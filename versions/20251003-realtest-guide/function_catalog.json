{
  "version": "20251003-realtest-guide",
  "generated_at": "2025-10-03T22:52:15.209829Z",
  "source_manual": "versions/20251003-realtest-guide/manual.txt",
  "entries": [
    {
      "name": "#Avg",
      "title": "#Avg",
      "aliases": [],
      "section": "17.18.1",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Cross-Sectional Functions",
      "description": "For each date, evaluates a formula and calculates the average value for all symbols on that date.",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.1",
          "title": "#Avg",
          "line": 3713
        }
      ],
      "sample_examples": [
        {
          "file": "samples/gics_indu_rank.rts",
          "line": 18,
          "code": "InduFactor:\t#Avg #ByIndu StockFactor\t// factor values averaged by industry"
        },
        {
          "file": "samples/sector_etfs_breadth.rts",
          "line": 41,
          "code": "SectFactor:\t#Avg #ByEcon StockFactor"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "#ByCII",
      "title": "#ByCII",
      "aliases": [],
      "section": "17.18.2",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Cross-Sectional Functions",
      "description": "A secondary cross-sectional function, which requests that the primary function be calculated separately for each group of stocks that share the same corresponding industry index",
      "example": "Ranks $SPX constituents separately by Norgate corresponding industry index. .",
      "notes": null,
      "see_also": [
        "?CII",
        "CIIFamily",
        "and CIILevel.See the cii_rotate.rts sample script for a complete"
      ],
      "manual_refs": [
        {
          "section": "17.18.2",
          "title": "#ByCII",
          "line": 3718
        }
      ],
      "sample_examples": [
        {
          "file": "samples/cii_rotate.rts",
          "line": 32,
          "code": "// use \"#ByCII\" after any breadth tag to calculate separately for each CII group"
        },
        {
          "file": "samples/industry_indices.rts",
          "line": 29,
          "code": "NewHighs:\t#sum #ByCII InSPX and C = HHV(C,252)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "#ByEcon",
      "title": "#ByEcon",
      "aliases": [],
      "section": "17.18.3",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Cross-Sectional Functions",
      "description": "A secondary cross-sectional function, which requests that the primary function be calculated separately for each group of stocks that share the same economic sector name",
      "example": "Calculates the average 100-bar ROC of all stocks in this economic sector and stores it as \"Econ ROC\" for each stock.",
      "notes": "Requires data with ?Econ Sect names in each stock record.Norgate provides these automatically -- use Classification to specify which scheme to request at Import time.For other data sources you would need to provide them via a Sym Info file.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.3",
          "title": "#ByEcon",
          "line": 3721
        }
      ],
      "sample_examples": [
        {
          "file": "samples/sector_etfs_breadth.rts",
          "line": 41,
          "code": "SectFactor:\t#Avg #ByEcon StockFactor"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "#ByGroup",
      "title": "#ByGroup",
      "aliases": [],
      "section": "17.18.4",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Cross-Sectional Functions",
      "description": "A secondary cross-sectional function, which requests that the primary function be calculated separately for each group of stocks that share the same industry group name",
      "example": "Calculates the average 100-bar ROC for all stocks in this industry group and stores it as \"Group ROC\" for each stock.",
      "notes": "Requires data with ?Ind Group names in each stock record.Norgate provides these automatically -- use Classification to specify which scheme to request at Import time.For other data sources you would need to provide them via a Sym Info file.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.4",
          "title": "#ByGroup",
          "line": 3724
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "#ByIndu",
      "title": "#ByIndu",
      "aliases": [],
      "section": "17.18.5",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Cross-Sectional Functions",
      "description": "A secondary cross-sectional function, which requests that the primary function be calculated separately for each group of stocks that share the same industry name",
      "example": "Calculates the average 100-bar ROC for all stocks in this industry and stores it as \"Indu ROC\" for each stock.",
      "notes": "Requires data with ?Industry names in each stock record.Norgate provides these automatically -- use Classification to specify which scheme to request at Import time.For other data sources you would need to provide them via a Sym Info file.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.5",
          "title": "#ByIndu",
          "line": 3730
        }
      ],
      "sample_examples": [
        {
          "file": "samples/gics_indu_rank.rts",
          "line": 18,
          "code": "InduFactor:\t#Avg #ByIndu StockFactor\t// factor values averaged by industry"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "#ByListNum",
      "title": "#ByListNum",
      "aliases": [],
      "section": "17.18.6",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Cross-Sectional Functions",
      "description": "A secondary cross-sectional function, which requests that the primary function be calculated separately for the stocks from each separate Include List",
      "example": "Counts the number of stocks in the same Include List as the current stock. is therefore only useful when each Include List contains unique symbols. The secondary cross-sectional ranking functions all work this way. For a stock cannot belong to more than one sector or industry.",
      "notes": "The List Num of a symbol is the number of the first Include List that it appears in. The above",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.6",
          "title": "#ByListNum",
          "line": 3733
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "#ByMkt",
      "title": "#ByMkt",
      "aliases": [],
      "section": "17.18.7",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Cross-Sectional Functions",
      "description": "A secondary cross-sectional function, which requests that the primary function be calculated separately for each group of individual futures contracts within the same market.",
      "example": "Rather than ranking all symbols in the data file by volume, each market-specific subset is ranked separately.Having defined this data item, you could then simply refer to Mkt Rank for the current symbol to see if it's the current highest-volume contract in its market.See the script futures_volume_rank.rts for a complete implementation of this.Note that this mechanism only works with Norgate\u2026",
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.7",
          "title": "#ByMkt",
          "line": 3739
        }
      ],
      "sample_examples": [
        {
          "file": "samples/futures_calendar_spread.rts",
          "line": 18,
          "code": "AgeRank:\t#Rank #ByMkt -DaysToExp"
        },
        {
          "file": "samples/futures_volume_rank.rts",
          "line": 2,
          "code": "shows how to use #ByMkt ranking in a universe of individual futures contracts"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "#BySect",
      "title": "#BySect",
      "aliases": [],
      "section": "17.18.8",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Cross-Sectional Functions",
      "description": "A secondary cross-sectional function, which requests that the primary function be calculated separately for each group of stocks that share the same business sector name",
      "example": "Calculates the average 100-bar ROC of all stocks in this sector and stores it as \"Sect ROC\" for each stock.",
      "notes": "Requires data with ?Sector names in each stock record.Norgate provides these automatically -- use Classification to specify which scheme to request at Import time.For other data sources you would need to provide them via a Sym Info file.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.8",
          "title": "#BySect",
          "line": 3742
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "#Count",
      "title": "#Count",
      "aliases": [],
      "section": "17.18.9",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Cross-Sectional Functions",
      "description": "For each date, calculates the count of symbols for which a formula can be evaluated on that date.",
      "example": null,
      "notes": "If the formula result is nan (not a number -- unable to calculate) then that stock is not included in the count.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.9",
          "title": "#Count",
          "line": 3745
        }
      ],
      "sample_examples": [
        {
          "file": "samples/breadth.rts",
          "line": 19,
          "code": "total:\t#count 1"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "#DenseRank",
      "title": "#DenseRank",
      "aliases": [],
      "section": "17.18.10",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Cross-Sectional Functions",
      "description": "For each date, evaluates a formula and then calculates the dense rank of each symbol's value among all symbols on that date. Lowest rank (1) means highest value. Identical values get the same rank number.",
      "example": "This first calculates a sector score as the average 20-day return of the symbols in that sector. All symbols in the same sector will have the same score. #Dense Rank is then used to assign sector ranks to each symbol starting with 1 for the top sector, 2 for the next sector, etc. This makes it possible to determine e.g. the top stock from each of the top 5 sectors using a custom scoring factor.",
      "notes": "If the formula result is nan (not a number -- unable to calculate) then that stock is not included in the ranking list (reducing the total count) and its rank value would be nan as well.If the formula result is the same for two symbols then they both get the same rank number. Use #Rank if you want every symbol to have a unique rank number.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.10",
          "title": "#DenseRank",
          "line": 3750
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "#Highest",
      "title": "#Highest",
      "aliases": [],
      "section": "17.18.11",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Cross-Sectional Functions",
      "description": "For each date, evaluates a formula and calculates the highest (largest) value for all symbols on that date.",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.11",
          "title": "#Highest",
          "line": 3753
        }
      ],
      "sample_examples": [
        {
          "file": "samples/cl_term_structure.rts",
          "line": 16,
          "code": "CL1:\t#Highest if(AgeRank=1, Symbol, 0)"
        },
        {
          "file": "samples/futures_calendar_spread.rts",
          "line": 19,
          "code": "Month1:\t#Highest #ByMkt if(AgeRank=1, Symbol, 0)"
        },
        {
          "file": "samples/vx_term_structure.rts",
          "line": 22,
          "code": "VX1:\t#Highest if(AgeRank=1, Symbol, 0)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "#Lowest",
      "title": "#Lowest",
      "aliases": [],
      "section": "17.18.12",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Cross-Sectional Functions",
      "description": "For each date, evaluates a formula and calculates the lowest (smallest) value for all symbols on that date.",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.12",
          "title": "#Lowest",
          "line": 3758
        }
      ],
      "sample_examples": [
        {
          "file": "samples/gics_indu_rank.rts",
          "line": 21,
          "code": "StockInduRank:\t#Lowest #ByIndu InduRank\t// the industry rank of each stock"
        },
        {
          "file": "samples/sector_etfs_breadth.rts",
          "line": 44,
          "code": "StockSectRank:\t#Lowest #ByEcon SectRank"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "#Median",
      "title": "#Median",
      "aliases": [],
      "section": "17.18.13",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Cross-Sectional Functions",
      "description": "For each date, evaluates a formula and calculates the median value for all symbols on that date.",
      "example": null,
      "notes": "If the formula result is nan (not a number -- unable to calculate) then that stock is not included in the count from which the median is derived.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.13",
          "title": "#Median",
          "line": 3760
        }
      ],
      "sample_examples": [
        {
          "file": "samples/index_breadth.rts",
          "line": 15,
          "code": "MedC:\t#Median C"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "#OnePerDate",
      "title": "#OnePerDate",
      "aliases": [],
      "section": "17.18.14",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Cross-Sectional Functions",
      "description": "Evaluate this Data or Test Data formula only once per date and return this value for any stock that references the item",
      "example": "Real Test now automatically applies #One Per Date even if not specified. Add this tag explicitly at the start of any formula to enforce this behavior.",
      "notes": "This is most applicable to something like Extern($SPY, C > MA(C,200)) where the result will be the same for all symbols.Prior to release 2.0.26.1 Real Test would nevertheless evaluate that same formula redundantly for every date of every symbol, and waste memory storing all these redundant values.For this specific",
      "see_also": [
        "#One Per Sym.Add both #One Per Date and #One Per Sym to calculate and store only a single value for all bars of all stocks (this is done automatically for constants and constant expressions)."
      ],
      "manual_refs": [
        {
          "section": "17.18.14",
          "title": "#OnePerDate",
          "line": 3763
        }
      ],
      "sample_examples": [
        {
          "file": "samples/annual_taxes.rts",
          "line": 13,
          "code": "LTGain:\t#OnePerDate if(SinceEOY > 0, Combined(TradeStatSum(if(DateYear(T.DateOut) = This(Year) and Days(T.DateIn, T.DateOut) > 366, T.Profit - T.Div, 0))), 0)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "#OnePerSym",
      "title": "#OnePerSym",
      "aliases": [],
      "section": "17.18.15",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Cross-Sectional Functions",
      "description": "Evaluate this Data or Test Data formula only once per symbol and return this same value for all bars.",
      "example": "Real Test now automatically applies #One Per Sym even if not specified. Add this tag explicitly at the start of any formula if to enforce this behavior.",
      "notes": "This is most applicable to something like Top(Info TRBC, 4) where the result will be the same for all symbols.Prior to release 2.0.26.1 Real Test would nevertheless evaluate that same formula redundantly for every date of every symbol, and waste memory storing all these redundant values.For this specific",
      "see_also": [
        "#One Per Date.Add both #One Per Date and #One Per Sym to calculate and store only a single value for all bars of all stocks (this is done automatically for constants and constant expressions)."
      ],
      "manual_refs": [
        {
          "section": "17.18.15",
          "title": "#OnePerSym",
          "line": 3768
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "#PercentRank",
      "title": "#PercentRank",
      "aliases": [],
      "section": "17.18.16",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Cross-Sectional Functions",
      "description": "For each date, evaluates a formula and then calculates the percent rank of each symbol's value among all symbols on that date.",
      "example": null,
      "notes": "The largest value will have a percent rank of 100, the lowest value 0, and the others will be distributed evenly between those extremes. If the formula result is nan (not a number -- unable to calculate) then that stock is not included in the ranking list (reducing the total count) and its rank value would be nan as well.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.16",
          "title": "#PercentRank",
          "line": 3770
        }
      ],
      "sample_examples": [
        {
          "file": "samples/clenow_stocks_on_move.rts",
          "line": 37,
          "code": "Percentile:\t#PercentRank 100 * CanRank + AdjSlope"
        },
        {
          "file": "samples/clenow_stocks_on_move_dynamic.rts",
          "line": 37,
          "code": "Percentile:\t#PercentRank 100 * CanRank + AdjSlope"
        },
        {
          "file": "samples/ibd_rs.rts",
          "line": 15,
          "code": "pctrnk:\t#PercentRank strength // \"inclusive\" (0-100) percent rank of strength"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "#Rank",
      "title": "#Rank",
      "aliases": [],
      "section": "17.18.17",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Cross-Sectional Functions",
      "description": "For each date, evaluates a formula and then calculates the rank of each symbol's value among all symbols on that date. Lowest rank (1) means highest value. Identical values get different rank numbers.",
      "example": null,
      "notes": "If the formula result is nan (not a number -- unable to calculate) then that stock is not included in the ranking list (reducing the total count) and its rank value would be nan as well.If the formula result is the same for two symbols then the one that comes first alphabetically gets the lower rank number. Use #Dense Rank if you want identical values to get the same rank number.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.17",
          "title": "#Rank",
          "line": 3775
        }
      ],
      "sample_examples": [
        {
          "file": "samples/cii_rotate.rts",
          "line": 27,
          "code": "InduRank:\t#Rank if(ListNum=99, ROC30, nan) // rank the index ETFs by the factor"
        },
        {
          "file": "samples/cl_term_structure.rts",
          "line": 15,
          "code": "AgeRank:\t#Rank if(InList(1), -DaysToExp, nan)"
        },
        {
          "file": "samples/futures_calendar_spread.rts",
          "line": 18,
          "code": "AgeRank:\t#Rank #ByMkt -DaysToExp"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "#SlowCalc",
      "title": "#SlowCalc",
      "aliases": [],
      "section": "17.18.18",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Cross-Sectional Functions",
      "description": "#Slow Calc is a special Data Section tag that looks like a cross-sectional function name but is not one.Specifying #Slow Calc at the beginning of a Data formula tells Real Test to NOT use the faster one-pass formula calculation mode for this formula.If you have a Data formula that you suspect may be calculating incorrect values, especially around bars with stock splits, try adding this tag to the start of the formula and recalculating it. If the output changes, keep the tag in place, otherwise remove it so the faster calculation speed can remain in use.",
      "example": "\"exponential slope\" calculation.",
      "notes": null,
      "see_also": [
        "Split Handling",
        "particularly the"
      ],
      "manual_refs": [
        {
          "section": "17.18.18",
          "title": "#SlowCalc",
          "line": 3778
        }
      ],
      "sample_examples": [
        {
          "file": "samples/clenow_stocks_on_move.rts",
          "line": 30,
          "code": "// AdjSlope calculation (#SlowCalc is required because log(c) of unadjusted prices can't be buffered)"
        },
        {
          "file": "samples/clenow_stocks_on_move_dynamic.rts",
          "line": 30,
          "code": "// AdjSlope calculation (#SlowCalc is required because log(c) of unadjusted prices can't be buffered)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "#StdDev",
      "title": "#StdDev",
      "aliases": [],
      "section": "17.18.19",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Cross-Sectional Functions",
      "description": "For each date, evaluates a formula and then calculates the standard deviation of values among all symbols on that date.",
      "example": null,
      "notes": "If the formula result is nan (not a number -- unable to calculate) then that stock is not included in the count that is used in the standard deviation calculation.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.19",
          "title": "#StdDev",
          "line": 3780
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "#Sum",
      "title": "#Sum",
      "aliases": [],
      "section": "17.18.20",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Cross-Sectional Functions",
      "description": "For each date, evaluates a formula and calculates the sum of values for all symbols on that date.",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.20",
          "title": "#Sum",
          "line": 3785
        }
      ],
      "sample_examples": [
        {
          "file": "samples/breadth.rts",
          "line": 20,
          "code": "numob:\t#sum ob"
        },
        {
          "file": "samples/hybrid_asset_allocation.rts",
          "line": 33,
          "code": "numOff:\t#sum holdOff"
        },
        {
          "file": "samples/hybrid_asset_allocation_dynamic.rts",
          "line": 32,
          "code": "numOff:\t#sum holdOff"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "?CII",
      "title": "?CII",
      "aliases": [],
      "section": "17.18.21",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Stock/Contract Information",
      "description": "Symbol of the corresponding industry index (CII) of the current security",
      "example": null,
      "notes": "The return value is a string which can be used in the Scan or Trades section or as input to any String Function.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.21",
          "title": "?CII",
          "line": 3787
        }
      ],
      "sample_examples": [
        {
          "file": "samples/industry_indices.rts",
          "line": 37,
          "code": "CII:\t?CII"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "?Currency",
      "title": "?Currency",
      "aliases": [],
      "section": "17.18.22",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Stock/Contract Information",
      "description": "Name of the currency that the security trades in",
      "example": null,
      "notes": "The return value is a string which can be used in the Scan or Trades section or as input to any String Function.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.22",
          "title": "?Currency",
          "line": 3789
        }
      ],
      "sample_examples": [
        {
          "file": "samples/djia_make_syminfo.rts",
          "line": 27,
          "code": "Cur:\t?Currency\t{\"Currency\"}"
        },
        {
          "file": "samples/djia_use_syminfo.rts",
          "line": 28,
          "code": "Cur:\t?Currency\t{\"Currency\"}"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "?Domicile",
      "title": "?Domicile",
      "aliases": [],
      "section": "17.18.23",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Stock/Contract Information",
      "description": "Name of the country of origin (domicile) of the security",
      "example": null,
      "notes": "The return value is a string which can be used in the Scan or Trades section or as input to any String Function.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.23",
          "title": "?Domicile",
          "line": 3791
        }
      ],
      "sample_examples": [
        {
          "file": "samples/djia_make_syminfo.rts",
          "line": 29,
          "code": "Domicile:\t?Domicile"
        },
        {
          "file": "samples/djia_use_syminfo.rts",
          "line": 30,
          "code": "Domicile:\t?Domicile"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "?EconSect",
      "title": "?EconSect",
      "aliases": [],
      "section": "17.18.24",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Stock/Contract Information",
      "description": "Name of the economic sector of the security (TRBC or GICS column 1)",
      "example": null,
      "notes": "The return value is a string which can be used in the Scan or Trades section or as input to any String Function.This value is also used for two-level Data item ranking when #Rank #By Econ is specified.Use Classification to specify which scheme to request at Import time.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.24",
          "title": "?EconSect",
          "line": 3796
        }
      ],
      "sample_examples": [
        {
          "file": "samples/djia_make_syminfo.rts",
          "line": 30,
          "code": "EconSect:\t?EconSect"
        },
        {
          "file": "samples/djia_use_syminfo.rts",
          "line": 31,
          "code": "EconSect:\t?EconSect"
        },
        {
          "file": "samples/sector_etfs_breadth.rts",
          "line": 57,
          "code": "ETFsect:\tExtern(SymNum(ETFstock), ?EconSect)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "?EndDate",
      "title": "?EndDate",
      "aliases": [],
      "section": "17.18.25",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General",
      "description": "The End Date setting value of the current script being run",
      "example": "Days(?Start Date, ?End Date) can be used to count the days of the current test.If a script includes run-mode-specific Settings Sections, the return value will reflect the setting from the section corresponding with the mode the script is running in. For , if Scan Settings has End Date: 2024-01-01 and Test Settings has End Date: 2020-01-01, ?End Date will be return the former if the script was run\u2026",
      "notes": "The date is returned as both a number (yyyymmdd) and a string (formatted).For",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.25",
          "title": "?EndDate",
          "line": 3798
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "?EquityType",
      "title": "?EquityType",
      "aliases": [],
      "section": "17.18.26",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Stock/Contract Information",
      "description": "Equity type of the security (Common/Ordinary, Unit, etc.)",
      "example": null,
      "notes": "The return value is a string which can be used in the Scan or Trades section or as input to any String Function.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.26",
          "title": "?EquityType",
          "line": 3800
        }
      ],
      "sample_examples": [
        {
          "file": "samples/djia_make_syminfo.rts",
          "line": 24,
          "code": "EquityType:\t?EquityType"
        },
        {
          "file": "samples/djia_use_syminfo.rts",
          "line": 25,
          "code": "EquityType:\t?EquityType"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "?Exchange",
      "title": "?Exchange",
      "aliases": [],
      "section": "17.18.27",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Stock/Contract Information",
      "description": "Name of the exchange that the security trades on",
      "example": null,
      "notes": "The return value is a string which can be used in the Scan or Trades section or as input to any String Function.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.27",
          "title": "?Exchange",
          "line": 3804
        }
      ],
      "sample_examples": [
        {
          "file": "samples/djia_make_syminfo.rts",
          "line": 26,
          "code": "Exchange:\t?Exchange"
        },
        {
          "file": "samples/djia_use_syminfo.rts",
          "line": 27,
          "code": "Exchange:\t?Exchange"
        },
        {
          "file": "samples/import_tiingo.rts",
          "line": 34,
          "code": "Exchange:\t?Exchange"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "?IndGroup",
      "title": "?IndGroup",
      "aliases": [],
      "section": "17.18.28",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Stock/Contract Information",
      "description": "Name of the industry group of the security (TRBC or GICS column 3)",
      "example": null,
      "notes": "The return value is a string which can be used in the Scan or Trades section or as input to any String Function.This value is also used for two-level Data item ranking when #Rank #By Group is specified.Use Classification to specify which scheme to request at Import time.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.28",
          "title": "?IndGroup",
          "line": 3806
        }
      ],
      "sample_examples": [
        {
          "file": "samples/djia_make_syminfo.rts",
          "line": 32,
          "code": "IndGroup:\t?IndGroup"
        },
        {
          "file": "samples/djia_use_syminfo.rts",
          "line": 33,
          "code": "IndGroup:\t?IndGroup"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "?Industry",
      "title": "?Industry",
      "aliases": [],
      "section": "17.18.29",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Stock/Contract Information",
      "description": "Name of the industry of the security (TRBC or GICS column 4)",
      "example": null,
      "notes": "The return value is a string which can be used in the Scan or Trades section or as input to any String Function.This value is also used for two-level Data item ranking when #Rank #By Indu is specified.Use Classification to specify which scheme to request at Import time.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.29",
          "title": "?Industry",
          "line": 3808
        }
      ],
      "sample_examples": [
        {
          "file": "samples/djia_make_syminfo.rts",
          "line": 33,
          "code": "Industry:\t?Industry"
        },
        {
          "file": "samples/djia_use_syminfo.rts",
          "line": 34,
          "code": "Industry:\t?Industry"
        },
        {
          "file": "samples/gics_indu_rank.rts",
          "line": 26,
          "code": "InduName:\t?Industry"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "?ListingType",
      "title": "?ListingType",
      "aliases": [],
      "section": "17.18.30",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Stock/Contract Information",
      "description": "Listing type of the security (Primary, ADR, etc.)",
      "example": null,
      "notes": "The return value is a string which can be used in the Scan or Trades section or as input to any String Function.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.30",
          "title": "?ListingType",
          "line": 3810
        }
      ],
      "sample_examples": [
        {
          "file": "samples/djia_make_syminfo.rts",
          "line": 25,
          "code": "ListingType:\t?ListingType"
        },
        {
          "file": "samples/djia_use_syminfo.rts",
          "line": 26,
          "code": "ListingType:\t?ListingType"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "?LocalTime",
      "title": "?LocalTime",
      "aliases": [],
      "section": "17.18.31",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General",
      "description": "Returns the current local date and time",
      "example": null,
      "notes": "When used as a String the format is yyyy-mm-dd hh:mm:ss, e.g. \"2023-12-21 14:40:05\"When used as a number the value is yyyymmdd.hhmmss, e.g. 20231221.144005",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.31",
          "title": "?LocalTime",
          "line": 3815
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "?Name",
      "title": "?Name",
      "aliases": [],
      "section": "17.18.32",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Stock/Contract Information",
      "description": "Name of the security (company or security name)",
      "example": null,
      "notes": "The return value is a string which can be used in the Scan or Trades section or as input to any String Function.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.32",
          "title": "?Name",
          "line": 3817
        }
      ],
      "sample_examples": [
        {
          "file": "samples/cii_rotate.rts",
          "line": 53,
          "code": "Industry:\tExtern(&cii,?Name)"
        },
        {
          "file": "samples/djia_make_syminfo.rts",
          "line": 22,
          "code": "Name:\t?Name"
        },
        {
          "file": "samples/djia_use_syminfo.rts",
          "line": 23,
          "code": "Name:\t?Name"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "?ReportingCurrency",
      "title": "?ReportingCurrency",
      "aliases": [],
      "section": "17.18.33",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Stock/Contract Information",
      "description": "Name of the currency that the security reports earnings in",
      "example": null,
      "notes": "The return value is a string which can be used in the Scan or Trades section or as input to any String Function.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.33",
          "title": "?ReportingCurrency",
          "line": 3819
        }
      ],
      "sample_examples": [
        {
          "file": "samples/djia_make_syminfo.rts",
          "line": 28,
          "code": "RepCur:\t?ReportingCurrency\t{\"ReportingCurrency\"}"
        },
        {
          "file": "samples/djia_use_syminfo.rts",
          "line": 29,
          "code": "RepCur:\t?ReportingCurrency\t{\"ReportingCurrency\"}"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "?RunMode",
      "title": "?RunMode",
      "aliases": [],
      "section": "17.18.34",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General",
      "description": "Name of the mode in which the script is being run",
      "example": null,
      "notes": "The return value is a string containing one of these run-mode names:",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.34",
          "title": "?RunMode",
          "line": 3821
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "?ScriptName",
      "title": "?ScriptName",
      "aliases": [],
      "section": "17.18.35",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General",
      "description": "Name of the script being run",
      "example": "?Script Name would be \"mr_sample\" for c:\\Real Test\\Scripts\\Examples\\mr_sample.rts.",
      "notes": "The string returned is the name of the current script with neither the full folder path nor the .RTS extension. For",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.35",
          "title": "?ScriptName",
          "line": 3825
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "?Sector",
      "title": "?Sector",
      "aliases": [],
      "section": "17.18.36",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Stock/Contract Information",
      "description": "Name of the business sector of the security (TRBC or GICS column 2)",
      "example": null,
      "notes": "The return value is a string which can be used in the Scan or Trades section or as input to any String Function.This value is also used for two-level Data item ranking when #Rank #By Sect is specified.Use Classification to specify which scheme to request at Import time.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.36",
          "title": "?Sector",
          "line": 3827
        }
      ],
      "sample_examples": [
        {
          "file": "samples/djia_make_syminfo.rts",
          "line": 31,
          "code": "Sector:\t?Sector"
        },
        {
          "file": "samples/djia_use_syminfo.rts",
          "line": 32,
          "code": "Sector:\t?Sector"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "?StartDate",
      "title": "?StartDate",
      "aliases": [],
      "section": "17.18.39",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General",
      "description": "The Start Date setting value of the current script being run",
      "example": "Days(?Start Date, ?End Date) can be used to count the days of the current test.If a script includes run-mode-specific Settings Sections, the return value will reflect the setting from the section corresponding with the mode the script is running in. For , if Scan Settings has Start Date: 2024-01-01 and Test Settings has Start Date: 2020-01-01, ?Start Date will be return the former if the script\u2026",
      "notes": "The date is returned as both a number (yyyymmdd) and a string (formatted).For",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.39",
          "title": "?StartDate",
          "line": 3836
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "?Strategy",
      "title": "?Strategy",
      "aliases": [],
      "section": "17.18.37",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Current Strategy Information",
      "description": "Name of the current strategy",
      "example": null,
      "notes": "The return value is a string containing the full name of the current strategy.",
      "see_also": [
        "Strat Num",
        "which returns the current strategy's number",
        "and Strat Ref",
        "which allows dynamic strategy lookup."
      ],
      "manual_refs": [
        {
          "section": "17.18.37",
          "title": "?Strategy",
          "line": 3829
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "?StratType",
      "title": "?StratType",
      "aliases": [],
      "section": "17.18.38",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Current Strategy Information",
      "description": "Type of the current strategy",
      "example": null,
      "notes": "The return value is a string containing the type of the current strategy.Possible return values are:\u00b7 Benchmark - the strategy is a Benchmark\u00b7 Stats Group - the strategy is a Stats Group or Combined\u00b7 Strategy - the strategy is a regular Strategy",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.38",
          "title": "?StratType",
          "line": 3831
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "?Symbol",
      "title": "?Symbol",
      "aliases": [],
      "section": "17.18.40",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Stock/Contract Information",
      "description": "Symbol of the current security",
      "example": null,
      "notes": "The return value is a string which can be used in the Scan or Trades section or as input to any String Function.",
      "see_also": [
        "Symbol",
        "which returns the current symbol as a constant Symbol Reference",
        "and Sym Ref",
        "which allows dynamic symbol lookup.?Symbol = \"MSFT\" and Symbol = $MSFT would both accomplish the same purpose",
        "but it is slightly more efficient to use symbol constants. Symbol constants also have the advantage of smart auto-complete when entering them."
      ],
      "manual_refs": [
        {
          "section": "17.18.40",
          "title": "?Symbol",
          "line": 3838
        }
      ],
      "sample_examples": [
        {
          "file": "samples/correl_multi.rts",
          "line": 41,
          "code": "CorrMinSym:\tExtern(SymNum(corr_min_sym), ?Symbol)"
        },
        {
          "file": "samples/dalio_all_weather.rts",
          "line": 28,
          "code": "Quantity:\tItem(\"alloc{?}\", ?symbol)"
        },
        {
          "file": "samples/dalio_all_weather_maxdiff.rts",
          "line": 27,
          "code": "TgtPct:\tItem(\"alloc{?}\", ?symbol)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "?Type",
      "title": "?Type",
      "aliases": [],
      "section": "17.18.41",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Stock/Contract Information",
      "description": "Type of the security",
      "example": null,
      "notes": "When used in place of a formula, causes this text to be displayed in a column.Can only be used in the Scan or Trades section.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.41",
          "title": "?Type",
          "line": 3840
        }
      ],
      "sample_examples": [
        {
          "file": "samples/djia_make_syminfo.rts",
          "line": 23,
          "code": "Type:\t?Type"
        },
        {
          "file": "samples/djia_use_syminfo.rts",
          "line": 24,
          "code": "Type:\t?Type"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Abs",
      "title": "Abs",
      "aliases": [],
      "section": "17.18.42",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Absolute Value of a number",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.42",
          "title": "Abs",
          "line": 3844
        }
      ],
      "sample_examples": [
        {
          "file": "samples/clenow_stocks_on_move.rts",
          "line": 36,
          "code": "CanRank:\tInSPX and C > MA(C,100) and CountTrue(ABS(ROC(C,1))>=15, 90) == 0"
        },
        {
          "file": "samples/clenow_stocks_on_move_dynamic.rts",
          "line": 36,
          "code": "CanRank:\tInSPX and C > MA(C,100) and CountTrue(ABS(ROC(C,1))>=15, 90) == 0"
        },
        {
          "file": "samples/dalio_all_weather_maxdiff.rts",
          "line": 28,
          "code": "Diff:\tAbs(CurPct - TgtPct)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "AccountSize",
      "title": "AccountSize",
      "aliases": [],
      "section": "17.18.43",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "Dollars in the simulated account at the beginning of each backtest",
      "example": null,
      "notes": "If Account Size is not specified in a script then the value from the Settings Panel will be used.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.43",
          "title": "AccountSize",
          "line": 3846
        }
      ],
      "sample_examples": [
        {
          "file": "samples/actual_trades.rts",
          "line": 18,
          "code": "AccountSize:\t100000"
        },
        {
          "file": "samples/bensdorp_book.rts",
          "line": 13,
          "code": "AccountSize:\t100000"
        },
        {
          "file": "samples/bottomup/actual_trades.rts",
          "line": 18,
          "code": "AccountSize:\t100000"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "AccountType",
      "title": "AccountType",
      "aliases": [],
      "section": "17.18.44",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "Specifies the type of account being modeled.Choices Cash Same Day - model a cash account where sale proceeds can be reinvested the same day Cash Next Day - model a cash account where sale proceeds can't be reinvested until the next day Margin - model a margin account (default)",
      "example": null,
      "notes": "This setting affects backtests and order generation in the following ways:\u00b7 In the Margin account model, Min Free Cash defaults to unlimited (can become negative) while in either Cash model, Min Free Cash defaults to 0 (can't become negative).\u00b7 In the Margin and Cash Same Day models, proceeds from sales made today can be used immediately to buy other positions, while in the Cash Next Day model there is a one-day delay before those proceeds can be used.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.44",
          "title": "AccountType",
          "line": 3848
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Adjustment",
      "title": "Adjustment",
      "aliases": [],
      "section": "17.18.45",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Import Specification",
      "description": "Price data adjustment setting",
      "example": null,
      "notes": "Real Test receives adjusted and unadjusted prices along with split and dividend histories from Norgate and some other sources. Imported data is then stored and used in unadjusted form so that each price reference on a given date reflects the actual price that was traded on that date. When necessary for multi-bar indicator calculation or lookback comparisons, on-the-fly adjustment is performed.See Split Handling for additional details about how this works.General best practice is to use the default Capital in most cases. Here are the trade-offs for each choice:\u00b7 Total Return converts all\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.45",
          "title": "Adjustment",
          "line": 3853
        }
      ],
      "sample_examples": [
        {
          "file": "samples/dividend_capture.rts",
          "line": 9,
          "code": "ExcludeIf:\tsincetrue(Dividend > 0.2 and C < 100) < 0\t// evaluated for latest bar so need explicit split-unadjustment"
        },
        {
          "file": "samples/dividend_yield_series.rts",
          "line": 9,
          "code": "Adjustment:\tCapitalSpecial\t// convert special dividends to splits so yield will only include ordinary ones"
        },
        {
          "file": "samples/hybrid_asset_allocation.rts",
          "line": 7,
          "code": "Adjustment:\tTotalReturn"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "ADX",
      "title": "ADX",
      "aliases": [],
      "section": "17.18.46",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Indicator Functions",
      "description": "Wilder's Average Directional Index",
      "example": null,
      "notes": "Calculation uses the original Welles Wilder formula. Wilder's exponential smoothing is equivalent to using 2*len-1 in a regular exponential moving average.This indicator supports one-pass calculation when used in the Data Section with a non-variable length.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.46",
          "title": "ADX",
          "line": 3855
        }
      ],
      "sample_examples": [
        {
          "file": "samples/bensdorp_book.rts",
          "line": 34,
          "code": "adx7:\tadx(7)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "AEMA",
      "title": "AEMA",
      "aliases": [],
      "section": "17.18.47",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Adaptive Exponential Moving Average",
      "example": null,
      "notes": "An AEMA is an EMA that supports a variable weighting factor. In other words, an EMA is an AEMA with a constant weight.The count of an EMA becomes a weight factor using the formula factor = 2 / (count + 1).Conversely the factor of an AEMA can be converted to a EMA count using count = (2 - factor) / factor.In both cases the average series is created by repeatedly calculating new Average = old Average + factor * (new Value - old Average).The key difference between the functions is that while the EMA count is evaluated only once before the series of values is calculated, the AEMA factor is\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.47",
          "title": "AEMA",
          "line": 3860
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "AESD",
      "title": "AESD",
      "aliases": [],
      "section": "17.18.48",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Adaptive Exponential Standard Deviation",
      "example": null,
      "notes": "This function calculates a standard deviation of values as an exponential series using a constant weighting factor represented as a bar count.As with the ESD function, the weighting factor is used both to calculate an exponential mean of values and one of squared differences.As with the AEMA function, the factor is equivalent to 2 / (count + 1) of an ESD and is reevaluated for every bar of the calculation, thus making it adaptive.This function supports one-pass calculation when used in the Data Section with a non-variable count.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.48",
          "title": "AESD",
          "line": 3862
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Allocation",
      "title": "Allocation",
      "aliases": [],
      "section": "17.18.49",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Dollars allocated to this strategy Input Any formula specifying a dollar amount",
      "example": "of each of these alternatives.The default allocation is Combined(S.Equity) when no Start Percent is specified (all strategies in one account).Strategies that specify Start Percent have a default allocation of S.Equity (each strategy in its own account).Strategies that specify Compounded: False have a default allocation of S.Start Equity (maintain a constant dollar allocation).The S.Alloc variable\u2026",
      "notes": "In most scripts it is not necessary to specify Allocation.It is generally not recommended to use Allocation to specify the fraction of the account that a strategy should use. Instead apply the fraction via the Quantity formula when modeling combined compounding, or use Start Percent to specify an initial fraction when modeling strategies trading in separate accounts.See Asset Allocation and Position Sizing for an",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.49",
          "title": "Allocation",
          "line": 3867
        }
      ],
      "sample_examples": [
        {
          "file": "samples/combined.rts",
          "line": 31,
          "code": "Quantity:\t30 \t// 30% allocation to one ETF"
        },
        {
          "file": "samples/combined_multi_bar_size.rts",
          "line": 30,
          "code": "Quantity:\t30 \t// 30% allocation to one ETF"
        },
        {
          "file": "samples/combined_rebalance.rts",
          "line": 17,
          "code": "// functions used by each strategy for Allocation and CashInOut"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "AllowMissingBar",
      "title": "AllowMissingBar",
      "aliases": [],
      "section": "17.18.50",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Whether to allow backtests to enter and exit positions after missing bars Input True or False (default is False)",
      "example": null,
      "notes": "A \"missing bar\" is a bar that is absent in this stock while being present in most other stocks from the same exchange.Often these are caused by temporary \"halt\" conditions. Missing bars can also simply reflect days when there was no trading volume. (Unless Padding is specified, Real Test does not import zero-volume bars.) By default Real Test will not allow an entry or an exit in a backtest to occur on any bar for which the prior bar's date is not the prior date in the trading calendar of the exchange (the prior date of most other symbols). This models a daily process that only places orders\u2026",
      "see_also": [
        "the general topic of Calendar Alignment and the Missing Bars function",
        "which can be used to count missing bars."
      ],
      "manual_refs": [
        {
          "section": "17.18.50",
          "title": "AllowMissingBar",
          "line": 3872
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "AllowNoVolume",
      "title": "AllowNoVolume",
      "aliases": [],
      "section": "17.18.51",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Whether to allow backtests to enter and exit positions on bars with zero volume Input True or False (default is False)",
      "example": null,
      "notes": "Most data providers including Norgate do not provide bars for days on which there were no trades.The Padding setting All Market Days can be added to an Import definition to include those bars.Bars added as padding always have zero volume and zero price movement (Open, High, Low, Close are all equal to the prior close).By default Real Test will not allow an entry or an exit in a backtest to occur on such a bar, since in live trading there could have been no such transaction.If you have a use case that requires transactions on zero-volume bars, add Allow No Volume: True to your Strategy\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.51",
          "title": "AllowNoVolume",
          "line": 3874
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "AllowSameName",
      "title": "AllowSameName",
      "aliases": [],
      "section": "17.18.52",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings Input True or False (default is False)",
      "description": "If True, Real Test will allows items in sections with user-defined names to be replaced by defining a new item with the same name.If False (the default), the parser shows an error message whenever the same name is used twice.",
      "example": null,
      "notes": "See Combining Scripts for more information about this setting.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.52",
          "title": "AllowSameName",
          "line": 3879
        }
      ],
      "sample_examples": [
        {
          "file": "samples/namespace_example.rts",
          "line": 5,
          "code": "AllowSameName: \tTrue"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "AlwaysImport",
      "title": "AlwaysImport",
      "aliases": [],
      "section": "17.18.53",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings Input True or False (default is False)",
      "description": "If True, Real Test will always run an Import (if the script has defined one) when any Run mode is initiated, prior to running the script in the requested mode.If False (the default), Real Test only runs an Import when Import was the requested run mode.",
      "example": null,
      "notes": "It is not advisable to leave this setting on True unless you have a specific need to do so. Importing data can be a time-consuming process. Doing so redundantly defeats the purpose of Real Test's local data file architecture.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.53",
          "title": "AlwaysImport",
          "line": 3881
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Ambiguity",
      "title": "Ambiguity",
      "aliases": [],
      "section": "17.18.54",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Specifies what assumptions to make when there is price sequence ambiguity in a test Choices Default - assume that if Close > Open then Low preceded High, or if Close < Open then High preceded Low (best guess) Stop - always exit at the stop price if that price was touched (most pessimistic) Target - always exit at the target (limit) price if that price was touched (most optimistic) Neither - do not exit if exit price cannot be determined with zero ambiguity (most strict)",
      "example": "is a target and stop both being hit within a wide-range bar. Another is a limit order entry and target exit within a single bar. The \"Default\" (best guess) choice is used if Ambiguity is not specified, and in most situations this will provide the most realistic results.In order to see how often this setting is being applied, run your test with Test Output: Log and then search the log file for the\u2026",
      "notes": "This constant specifies what Real Test should do in a trade where more than one outcome could occur within the same bar and where a smaller timeframe bar would be required to know for sure which outcome happened first.One",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.54",
          "title": "Ambiguity",
          "line": 3883
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "ArcCos",
      "title": "ArcCos",
      "aliases": [],
      "section": "17.18.55",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Determines which angle has the specified Cosine",
      "example": null,
      "notes": "The return value is expressed in degrees (0 to 180).To convert degrees to radians, divide by 57.2957795131.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.55",
          "title": "ArcCos",
          "line": 3888
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "ArcSin",
      "title": "ArcSin",
      "aliases": [],
      "section": "17.18.56",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Determines which angle has the specified Sine",
      "example": null,
      "notes": "The return value is expressed in degrees (-90 to 90).To convert degrees to radians, divide by 57.2957795131.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.56",
          "title": "ArcSin",
          "line": 3890
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "ArcTan",
      "title": "ArcTan",
      "aliases": [],
      "section": "17.18.57",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Determines which angle has the specified Tangent",
      "example": null,
      "notes": "The return value is expressed in degrees (-90 to 90).To convert degrees to radians, divide by 57.2957795131.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.57",
          "title": "ArcTan",
          "line": 3892
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Arg1-Arg9",
      "title": "Arg1-Arg9",
      "aliases": [],
      "section": "17.18.58",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Library Section",
      "description": "Special variables that can be used within a Library formula to access the arguments that were passed to it",
      "example": "my Lib Func(close) would first evaluate \"close\" to determine the current close, then pass it to the function.This implies that library functions that use arg1-arg9 should not attempt to pass these along to a multi-bar function, refer to them with a bar offset, etc. A that point they are constants, not arrays.",
      "notes": "Library items can be referenced either with or without arguments. When referenced with arguments (so that the reference looks like a function call), the item formula can obtain the values passed in as arguments by using these numbered variables. Arg1 is the first (leftmost) argument, Arg2 the second one, and so on.Library function arguments can be either numbers or strings (or formulas that evaluate to either).Library arguments are \"passed by value\" (not \"by reference\"). For",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.58",
          "title": "Arg1-Arg9",
          "line": 3896
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Assert",
      "title": "Assert",
      "aliases": [],
      "section": "17.18.59",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Require a condition to be true for the script to continue",
      "example": null,
      "notes": "When the condition is true, the function does nothing.When the condition is false, a pop-up message appears: The default text shows the assertion that failed and which formula, strategy, symbol, date and time the formula was being evaluated for.If the optional text parameter is provided that text is displayed in place of the above.The script can either be continued (Yes) or stopped (No) after the pop-up is dismissed.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.59",
          "title": "Assert",
          "line": 3898
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "ATR",
      "title": "ATR",
      "aliases": [],
      "section": "17.18.60",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Indicator Functions",
      "description": "Wilder's Average True Range",
      "example": null,
      "notes": "Calculation uses the original Welles Wilder formula. Wilder's exponential smoothing is equivalent to using 2*len-1 in a regular exponential moving average.This indicator supports one-pass calculation when used in the Data Section with a non-variable length.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.60",
          "title": "ATR",
          "line": 3904
        }
      ],
      "sample_examples": [
        {
          "file": "samples/bensdorp_book.rts",
          "line": 29,
          "code": "atr10:\tatr(10)"
        },
        {
          "file": "samples/breadth.rts",
          "line": 2,
          "code": "Calculates the number of S&P components that closed outside a 20-day 1-ATR Keltner channel each day"
        },
        {
          "file": "samples/clenow_stocks_on_move.rts",
          "line": 28,
          "code": "// ATR"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "BarDate",
      "title": "BarDate",
      "aliases": [],
      "section": "17.18.61",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Bar Data Values",
      "description": "Date of this bar",
      "example": null,
      "notes": "Returns the current bar end date as a number in YYYYMMDD format.If the bar is of non-daily Bar Size, then this will be the closing date of the bar.Use Bar Start to get the opening date of the current bar.Negative offsets, e.g. Bar Date[-5], can be legitimately used to obtain the date of a future bar. This works even if the offset goes beyond the range of the currently loaded data file. For best results when future dates are required, a Holiday List should also be provided.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.61",
          "title": "BarDate",
          "line": 3908
        }
      ],
      "sample_examples": [
        {
          "file": "samples/cl_term_structure.rts",
          "line": 14,
          "code": "DaysToExp:\tDays(BarDate, InfoExpiry)"
        },
        {
          "file": "samples/futures_calendar_spread.rts",
          "line": 17,
          "code": "DaysToExp:\tDays(BarDate, InfoExpiry)"
        },
        {
          "file": "samples/ndx_plus_wtf_script.rts",
          "line": 64,
          "code": "Stop:\tif(T.Strat = 2 and BarDate>=T.DateIn and BarDate <= T.DateOut, wtf_trail, nan)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "BarNum",
      "title": "BarNum",
      "aliases": [],
      "section": "17.18.62",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Bar Data Values",
      "description": "Ordinal number of a bar within the data for that stock. The earliest bar is 1, next earliest is 2, etc.",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.62",
          "title": "BarNum",
          "line": 3910
        }
      ],
      "sample_examples": [
        {
          "file": "samples/breadth.rts",
          "line": 30,
          "code": "Filter:\tSymbol = $SPY and BarNum > 20"
        },
        {
          "file": "samples/combined_multi_bar_size.rts",
          "line": 52,
          "code": "EntrySetup:\tBarNum>12 and InNDX and Extern($SPY, Extern(~Daily, C > MA(C,200)))"
        },
        {
          "file": "samples/flipper.rts",
          "line": 25,
          "code": "flip:\tif(barnum==1, c,"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "BarsHeld",
      "title": "BarsHeld",
      "aliases": [],
      "section": "17.18.63",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Current Position Information",
      "description": "The number of bars since this position was entered, not including the entry day",
      "example": ", if you entered on Monday and want to exit on Friday, your Exit Rule formula would be Bars Held=4 (assuming there were no holidays that week). You are exiting the 4th trading day after your entry day.If used as Combined(Bars Held) when multiple positions are open in the same symbol (whether due to pyramiding or multiple strategies), the oldest entry date (largest value of Bars Held) for that\u2026",
      "notes": "For daily bars, it is easiest to think of this as Nights Held.This will generally be used in the Exit Rule formula to implement a Time Stop. For",
      "see_also": [
        "Entry Date."
      ],
      "manual_refs": [
        {
          "section": "17.18.63",
          "title": "BarsHeld",
          "line": 3912
        }
      ],
      "sample_examples": [
        {
          "file": "samples/bensdorp_book.rts",
          "line": 102,
          "code": "ExitStop:\tMax(FillPrice - 5 * atr20, HHV(C,BarsHeld)*0.75)"
        },
        {
          "file": "samples/futures_trend_follow_csi.rts",
          "line": 49,
          "code": "ExitStop:\tHighest(LongStop, BarsHeld + 1) // Trailing Stop"
        },
        {
          "file": "samples/futures_trend_follow_simple.rts",
          "line": 37,
          "code": "ExitRule:\tC <= Max(FillPrice - Stop[BarsHeld+1], Lowest(C, Breaklen))"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "BarSize",
      "title": "BarSize",
      "aliases": [],
      "section": "17.18.65",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings or Strategy Elements or Data",
      "description": "Specifies the default bar size (periodicity) for scans and/or tests, a strategy-specific bar size, or the bar size for a group of data items.",
      "example": null,
      "notes": "Valid values are Daily, Weekly, Monthly, Quarterly, Yearly.If Settings Bar Size is not specified in a script then the value from the Settings Panel will be used.See Bar Sizes and Multiple Timeframes for more information about how this works.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.65",
          "title": "BarSize",
          "line": 3919
        }
      ],
      "sample_examples": [
        {
          "file": "samples/Sample1.rts",
          "line": 16,
          "code": "BarSize:\tDaily"
        },
        {
          "file": "samples/Sample2.rts",
          "line": 9,
          "code": "BarSize:\tDaily"
        },
        {
          "file": "samples/Sample2a.rts",
          "line": 9,
          "code": "BarSize:\tDaily"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "BarsLeft",
      "title": "BarsLeft",
      "aliases": [],
      "section": "17.18.64",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Bar Data Values",
      "description": "The number of bars remaining before the end of data for this symbol",
      "example": null,
      "notes": "Bars Left is 0 for the last bar, 1 for the next-to-last bar, and so on.This can be used in the Entry Setup formula to avoid entering positions in stocks that will soon be delisted. Real Test will automatically exit any position that remains open on the last data date (or last date of a test) at the close of that bar, so it is not necessary to use Bars Left unless you want to be sure to exit before the last date.Bars Left can also be useful when modeling futures rollovers using individual contract data.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.64",
          "title": "BarsLeft",
          "line": 3914
        }
      ],
      "sample_examples": [
        {
          "file": "samples/futures_trend_follow_simple.rts",
          "line": 21,
          "code": "Liquid:\tLowest(V,5) > VolMin and BarsLeft > 5"
        },
        {
          "file": "samples/futures_volume_rank.rts",
          "line": 15,
          "code": "MktRank: #rank #ByMkt if(InList(2) and BarsLeft >= 5, Volume, -1)"
        },
        {
          "file": "samples/turtles.rts",
          "line": 31,
          "code": "Universe:\tInList(list) and Liquid and (list==1 or BarsLeft > 63)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "BarStart",
      "title": "BarStart",
      "aliases": [],
      "section": "17.18.66",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Bar Data Values",
      "description": "Start Date of this bar",
      "example": null,
      "notes": "Returns the current bar start date as a number in YYYYMMDD format.Use Bar Date to get the current bar end date.If the bar has daily Bar Size, then Bar Date and Bar Start are the same.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.66",
          "title": "BarStart",
          "line": 3921
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "BBBot",
      "title": "BBBot",
      "aliases": [],
      "section": "17.18.67",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Indicator Functions",
      "description": "Bollinger band bottom",
      "example": null,
      "notes": "This is equivalent to Avg(C, len) - (mult * Std Dev(C, len)).To calculate BBBot for something other than Close use BBBot F.This function supports one-pass calculation when used in the Data Section with a non-variable count.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.67",
          "title": "BBBot",
          "line": 3923
        }
      ],
      "sample_examples": [
        {
          "file": "samples/radge_bbo.rts",
          "line": 32,
          "code": "BBL:  \tBBBOT(100,1)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "BBBotF",
      "title": "BBBotF",
      "aliases": [],
      "section": "17.18.68",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Bollinger band bottom as a function",
      "example": null,
      "notes": "The BBBot indicator always uses the series of closing prices for its calculations. This function makes it possible to calculate the Bollinger band bottom of any series of values.This function supports one-pass calculation when used in the Data Section with a non-variable count.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.68",
          "title": "BBBotF",
          "line": 3928
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "BBPct",
      "title": "BBPct",
      "aliases": [],
      "section": "17.18.69",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Indicator Functions",
      "description": "Bollinger band percent (%B)",
      "example": null,
      "notes": "This indicator returns the position of Close relative to the Bollinger bands.This is equivalent to (Close - BBBot(len, mult)) / (BBTop(len, mult) - BBBot(len, mult)).The return value is:\u00b7 >1 if close is above the top band\u00b7 1 if close equals the top band\u00b7 0.5 if close equals the moving average\u00b7 0 if close equals the bottom band\u00b7 <0 if close is below the bottom band To calculate BBPct for something other than Close use BBPct F.This function supports one-pass calculation when used in the Data Section with a non-variable count.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.69",
          "title": "BBPct",
          "line": 3930
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "BBPctF",
      "title": "BBPctF",
      "aliases": [],
      "section": "17.18.70",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Bollinger band percent (%B) as a function",
      "example": null,
      "notes": "The BBPct indicator always uses the series of closing prices for its calculations. This function makes it possible to calculate the %B of any series of values.This function supports one-pass calculation when used in the Data Section with a non-variable count.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.70",
          "title": "BBPctF",
          "line": 3935
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "BBTop",
      "title": "BBTop",
      "aliases": [],
      "section": "17.18.71",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Indicator Functions",
      "description": "Bollinger band top",
      "example": null,
      "notes": "This is equivalent to Avg(C, len) + (mult * Std Dev(C, len)).To calculate BBTop for something other than Close use BBTop F.This function supports one-pass calculation when used in the Data Section with a non-variable count.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.71",
          "title": "BBTop",
          "line": 3937
        }
      ],
      "sample_examples": [
        {
          "file": "samples/radge_bbo.rts",
          "line": 31,
          "code": "BBH:  \tBBTOP(100,3)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "BBTopF",
      "title": "BBTopF",
      "aliases": [],
      "section": "17.18.72",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Bollinger band top as a function",
      "example": null,
      "notes": "The BBTop indicator always uses the series of closing prices for its calculations. This function makes it possible to calculate the Bollinger band top of any series of values.This function supports one-pass calculation when used in the Data Section with a non-variable count.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.72",
          "title": "BBTopF",
          "line": 3942
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "BBTrend",
      "title": "BBTrend",
      "aliases": [],
      "section": "17.18.73",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Indicator Functions",
      "description": "Bollinger band trend",
      "example": null,
      "notes": "The BBTrend indicator is calculated as follows:lower = ABS(BBBot(len1, mult) - BBBot(len2, mult))upper = ABS(BBTop(len1, mult) - BBTop(len2, mult)) BBTrend = (lower - upper) / Avg(C, len1) This indicator is intended to signal both strength and direction of trend.To calculate BBTrend for something other than Close use BBTrend F.This function supports one-pass calculation when used in the Data Section with a non-variable count.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.73",
          "title": "BBTrend",
          "line": 3944
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "BBTrendF",
      "title": "BBTrendF",
      "aliases": [],
      "section": "17.18.74",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Bollinger band trend as a function",
      "example": null,
      "notes": "The BBTrend indicator always uses the series of closing prices for its calculations. This function makes it possible to calculate the Bollinger band trend of any series of values.This function supports one-pass calculation when used in the Data Section with a non-variable count.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.74",
          "title": "BBTrendF",
          "line": 3949
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "BBWidth",
      "title": "BBWidth",
      "aliases": [],
      "section": "17.18.75",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Indicator Functions",
      "description": "Bollinger band width",
      "example": null,
      "notes": "This indicates the width of the Bollinger bands relative to the average price that they surround.This is equivalent to 100 * (BBTop(len, mult) - BBBot(len, mult)) / Avg(C, len).To calculate BBWidth for something other than Close use BBWidth F.This function supports one-pass calculation when used in the Data Section with a non-variable count.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.75",
          "title": "BBWidth",
          "line": 3951
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "BBWidthF",
      "title": "BBWidthF",
      "aliases": [],
      "section": "17.18.76",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Bollinger band width as a function",
      "example": null,
      "notes": "The BBWidth indicator always uses the series of closing prices for its calculations. This function makes it possible to calculate the Bollinger band width of any series of values.This function supports one-pass calculation when used in the Data Section with a non-variable count.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.76",
          "title": "BBWidthF",
          "line": 3956
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Benchmark",
      "title": "Benchmark",
      "aliases": [],
      "section": "17.18.77",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Script Sections",
      "description": "Defines a benchmark strategy",
      "example": null,
      "notes": "See Special Strategy Types for details.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.77",
          "title": "Benchmark",
          "line": 3958
        }
      ],
      "sample_examples": [
        {
          "file": "samples/cii_rotate.rts",
          "line": 65,
          "code": "Benchmark: SPY // compare to SPY with dividend reinvestement"
        },
        {
          "file": "samples/clenow_stocks_on_move.rts",
          "line": 70,
          "code": "Benchmark: buy_and_hold"
        },
        {
          "file": "samples/clenow_stocks_on_move_dynamic.rts",
          "line": 62,
          "code": "Benchmark: buy_and_hold"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "Bound",
      "title": "Bound",
      "aliases": [],
      "section": "17.18.78",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Force a value to be between a lower and upper limit",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.78",
          "title": "Bound",
          "line": 3960
        }
      ],
      "sample_examples": [
        {
          "file": "samples/sctr.rts",
          "line": 20,
          "code": "slopescore:\t0.5 * (Bound(pposlope, -1, 1) + 1)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "CalendarSym",
      "title": "CalendarSym",
      "aliases": [],
      "section": "17.18.79",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Symbol to use as the market date list for this strategy Input Any symbol in the current data file (does not require an extra $)",
      "example": "of the problem that this optional element solves:\u00b7 it is Tuesday morning and Monday was a US holiday\u00b7 your data file includes the symbol AUDUSD which has a bar for Monday\u00b7 the global date list therefore includes Monday's date\u00b7 your strategy uses a Max Positions formula that varies depending on a US-index-based trend filter\u00b7 while trying to evaluate Max Positions for Tuesday's trades, it sets the\u2026",
      "notes": "Calendar Sym is only needed when a multi-strategy script includes strategies for different countries or for markets with different trading calendars.An global date list is needed when evaluating formulas that don't have a specific symbol context, e.g. Max Positions, Max Exposure, etc.The global date list includes every date that has a bar for any stock in the data file.Specifying Calendar Sym replaces the default date list with a specific symbol's date list for this strategy only.Do not prefix the symbol with $ -- that is only required for symbol references within formulas.An",
      "see_also": [
        "the general topic of Calendar Alignment."
      ],
      "manual_refs": [
        {
          "section": "17.18.79",
          "title": "CalendarSym",
          "line": 3965
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "CashInOut",
      "title": "CashInOut",
      "aliases": [],
      "section": "17.18.80",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Syntax Element Details",
      "description": "Specifies deposits and/or withdarawals to/from the current equity of a strategy by formula Input Formula expression returning an amount in dollars",
      "example": "script.",
      "notes": "This formula is evaluated once per day at the beginning of the day, before any trading signals are processed. The resulting amount is added to the equity of the strategy. The formula should return a positive value for deposits or a negative value for withdrawals, or 0 on dates when neither occurs.The simplest way to use this formula in a multi-strategy system is to give it its own strategy, as in the examples below.To provide a list of specific dates and amounts, use Cash List rather than Cash In Out. Unlike Fees In Out, Cash In Out is NOT included in backtest stats such as the annual return\u2026",
      "see_also": [
        "the annual_taxes.rts"
      ],
      "manual_refs": [
        {
          "section": "17.18.80",
          "title": "CashInOut",
          "line": 3967
        }
      ],
      "sample_examples": [
        {
          "file": "samples/annual_taxes.rts",
          "line": 31,
          "code": "CashInOut:\t-Combined(TaxOwed)[1] // invesetment stats are \"before taxes\""
        },
        {
          "file": "samples/combined_rebalance.rts",
          "line": 17,
          "code": "// functions used by each strategy for Allocation and CashInOut"
        },
        {
          "file": "samples/two_accounts_rebalance.rts",
          "line": 108,
          "code": "CashInOut:\tif(EndOfMonth, 0.5 * Combined(S.Alloc) - Extern(@account1, S.Alloc), 0)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "CashIntPct",
      "title": "CashIntPct",
      "aliases": [],
      "section": "17.18.81",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "Interest rate received for positive daily excess cash",
      "example": null,
      "notes": "If the settings also provide a Risk Free Rate Sym then Cash Int Pct is added to the current daily interest rate as determined by today's value of the risk-free rate series. In this case, Cash Int Pct would typically be negative, e.g. -0.5 if your broker pays 0.5% less than the fed funds rate (with floor of zero).If Risk Free Rate Sym is provided but Cash Int Pct is not provided or is 0 then no interest is received. You must specify a non-zero value of Cash Int Pct to include interest on excess cash in your backtests.If Cash Int Pct is provided when there is no Risk Free Rate Sym then Cash Int\u2026",
      "see_also": [
        "Margin Int Pct which specifies the rate charged for negative excess cash (margin loan)."
      ],
      "manual_refs": [
        {
          "section": "17.18.81",
          "title": "CashIntPct",
          "line": 3972
        }
      ],
      "sample_examples": [
        {
          "file": "samples/futures_trend_follow_csi.rts",
          "line": 16,
          "code": "CashIntPct:\t2\t// interest paid on cash not in use as margin collateral"
        },
        {
          "file": "samples/radge_bbo.rts",
          "line": 21,
          "code": "CashIntPct:    \t-0.5"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "CashList",
      "title": "CashList",
      "aliases": [],
      "section": "17.18.82",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Syntax Element Details",
      "description": "Specifies a CSV file that lists deposits and/or withdrawals to/from the current equity of a strategy Input Path to a CSV file with dates in the first column and amounts in the second column",
      "example": "Cash List is most often used with strategies that use Trade List to play back live trades: The CSV file would look like this (additional columns will be ignored):",
      "notes": "The file can have any number of rows, and can have multiple rows for the same date.The header row is optional.Use positive amounts for deposits and negative amounts for withdrawals.Amounts for each date in a test are applied at the beginning of that day, before any trading signals are processed.If dates are weekend or holiday, they are applied to the next trading day.To specify deposits and withdrawals by formula, use Cash In Out rather than Cash List.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.82",
          "title": "CashList",
          "line": 3974
        }
      ],
      "sample_examples": [
        {
          "file": "samples/oc_all_actual.rts",
          "line": 58,
          "code": "//\tCashList: c:\\wherever\\cash_in_out.csv"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Category (definition",
      "title": "Category (definition)",
      "aliases": [],
      "section": "17.18.83",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements value to a position at entry time Input Formula expression property.A typical usage, along with the Max Same Cat element, is to limit the number of simultaneous positions from the same sector or industry. When using Norgate data, either the TRBC or GICS classification value for the current symbol can be referenced in the formula. Using TRBC along with the Top function is an especially convenient way to specify a for this purpose. For",
      "description": "Assigns a",
      "example": ", Top(TRBC,2) is the economic sector, Top(TRBC,4) is the business sector, Top(TRBC,6) is the industry group, and Top(TRBC,8) is the specific industry.",
      "notes": "This formula is evaluated before the Entry Setup for each stock each day, so its value can be accessed in any other entry-related formula using the",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.83",
          "title": "Category (definition)",
          "line": 3980
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Category (reference",
      "title": "Category (reference)",
      "aliases": [],
      "section": "17.18.84",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Current Position Information strategy element formula for this position",
      "description": "The value of the",
      "example": null,
      "notes": "This property can be referenced in any strategy element formula. It is most likely useful in Entry Setup, Quantity, or Exit Rule.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.84",
          "title": "Category (reference)",
          "line": 3985
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "CCI",
      "title": "CCI",
      "aliases": [],
      "section": "17.18.85",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Indicator Functions",
      "description": "Commodity Channel Index of this indicator, see its Stock Charts Chart School page.",
      "example": null,
      "notes": "For the best",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.85",
          "title": "CCI",
          "line": 3987
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "CDF",
      "title": "CDF",
      "aliases": [],
      "section": "17.18.86",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Cumulative Distribution Function",
      "example": null,
      "notes": "The CDF calculates the probability that a random observation will be less than or equal to a certain value. By normalizing financial data to a range of 0 to 1, it enables consistent comparison across assets and periods, aiding in the creation of trading indicators.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.86",
          "title": "CDF",
          "line": 3989
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Charts",
      "title": "Charts",
      "aliases": [],
      "section": "17.18.87",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Script Sections",
      "description": "Chart indicator definitions",
      "example": null,
      "notes": "See Charts Section and Candlestick/Bar Charts.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.87",
          "title": "Charts",
          "line": 3993
        }
      ],
      "sample_examples": [
        {
          "file": "samples/anchored_vwap.rts",
          "line": 27,
          "code": "Charts:"
        },
        {
          "file": "samples/breadth.rts",
          "line": 36,
          "code": "Charts:"
        },
        {
          "file": "samples/cl_term_structure.rts",
          "line": 4,
          "code": "charts their closing prices in the volume pane"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "CIIFamily",
      "title": "CIIFamily",
      "aliases": [],
      "section": "17.18.88",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Import Specification",
      "description": "Norgate corresponding industry index family",
      "example": null,
      "notes": "Used in conjunction with CIILevel to add corresponding index references to each import stock symbol.Causes the relevant index symbols to be automatically added to the import as well.Automatically-added index symbols are placed in virtual List Num = 99.The specific industry index for the current symbol can be referenced using Extern(&99, expression).",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.88",
          "title": "CIIFamily",
          "line": 3995
        }
      ],
      "sample_examples": [
        {
          "file": "samples/cii_rotate.rts",
          "line": 13,
          "code": "CIIFamily:\t$SPX"
        },
        {
          "file": "samples/industry_indices.rts",
          "line": 17,
          "code": "CIIFamily:\t$SPX // can be $SPX or $SP1500 -- determines which set of corresponding industry index symbols to use"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "CIILevel",
      "title": "CIILevel",
      "aliases": [],
      "section": "17.18.89",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Import Specification",
      "description": "Norgate corresponding industry index level",
      "example": null,
      "notes": "Used in conjunction with CIIFamily to add corresponding index references to each import stock symbol.Causes the relevant index symbols to be automatically added to the import as well.Automatically-added index symbols are placed in virtual List Num = 99.The specific industry index for the current symbol can be referenced using Extern(&99, expression).",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.89",
          "title": "CIILevel",
          "line": 3997
        }
      ],
      "sample_examples": [
        {
          "file": "samples/cii_rotate.rts",
          "line": 14,
          "code": "CIILevel:\tIndustryGroup"
        },
        {
          "file": "samples/industry_indices.rts",
          "line": 18,
          "code": "CIILevel:\tIndustryGroup // corresponding industry index specificity level (see auto-complete choices)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Classification",
      "title": "Classification",
      "aliases": [],
      "section": "17.18.90",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Import Specification",
      "description": "Name of the classification scheme to use when querying Norgate for each stock's sector and industry names Choices TRBC - use The Refinitive Business Classification GICS - use the Global Industry Classification Standard",
      "example": null,
      "notes": "Four classification names are imported for each stock: ?Econ Sect, ?Sector, ?Ind Group, and ?Industry. In each of the two schemes, the first four column values (see above links) are assigned to those names respectively.As well as for display purposes, these names are used when calculating two-level rankings e.g. #Rank #By Ind Group factor.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.90",
          "title": "Classification",
          "line": 4002
        }
      ],
      "sample_examples": [
        {
          "file": "samples/gics_indu_rank.rts",
          "line": 2,
          "code": "Shows how to find the top X stocks in the top Y industries using GICS classification"
        },
        {
          "file": "samples/sector_etfs_breadth.rts",
          "line": 9,
          "code": "Classification:\tGICS"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Close",
      "title": "Close or C",
      "aliases": [
        "C"
      ],
      "section": "17.18.91",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Bar Data Values",
      "description": "Current bar closing price",
      "example": null,
      "notes": "Either Close or C can be used as the name of this value.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.91",
          "title": "Close or C",
          "line": 4004
        }
      ],
      "sample_examples": [
        {
          "file": "samples/Sample1.rts",
          "line": 2,
          "code": "Simplest Example -- 50/200 crossover on SPY"
        },
        {
          "file": "samples/Sample2.rts",
          "line": 3,
          "code": "find out which crossover MA lengths would have done best"
        },
        {
          "file": "samples/Sample2a.rts",
          "line": 3,
          "code": "find out which crossover MA lengths would have done best"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "CloseSlip",
      "title": "CloseSlip",
      "aliases": [],
      "section": "17.18.92",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Slippage amount, in points (dollars per share or contract), for each transaction that simulates a market order filling at the close Input Any formula specifying dollars per share or contract (points)",
      "example": null,
      "notes": "Defines the amount of slippage to apply to each market-at-close transaction, in price points. Close Slip is applied to any transaction that logically occurs at the close and not at a specified limit or stop price.If Close Slip is not specified then Slippage is applied instead.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.92",
          "title": "CloseSlip",
          "line": 4006
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Combined (function",
      "title": "Combined (function)",
      "aliases": [],
      "section": "17.18.93",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions Descriptionevaluate stats expression using combined strategy results",
      "description": null,
      "example": null,
      "notes": "This function is intended for use with strategy-specific",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.93",
          "title": "Combined (function)",
          "line": 4011
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Combined (section",
      "title": "Combined (section)",
      "aliases": [],
      "section": "17.18.94",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Script Sections",
      "description": "Allows definition of all-strategy combined constraints such as Max Exposure, Max Invested, Max Positions, etc.",
      "example": null,
      "notes": ".See Special Strategy Types for details.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.94",
          "title": "Combined (section)",
          "line": 4013
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "CommCurrency",
      "title": "CommCurrency",
      "aliases": [],
      "section": "17.18.95",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "Specifies how the Commission formula is interpreted in a multi-currency script. Choices Instrument - commission values are interpreted as being in the currency of the instrument being traded (default) Account - commission values are interpreted as being in the base currency of the account",
      "example": null,
      "notes": "Some brokers, including IB (Interactive Brokers), charge trade commissions in the currency of the instrument being traded. Other brokers may charge commissions in the account's base currency. This setting lets you tell Real Test which way your broker does it.Comm Currency also determines how commission values in Imported Trade Lists are interpreted.",
      "see_also": [
        "Testing Multi-Currency Strategies."
      ],
      "manual_refs": [
        {
          "section": "17.18.95",
          "title": "CommCurrency",
          "line": 4015
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Commission",
      "title": "Commission",
      "aliases": [],
      "section": "17.18.96",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Commission amount, in instrument or account currency units, for each trade Input Formula specifying a commission amount",
      "example": null,
      "notes": "If your broker charges no commissions, omit this formula or set it to 0. If you pay a flat fee for every trade, simply specify that number. Commission is calculated and charged separately for entry and exit transactions, so round-trip commission is twice the value of this formula. If Fill Price is used in the Commission formula, it will automatically retrieve the entry price for the entry commission and the exit price for the exit commission.The formula for the standard US commission at Interactive Brokers is: Min(0.01 * Fill Value, Max(0.005 * Shares, 1)).IB's Canadian commission formula is\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.96",
          "title": "Commission",
          "line": 4020
        }
      ],
      "sample_examples": [
        {
          "file": "samples/bensdorp_book.rts",
          "line": 91,
          "code": "Commission:\tMax(0.005 * Shares, 1)"
        },
        {
          "file": "samples/dividend_capture.rts",
          "line": 51,
          "code": "Commission:\t5 // $5 since always 1000 shares"
        },
        {
          "file": "samples/es_compare.rts",
          "line": 24,
          "code": "Commission:\t2.40"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Compounded",
      "title": "Compounded",
      "aliases": [],
      "section": "17.18.97",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Optionally overrides the automatically-determined S.Compounded flag for a strategy Choices True - force the strategy to report stats as if compounded False - force the strategy to report stats as if non-compounded(unspecified) - report stats as compounded if equity is compounded or as non-compounded if equity is not compounded (default)",
      "example": null,
      "notes": "This setting mainly controls how percent-based stats are reported. For tests where Compounded was True, the \"ROR\" stat is compound annual return (CAR) and the denominator used to calculate percent drawdown is the peak equity value.For tests where Compounded was False, the \"ROR\" stat is average annual return (AAR) and the denominator used to calculate percent drawdown is the starting (constant) equity value.If Allocation was not specified then it will default to Combined(S.Equity) when Compounded is True or to S.Start Equity when Compounded is False.This in turn impacts Quantity (position\u2026",
      "see_also": [
        "Compounding."
      ],
      "manual_refs": [
        {
          "section": "17.18.97",
          "title": "Compounded",
          "line": 4022
        }
      ],
      "sample_examples": [
        {
          "file": "samples/dividend_capture.rts",
          "line": 43,
          "code": "Allocation:\tS.StartEquity // non-compounded"
        },
        {
          "file": "samples/ndx_rotate_weekly_reduce.rts",
          "line": 46,
          "code": "Compounded:\tTrue\t// this Quantity formula fools the automatic detection"
        },
        {
          "file": "samples/turtles.rts",
          "line": 59,
          "code": "Compounded:\tTrue\t// this sizing model is kind of compounded and kind of not -- causes stats to assume compoounding"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Constituency",
      "title": "Constituency",
      "aliases": [],
      "section": "17.18.98",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Import Specification",
      "description": "Norgate index constituency list",
      "example": null,
      "notes": "Norgate supports historical index constituency series for many different indexes.The following links to their website will provide the latest details:\u00b7 US Historical Index Constituents\u00b7 AU Historical Index Constituents\u00b7 CA Historical Index Constituents These details can also be found in the constituency.csv file that comes with Real Test and is automatically loaded each time the program starts.Here is a subset of that file: Column A contains the index number used by Real Test internally to identify each constituency time series. Column B contains the symbol to use in your Constituency\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.98",
          "title": "Constituency",
          "line": 4027
        }
      ],
      "sample_examples": [
        {
          "file": "samples/import_norgate.rts",
          "line": 5,
          "code": "index constituency bits for each of these indexes will be added to every bar of every stock"
        },
        {
          "file": "samples/index_breadth.rts",
          "line": 4,
          "code": "use the \"Correct\" technique for breadth calculations involving variable constituency and count significance"
        },
        {
          "file": "samples/mr_sample_scan.rts",
          "line": 29,
          "code": "// removed constituency test since using current constituent list"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Correl",
      "title": "Correl",
      "aliases": [],
      "section": "17.18.99",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Pearson's Correlation of two series",
      "example": null,
      "notes": "Correl(ROC(C,1), Extern($SPY, ROC(C,1)), 100) would be a simple way to calculate the rolling 100-day correlation of a stock to SPY.",
      "see_also": [
        "Spearman",
        "Correl Avg",
        "etc."
      ],
      "manual_refs": [
        {
          "section": "17.18.99",
          "title": "Correl",
          "line": 4032
        }
      ],
      "sample_examples": [
        {
          "file": "samples/clenow_stocks_on_move.rts",
          "line": 33,
          "code": "R2:\t#SlowCalc Correl(Log(C), FunBar, lookback) ^ 2"
        },
        {
          "file": "samples/clenow_stocks_on_move_dynamic.rts",
          "line": 33,
          "code": "R2:\t#SlowCalc Correl(Log(C), FunBar, lookback) ^ 2"
        },
        {
          "file": "samples/correl_multi.rts",
          "line": 2,
          "code": "Demonstrates how to use CorrelAvg and related functions"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "CorrelAvg",
      "title": "CorrelAvg",
      "aliases": [],
      "section": "17.18.100",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Average correlation of a stock to a group of stocks",
      "example": null,
      "notes": "Correl Avg(In DJI, ROC(C,1), 20) would return the average 20-bar correlation of each DJIA constituent to the current stock.",
      "see_also": [
        "Correl",
        "Spearman",
        "Correl Med",
        "Correl Min",
        "Correl Min Sym",
        "Correl Max",
        "Correl Max Sym"
      ],
      "manual_refs": [
        {
          "section": "17.18.100",
          "title": "CorrelAvg",
          "line": 4037
        }
      ],
      "sample_examples": [
        {
          "file": "samples/correl_multi.rts",
          "line": 2,
          "code": "Demonstrates how to use CorrelAvg and related functions"
        },
        {
          "file": "samples/optimal_diversity.rts",
          "line": 32,
          "code": "score1:\tif(setup, -CorrelAvg(setup, roc1, bars), nan)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "CorrelMax",
      "title": "CorrelMax",
      "aliases": [],
      "section": "17.18.104",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Highest correlation of a stock to a group of stocks",
      "example": null,
      "notes": "Correl Max(In DJI, ROC(C,1), 20) would return the highest 20-bar correlation of any DJIA constituent to the current stock.",
      "see_also": [
        "Correl",
        "Spearman",
        "Correl Avg",
        "Correl Med",
        "Correl Min",
        "Correl Min Sym",
        "Correl Max Sym"
      ],
      "manual_refs": [
        {
          "section": "17.18.104",
          "title": "CorrelMax",
          "line": 4051
        }
      ],
      "sample_examples": [
        {
          "file": "samples/correl_multi.rts",
          "line": 31,
          "code": "corr_max:\tCorrelMax(InDJI, factor, len, sprmn)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "CorrelMaxSym",
      "title": "CorrelMaxSym",
      "aliases": [],
      "section": "17.18.105",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Symbol of stock with highest correlation to the current stock",
      "example": null,
      "notes": "Correl Max Sym(In DJI, ROC(C,1), 20) would return the symbol of the DJIA constituent with the highest 20-bar correlation to the current stock.The symbol is returned as both a number and a string. Use Sym Ref to refer to symbol with Extern.",
      "see_also": [
        "Correl",
        "Spearman",
        "Correl Avg",
        "Correl Med",
        "Correl Min",
        "Correl Min Sym",
        "Correl Max"
      ],
      "manual_refs": [
        {
          "section": "17.18.105",
          "title": "CorrelMaxSym",
          "line": 4053
        }
      ],
      "sample_examples": [
        {
          "file": "samples/correl_multi.rts",
          "line": 32,
          "code": "corr_max_sym:\tCorrelMaxSym(InDJI, factor, len, sprmn)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "CorrelMed",
      "title": "CorrelMed",
      "aliases": [],
      "section": "17.18.101",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Median correlation of a stock to a group of stocks",
      "example": null,
      "notes": "Correl Med(In DJI, ROC(C,1), 20) would return the median 20-bar correlation of each DJIA constituent to the current stock.",
      "see_also": [
        "Correl",
        "Spearman",
        "Correl Avg",
        "Correl Min",
        "Correl Min Sym",
        "Correl Max",
        "Correl Max Sym"
      ],
      "manual_refs": [
        {
          "section": "17.18.101",
          "title": "CorrelMed",
          "line": 4039
        }
      ],
      "sample_examples": [
        {
          "file": "samples/correl_multi.rts",
          "line": 28,
          "code": "corr_med:\tCorrelMed(InDJI, factor, len, sprmn)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "CorrelMin",
      "title": "CorrelMin",
      "aliases": [],
      "section": "17.18.102",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Lowest correlation of a stock to a group of stocks",
      "example": null,
      "notes": "Correl Min(In DJI, ROC(C,1), 20) would return the lowest 20-bar correlation of any DJIA constituent to the current stock.",
      "see_also": [
        "Correl",
        "Spearman",
        "Correl Avg",
        "Correl Med",
        "Correl Min Sym",
        "Correl Max",
        "Correl Max Sym"
      ],
      "manual_refs": [
        {
          "section": "17.18.102",
          "title": "CorrelMin",
          "line": 4044
        }
      ],
      "sample_examples": [
        {
          "file": "samples/correl_multi.rts",
          "line": 29,
          "code": "corr_min:\tCorrelMin(InDJI, factor, len, sprmn)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "CorrMinSym",
      "title": "CorrMinSym",
      "aliases": [],
      "section": "17.18.103",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Symbol of stock with lowest correlation to the current stock",
      "example": null,
      "notes": "Correl Min Sym(In DJI, ROC(C,1), 20) would return the symbol of the DJIA constituent with the lowest 20-bar correlation to the current stock.The symbol is returned as both a number and a string. Use Sym Ref to refer to symbol with Extern.",
      "see_also": [
        "Correl",
        "Spearman",
        "Correl Avg",
        "Correl Med",
        "Correl Min",
        "Correl Max",
        "Correl Max Sym"
      ],
      "manual_refs": [
        {
          "section": "17.18.103",
          "title": "CorrMinSym",
          "line": 4046
        }
      ],
      "sample_examples": [
        {
          "file": "samples/correl_multi.rts",
          "line": 41,
          "code": "CorrMinSym:\tExtern(SymNum(corr_min_sym), ?Symbol)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Cosine",
      "title": "Cosine",
      "aliases": [],
      "section": "17.18.106",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Trigonometric cosine of a number of degrees",
      "example": null,
      "notes": "The parameter value is assumed to be degrees (0-360).To convert radians to degrees, multiply by 57.2957795131 (180/\u03c0).",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.106",
          "title": "Cosine",
          "line": 4058
        }
      ],
      "sample_examples": [
        {
          "file": "samples/ehlers_windows.rts",
          "line": 22,
          "code": "hannfunc:\t(1 - Cosine(360 * FunBar / (len+1)))"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "CountTrue",
      "title": "CountTrue",
      "aliases": [],
      "section": "17.18.108",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Count of bars for which a condition was true (non-zero)",
      "example": null,
      "notes": "Condition will always be evaluated for count bars (or all bars if omitted). For each bar, condition is evaluated as if that bar were the current bar, i.e. without knowledge of future splits relative to that bar.If condition was never true for any bar, the return value is 0.Unless you really care about the specific count, it is more efficient to use Since True to test whether a condition has ever been true.This function supports one-pass calculation when used in the Data Section without a count argument.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.108",
          "title": "CountTrue",
          "line": 4062
        }
      ],
      "sample_examples": [
        {
          "file": "samples/clenow_stocks_on_move.rts",
          "line": 36,
          "code": "CanRank:\tInSPX and C > MA(C,100) and CountTrue(ABS(ROC(C,1))>=15, 90) == 0"
        },
        {
          "file": "samples/clenow_stocks_on_move_dynamic.rts",
          "line": 36,
          "code": "CanRank:\tInSPX and C > MA(C,100) and CountTrue(ABS(ROC(C,1))>=15, 90) == 0"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Cross",
      "title": "Cross",
      "aliases": [],
      "section": "17.18.107",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Compares two values for two bars to see if their ranking has changed",
      "example": null,
      "notes": "This function is a shortcut for the expression value1[1] < value2[1] and value1 > value2. It is most commonly used to compare two moving averages, or price to a moving average, e.g. Cross(MA(C,5), MA(C,20)) would return 1 (true) if the 5-day average was below the 20-day average yesterday and is above it today.Logically, Cross(A,B) means \"A has crossed above B\". To test for \"A has crossed below B\", simply use Cross(B,A).",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.107",
          "title": "Cross",
          "line": 4060
        }
      ],
      "sample_examples": [
        {
          "file": "samples/Sample1.rts",
          "line": 2,
          "code": "Simplest Example -- 50/200 crossover on SPY"
        },
        {
          "file": "samples/Sample2.rts",
          "line": 3,
          "code": "find out which crossover MA lengths would have done best"
        },
        {
          "file": "samples/Sample2a.rts",
          "line": 3,
          "code": "find out which crossover MA lengths would have done best"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "CRSI",
      "title": "CRSI",
      "aliases": [],
      "section": "17.18.109",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Indicator Functions",
      "description": "Connors RSI Indicator",
      "example": null,
      "notes": "This calculates the equivalent of the following formula: CRSI was added as a built-in function to improve calculation speed and enable \"reverse CRSI\" to be calculated by passing it to the Target Price function.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.109",
          "title": "CRSI",
          "line": 4066
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "CSVDateFmt",
      "title": "CSVDateFmt",
      "aliases": [],
      "section": "17.18.110",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Import Specification",
      "description": "Specifies whether the dates in a CSV Import are in M/D/Y vs. D/M/Y format Choices DMY - dates are D/M/YMDY - dates are M/D/YNotes The default if your Import definition does not include CSVDate Format is to use the Date Display Format setting from the Program Options Dialog.This element lets you use CSV data files with the opposite of your standard date format more easily.Other date formats are supported which are not ambiguous and therefore do not require CSVDate Fmt to be specified.",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.110",
          "title": "CSVDateFmt",
          "line": 4070
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "CSVDelim",
      "title": "CSVDelim",
      "aliases": [],
      "section": "17.18.111",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Import Specification",
      "description": "Specifies the column delimiter in a CSV Import file Choices Comma Semicolon Tab",
      "example": null,
      "notes": "The default column delimiter is Comma when CSVNum Fmt is Point or Semicolon when CSVNum Fmt is Comma.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.111",
          "title": "CSVDelim",
          "line": 4075
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "CSVFields",
      "title": "CSVFields",
      "aliases": [],
      "section": "17.18.112",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Import Specification",
      "description": "CSV field order (comma-separated list) Choices Date - this field is the bar date Time - this field is the bar time Open - this field is the open price High - this field is the high price Low - this field is the low price Close - this field is the close price Volume - this field is the volume Adj Close - this field is the adjusted close price Real Close - this field is the unadjusted (as-traded) close price Split - this field is the split ratio (real close / adjusted close) Dividend - this field is the dividend amount (should be 0 except on ex-dividend dates) Extra - this field is the value\u2026",
      "example": "of a CSV import specification showing how this looks: Note that CSV field names (like all names in Real Test) are not case-sensitive.To ignore a column in a CSV file, add an extra comma to the field order list, e.g. \"date,,,open,high,low,close,,volume\".To ignore the first one or more columns, add extra comma(s) at the start of the list, e.g. \",,date,close\".",
      "notes": "CSV field order must be specified for CSV Import to work. If CSV data files include header rows with column labels, these are simply ignored.Here is a partial",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.112",
          "title": "CSVFields",
          "line": 4077
        }
      ],
      "sample_examples": [
        {
          "file": "samples/import_csv.rts",
          "line": 8,
          "code": "CSVFields:\tDate,Open,High,Low,Close,Volume,RealClose,Dividend"
        },
        {
          "file": "samples/import_multi.rts",
          "line": 22,
          "code": "CSVFields:\tDate,Open,High,Low,Close,Volume,RealClose,Dividend"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "CSVFile",
      "title": "CSVFile",
      "aliases": [],
      "section": "17.18.113",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Import Specification",
      "description": "CSV file to be used for single-file CSV data import Input The full path to a file that contains CSV data for one or more symbols.",
      "example": null,
      "notes": "The file must include a Symbol column, and CSVFields must specify its location.For multi-file CSV import (one file per symbol), use Data Path instead of CSVFile.See CSV Import for additional details.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.113",
          "title": "CSVFile",
          "line": 4083
        }
      ],
      "sample_examples": [
        {
          "file": "samples/import_csv.rts",
          "line": 17,
          "code": "CSVFile:\tc:\\Data\\BigFile.CSV // the file path"
        },
        {
          "file": "samples/import_multi.rts",
          "line": 35,
          "code": "CSVFile:\tc:\\Data\\OtherData1.CSV"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "CSVNumFmt",
      "title": "CSVNumFmt",
      "aliases": [],
      "section": "17.18.114",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Import Specification",
      "description": "Specifies whether numbers (prices) in a CSV Import use a point or a comma as their decimal separator Choices Point - point (period) is used (default) Comma - comma is used",
      "example": null,
      "notes": "By default (and by definition) comma is the field separator in a CSV file, and point is the decimal separator.This optional item enables European-format \"CSV\" files to be imported by Real Test. When you add CSVNum Fmt: Comma to your CSV Import definition, semicolon becomes the default CSVDelim and comma is used as the decimal separator.Such files sometimes use point as the date field separator, and Real Test also supports this format automatically.",
      "see_also": [
        "CSVDate Fmt for D/M/Y date field order specification."
      ],
      "manual_refs": [
        {
          "section": "17.18.114",
          "title": "CSVNumFmt",
          "line": 4085
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Currency",
      "title": "Currency",
      "aliases": [],
      "section": "17.18.115",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "The base currency of the model account in a backtest Value A three-letter currency abbreviation such as AUD, CAD, USD, JPY etc. (do not include quotation marks)",
      "example": null,
      "notes": "Only specify a base currency when you specifically want to test multi-currency strategies, e.g. trading US stocks in a non-US account.For this setting to work, the active data file must include the appropriate exchange rate series, e.g. AUDUSD, and the stock metadata must specify the currency for each symbol.See Testing Multi-Currency Strategies for details on how this works.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.115",
          "title": "Currency",
          "line": 4090
        }
      ],
      "sample_examples": [
        {
          "file": "samples/djia_make_syminfo.rts",
          "line": 27,
          "code": "Cur:\t?Currency\t{\"Currency\"}"
        },
        {
          "file": "samples/djia_use_syminfo.rts",
          "line": 28,
          "code": "Cur:\t?Currency\t{\"Currency\"}"
        },
        {
          "file": "samples/simple_day_trade_basket_scan.rts",
          "line": 26,
          "code": "Cur:\t{\"Currency\"} \"USD\""
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Data",
      "title": "Data",
      "aliases": [],
      "section": "17.18.116",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Script Sections",
      "description": "Named formulas calculated once and stored in memory arrays before tests are run .",
      "example": null,
      "notes": "See Data Section for a more detailed",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.116",
          "title": "Data",
          "line": 4092
        }
      ],
      "sample_examples": [
        {
          "file": "samples/Sample1.rts",
          "line": 7,
          "code": "DataSource:\tYahoo"
        },
        {
          "file": "samples/Sample2.rts",
          "line": 6,
          "code": "DataFile:\tsample1.rtd // see Sample1.rts for import instructions"
        },
        {
          "file": "samples/Sample2a.rts",
          "line": 6,
          "code": "DataFile:\tsample1.rtd // see Sample1.rts for import instructions"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "DataFile",
      "title": "DataFile",
      "aliases": [],
      "section": "17.18.117",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "Path to the .RTD data file to load before running a scan or test",
      "example": null,
      "notes": "If Data File is not specified in a script then the path from the Settings Panel will be used.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.117",
          "title": "DataFile",
          "line": 4094
        }
      ],
      "sample_examples": [
        {
          "file": "samples/Sample1.rts",
          "line": 13,
          "code": "DataFile:\tsample1.rtd"
        },
        {
          "file": "samples/Sample2.rts",
          "line": 6,
          "code": "DataFile:\tsample1.rtd // see Sample1.rts for import instructions"
        },
        {
          "file": "samples/Sample2a.rts",
          "line": 6,
          "code": "DataFile:\tsample1.rtd // see Sample1.rts for import instructions"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "DataPath",
      "title": "DataPath",
      "aliases": [],
      "section": "17.18.118",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Import Specification",
      "description": "CSI Futures, CSI Stocks, CSV, or Meta Stock file location Input The full path to a directory (folder) that contains a collection of local data files.",
      "example": null,
      "notes": "By default all data files found in each specified Data Path are included in the import.Specify one or more Include List to optionally filter the files to include only those symbols listed.Include List can also be used to provide In List names or numbers with local-file import.Specify Keep Non Included: True if you want to define In List names while still importing all the data files.See CSI Futures Import, CSI Stocks Import, CSV Import, or Meta Stock Import for further details.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.118",
          "title": "DataPath",
          "line": 4098
        }
      ],
      "sample_examples": [
        {
          "file": "samples/futures_trend_follow_csi.rts",
          "line": 6,
          "code": "DataPath:\tc:\\UA\\Files\\RealTest {\"CSI\"} // change to your CSI futures portfolio location"
        },
        {
          "file": "samples/import_csv.rts",
          "line": 9,
          "code": "DataPath:\tc:\\NDExport // the folder path"
        },
        {
          "file": "samples/import_ms.rts",
          "line": 7,
          "code": "Point the above \"DataPath\" to your MSLegacy folder."
        }
      ],
      "grammar_match": false
    },
    {
      "name": "DataSource",
      "title": "DataSource",
      "aliases": [],
      "section": "17.18.119",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Import Specification",
      "description": "Name of the data source to use for a data import Choices Norgate - import from Norgate NDU (stocks, futures, indexes, indicators) Yahoo - import from finance.yahoo.com (stocks) Tiingo - import from api.tiingo.com (stocks) Tiingo Crypto - import end-of-day Crypto currency prices from Tiingo Metastock - import stock data from a local Metastock database CSIFutures - import futures data from CSI Unfair Advantage portfolios CSV - import any type of data from your own local CSV files",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.119",
          "title": "DataSource",
          "line": 4100
        }
      ],
      "sample_examples": [
        {
          "file": "samples/Sample1.rts",
          "line": 7,
          "code": "DataSource:\tYahoo"
        },
        {
          "file": "samples/actual_trades.rts",
          "line": 8,
          "code": "DataSource:\tYahoo"
        },
        {
          "file": "samples/anchored_vwap.rts",
          "line": 7,
          "code": "DataSource:\tYahoo"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "DataType",
      "title": "DataType",
      "aliases": [],
      "section": "17.18.120",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Causes a value to be treated as a specific type of data",
      "example": ", a complex Data Section formula.",
      "notes": "This function is rarely needed because Real Test automatically determines the type of most calculated values correctly.The data type of a value is only important when the value is used in multi-bar formulas or indicators that cross a split date.Only use this function if you have observed incorrect split handling in, for",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.120",
          "title": "DataType",
          "line": 4102
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Date",
      "title": "Date",
      "aliases": [],
      "section": "17.18.121",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Returns a numeric date value for a given year, month and day",
      "example": null,
      "notes": "The return value is the date in YYYYMMDD format, which can be used for comparison with Bar Date or as input to Date Bars.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.121",
          "title": "Date",
          "line": 4107
        }
      ],
      "sample_examples": [
        {
          "file": "samples/Sample1.rts",
          "line": 9,
          "code": "StartDate:\t1993-01-01"
        },
        {
          "file": "samples/Sample2.rts",
          "line": 7,
          "code": "StartDate:\tEarliest"
        },
        {
          "file": "samples/Sample2a.rts",
          "line": 7,
          "code": "StartDate:\tEarliest"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "DateBars",
      "title": "DateBars",
      "aliases": [],
      "section": "17.18.122",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Number of bars since (or until) a specific date",
      "example": null,
      "notes": "This function can be used to return a bar count or offset from the current bar to a specific date in the past or future.The date parameter can be any formula returning a numeric date value. The Date function is a convenient way to generate a numeric date.If there is no bar with the specified date, the first bar with a date more recent than the specified date is used.Examples ROC(C, Date Bars(Date(2016,2,1)) + 1) returns the percent gain or loss since February 1, 2016. (The +1 is needed to make the bar count inclusive of the specified bar when using the count as a length argument.) C[Date\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.122",
          "title": "DateBars",
          "line": 4109
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "DateDay",
      "title": "DateDay",
      "aliases": [],
      "section": "17.18.123",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Extract the day number from a date",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.123",
          "title": "DateDay",
          "line": 4114
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "DateDisplay",
      "title": "DateDisplay",
      "aliases": [],
      "section": "17.18.124",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "Specifies how dates are displayed in the user interface, scans, trade lists, etc.",
      "example": null,
      "notes": "This setting optionally overrides the default date display format as defined in Program Options. The override applies while the script is running and the prior setting is restored when it finishes.See Date Format Pictures for details about the format specification string.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.124",
          "title": "DateDisplay",
          "line": 4116
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "DateInput",
      "title": "DateInput",
      "aliases": [],
      "section": "17.18.125",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "Specifies how dates are parsed when it isn't clear whether the first two numbers are day/month or month/day.",
      "example": null,
      "notes": "Real Test can parse dates in any known format without being told what the format is. The only exception is when day and month precede year. In this case it is not always clear which is which, so a setting is required.This setting optionally overrides the default date input format as defined in Program Options. Note that this setting is independent of the Date Display format, which is not used when parsing dates in scripts or input files.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.125",
          "title": "DateInput",
          "line": 4118
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "DateMonth",
      "title": "DateMonth",
      "aliases": [],
      "section": "17.18.126",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Extract the month number from a date",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.126",
          "title": "DateMonth",
          "line": 4123
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "DateSym",
      "title": "DateSym",
      "aliases": [],
      "section": "17.18.127",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "Symbol to use to interpret \"Earliest\" or \"Latest\" in Start Date or End Date",
      "example": null,
      "notes": "By default Earliest means the oldest date and Latest the newest date of any symbol in the current data file.If Date Sym is specified then that symbol is used instead.A good use of Date Sym is to avoid the common problem where adding a currency symbol like AUDUSD to your data file causes the \"latest\" bar to be one for which no stocks have bars.Do not prefix the symbol with $ -- that is only required for symbol references within formulas.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.127",
          "title": "DateSym",
          "line": 4125
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "DateYear",
      "title": "DateYear",
      "aliases": [],
      "section": "17.18.128",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Extract the year number from a date",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.128",
          "title": "DateYear",
          "line": 4127
        }
      ],
      "sample_examples": [
        {
          "file": "samples/annual_taxes.rts",
          "line": 13,
          "code": "LTGain:\t#OnePerDate if(SinceEOY > 0, Combined(TradeStatSum(if(DateYear(T.DateOut) = This(Year) and Days(T.DateIn, T.DateOut) > 366, T.Profit - T.Div, 0))), 0)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Day",
      "title": "Day",
      "aliases": [],
      "section": "17.18.129",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Bar Data Values",
      "description": "Day of month of this bar",
      "example": null,
      "notes": "Returns the day of month of the current bar date as a number.Negative offsets, e.g. Day[-5], can be legitimately used to obtain the day of a future bar. This works even if the offset goes beyond the range of the currently loaded data file. For best results when future dates are required, a Holiday List should also be provided.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.129",
          "title": "Day",
          "line": 4132
        }
      ],
      "sample_examples": [
        {
          "file": "samples/annual_taxes.rts",
          "line": 13,
          "code": "LTGain:\t#OnePerDate if(SinceEOY > 0, Combined(TradeStatSum(if(DateYear(T.DateOut) = This(Year) and Days(T.DateIn, T.DateOut) > 366, T.Profit - T.Div, 0))), 0)"
        },
        {
          "file": "samples/bensdorp_book.rts",
          "line": 74,
          "code": "smr2_setup:\t// \"Short Mean Reversion High Six-Day Surge\" setup criteria"
        },
        {
          "file": "samples/breadth.rts",
          "line": 2,
          "code": "Calculates the number of S&P components that closed outside a 20-day 1-ATR Keltner channel each day"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "DayOfWeek",
      "title": "DayOfWeek",
      "aliases": [],
      "section": "17.18.130",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Bar Data Values",
      "description": "Numeric code for day of week of this bar Notes1=Monday2=Tuesday3=Wednesday4=Thursday5=Friday6=Saturday (e.g. for Crypto)7=Sunday (ditto) Negative offsets, e.g. Day Of Week[-1], can be legitimately used to obtain the weekday of a future bar. This works even if the offset goes beyond the range of the currently loaded data file. For best results when future dates are required, a Holiday List should also be provided.",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.130",
          "title": "DayOfWeek",
          "line": 4134
        }
      ],
      "sample_examples": [
        {
          "file": "samples/clenow_stocks_on_move.rts",
          "line": 41,
          "code": "TradeDay:\tExtern($SPY, DayOfWeek < 3 and  DayOfWeek[-1] >= 3) // Wed. (Thu. if holiday)"
        },
        {
          "file": "samples/clenow_stocks_on_move_dynamic.rts",
          "line": 41,
          "code": "TradeDay:\tExtern($SPY, DayOfWeek < 3 and  DayOfWeek[-1] >= 3) // Wed. (Thu. if holiday)"
        },
        {
          "file": "samples/opex_and_vxex.rts",
          "line": 18,
          "code": "IsOpEx:\t(Day >= 15 and Day <= 21 and DayOfWeek = 5) // normal case"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "DayOfYear",
      "title": "DayOfYear",
      "aliases": [],
      "section": "17.18.131",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Bar Data Values",
      "description": "Day of year of this bar",
      "example": ", a February 1 bar will always return 32. A December 31 bar will return 365 on normal years or 366 on leap years.Negative offsets, e.g. Day Of Year[-10], can be legitimately used to obtain the day of year of a future bar. This works even if the offset goes beyond the range of the currently loaded data file. For best results when future dates are required, a Holiday List should also be provided.",
      "notes": "Returns the calendar day of year, not the number of bars. For",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.131",
          "title": "DayOfYear",
          "line": 4136
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Days",
      "title": "Days",
      "aliases": [],
      "section": "17.18.132",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Counts the number of calendar or market days from one date to another",
      "example": null,
      "notes": "The",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.132",
          "title": "Days",
          "line": 4141
        }
      ],
      "sample_examples": [
        {
          "file": "samples/annual_taxes.rts",
          "line": 13,
          "code": "LTGain:\t#OnePerDate if(SinceEOY > 0, Combined(TradeStatSum(if(DateYear(T.DateOut) = This(Year) and Days(T.DateIn, T.DateOut) > 366, T.Profit - T.Div, 0))), 0)"
        },
        {
          "file": "samples/cl_term_structure.rts",
          "line": 14,
          "code": "DaysToExp:\tDays(BarDate, InfoExpiry)"
        },
        {
          "file": "samples/combined.rts",
          "line": 21,
          "code": "HolidayList:\t?scriptpath?\\holidays.us.txt \t// only needed for generating tomorrow's orders"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "DaysPerYear",
      "title": "DaysPerYear",
      "aliases": [],
      "section": "17.18.133",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "Number of market days per year for stats purposes",
      "example": null,
      "notes": "This becomes the value returned by S.BPY for Daily Bar Size tests (S.BPY is logically always 52 for Weekly, 12 for Monthly, 4 for Quarterly, 1 for Yearly).The default if not specified is 252. Use 365 for a 7-day asset such as Crypto.S.BPY is used internally to calculate the following:- S.BPW = S.BPY / 52 - S.BPM = S.BPY / 12- S.BPQ = S.BPY / 4- HVOL(len) = Std Dev(log(c/c[1]), len) * 100 * Sqr(S.BPY) S.BPY is also used in some of the formulas in Graphs.rts and Results.rts.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.133",
          "title": "DaysPerYear",
          "line": 4143
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "DebugEntry",
      "title": "DebugEntry",
      "aliases": [],
      "section": "17.18.134",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Log output from a running test at position entry (or skip) time Input Any formula returning a string (blank string \"\" means don't log anything) or numeric value (0 means don't log anything)",
      "example": "(from mr_sample_debug.rts):",
      "notes": "If this formula is present in a strategy, it will be evaluated for every setup just prior to position entry processing.If the Debug Entry formula returns a non-blank string or a non-zero numeric value then whatever it returns is added to the test debug or log output.To make the best use of this debugging feature, use the IF and Format functions, as in this",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.134",
          "title": "DebugEntry",
          "line": 4148
        }
      ],
      "sample_examples": [
        {
          "file": "samples/mr_sample_debug.rts",
          "line": 13,
          "code": "// allows during-test DebugEntry (etc.) statements to write to log"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "DebugEval",
      "title": "DebugEval",
      "aliases": [],
      "section": "17.18.135",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Stop script execution and log the details of a strategy formula's evaluation when a condition is met",
      "example": "say you have a complex Quantity formula such as: (from the clenow_stocks_on_move_dynamic.rts script) You want to see exactly how it is being calculated for AAPL on 2024-06-21: Run the test and it will run as normal until coming to that symbol and date, then will:\u00b7 turn on the same mechanism used for \"Show Evaluation\" option in the Debug Panel\u00b7 evaluate the formula, causing full evaluation details\u2026",
      "notes": "Debug Eval is meant to be wrapped around a strategy formula when necessary to learn the details of how it is being calculated in the context of a specific point in a running test.For",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.135",
          "title": "DebugEval",
          "line": 4150
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "DebugExit",
      "title": "DebugExit",
      "aliases": [],
      "section": "17.18.136",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Log output from a running test at Exit Rule evaluation time Input Any formula returning a string (blank string \"\" means don't log anything)",
      "example": "(from mr_sample_debug.rts):",
      "notes": "If this formula is present in a strategy, it will be evaluated for every stock every day of the test, just prior to the Exit Rule formula evaluation.If the Debug Exit formula returns a non-blank string or a non-zero numeric value then whatever it returns is added to the test debug or log output.To make the best use of this debugging feature, use the IF and Format functions, as in this",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.136",
          "title": "DebugExit",
          "line": 4156
        }
      ],
      "sample_examples": [
        {
          "file": "samples/mr_sample_debug.rts",
          "line": 37,
          "code": "DebugExit:\tif(debug_sym, Format(\"c={#2}, c[1]={#2}, held={#}\", c, c[1], BarsHeld), \"\")"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "DebugTargetStop",
      "title": "DebugTargetStop",
      "aliases": [],
      "section": "17.18.137",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Log output from a running test at Exit Limit / Exit Stop evaluation time Input Any formula returning a string (blank string \"\" means don't log anything)",
      "example": "(from mr_sample_debug.rts):",
      "notes": "If this formula is present in a strategy, it will be evaluated for every stock every day of the test, just prior to the Exit Limit and Exit Stop formula evaluations. If the Debug Target Stop formula returns a non-blank string or a non-zero numeric value then whatever it returns is added to the test debug or log output.To make the best use of this debugging feature, use the IF and Format functions, as in this",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.137",
          "title": "DebugTargetStop",
          "line": 4158
        }
      ],
      "sample_examples": [
        {
          "file": "samples/mr_sample_debug.rts",
          "line": 38,
          "code": "DebugTargetStop:\tif(debug_sym, Format(\"target={#2}, nexthigh={#2}, miss={#2}\", long_target, next_high, long_target - next_high), \"\")"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "DEMA",
      "title": "DEMA",
      "aliases": [],
      "section": "17.18.138",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Double Exponential Moving Average",
      "example": null,
      "notes": "Count is usually thought of as an integer representing a number of bars, but can actually be any decimal value. An EMA is constructed by multiplying each difference between the result so far and the next value by a factor equal to 2 / (count + 1).Double EMA is calculated as 2 * EMA(expr, count) - EMA(EMA(expr, count)). Unlike the EMA function, DEMA applies the exponential weight factor from the start of available data rather than beginning with MA(expr, count). This is consistent with how other backtesting software calculates this indicator.This function supports one-pass calculation when\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.138",
          "title": "DEMA",
          "line": 4163
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Dividend",
      "title": "Dividend",
      "aliases": [],
      "section": "17.18.139",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Bar Data Values",
      "description": "Dividend amount ($/share) earned on an ex-dividend date",
      "example": null,
      "notes": "Dividend will be 0 for every bar except for those of ex-dividend dates. In other words, for any bar, Dividend is the $/share you will receive if you held the stock that morning before the open.Dividend values will only be present in the data if the data source used for import provided them. Norgate and Yahoo both provide dividend amounts.If Adjustment is set to Total Return when Norgate data is imported, then dividends are converted to splits (price adjustments) rather than reported as dividend payments.When data includes dividend payments and a position is held across an ex-dividend date in\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.139",
          "title": "Dividend",
          "line": 4165
        }
      ],
      "sample_examples": [
        {
          "file": "samples/annual_taxes.rts",
          "line": 2,
          "code": "library script to add capital gains and dividend income tax calculations to any set of strategies"
        },
        {
          "file": "samples/cii_rotate.rts",
          "line": 65,
          "code": "Benchmark: SPY // compare to SPY with dividend reinvestement"
        },
        {
          "file": "samples/clenow_stocks_on_move.rts",
          "line": 73,
          "code": "ExitRule:\tDividend\t// reinvest"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "DllDataCalc",
      "title": "DllDataCalc",
      "aliases": [],
      "section": "17.18.140",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Call a custom external DLL function to calculate a Data item",
      "example": ".",
      "notes": "A native Windows DLL must be specifically built for this purpose.See the RTDLL folder within your Real Test installation folder for details and an",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.140",
          "title": "DllDataCalc",
          "line": 4170
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "DynamicSizing",
      "title": "DynamicSizing",
      "aliases": [],
      "section": "17.18.141",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Determines whether strategy operates in a special dynamic sizing mode Choices True - use dynamic sizing mode False - use typical entry/exit formula mode (default)",
      "example": "scripts clenow_stocks_on_move.rts and clenow_stocks_on_move_dynamic.rts. These implement the same strategy logic using (a) the older approach and (b) dynamic sizing mode.",
      "notes": "If Dynamic Sizing is set to True then most of the typical strategy formulas become disabled and the Quantity formula determines whether a new position or partial position is entered or exited each day.In this mode the following elements are disallowed: Entry Setup, Entry Limit, Entry Stop, Entry Score, Exit Rule, Exit Limit, Exit Stop, Exit Qty, Exit Limit Qty, Exit Stop Qty, Exit Score, Max Same Sym, Max Same Cat, Max Setups, Max Entries, Side.Instead of the logic provided by all of the above elements, the backtest engine simple evaluates Quantity once per test period. The value returned is\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.141",
          "title": "DynamicSizing",
          "line": 4172
        }
      ],
      "sample_examples": [
        {
          "file": "samples/clenow_stocks_on_move_dynamic.rts",
          "line": 3,
          "code": "This version uses DynamicSizing: True where Quantity does all the work of the strategy"
        },
        {
          "file": "samples/ndx_rotate_rebalance.rts",
          "line": 31,
          "code": "DynamicSizing:\tTrue"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "EMA",
      "title": "EMA or XAvg",
      "aliases": [
        "XAvg"
      ],
      "section": "17.18.142",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Exponential Moving Average",
      "example": null,
      "notes": "Either EMA or XAvg can be used as the name of this function.Count is usually thought of as an integer representing a number of bars, but can actually be any decimal value. An EMA is constructed by multiplying each difference between the result so far and the next value by a factor equal to 2 / (count + 1).Note that, like most other backtesting software, Real Test begins each EMA calculation with MA(expr, count), then begins to apply the EMA weighting for subsequent bars once count has been reached.This function supports one-pass calculation when used in the Data Section with a non-variable\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.142",
          "title": "EMA or XAvg",
          "line": 4177
        }
      ],
      "sample_examples": [
        {
          "file": "samples/clenow_stocks_on_move.rts",
          "line": 55,
          "code": "// ^^^ must remain constant for all sub-positions so cannot use Library for pctdiff"
        },
        {
          "file": "samples/goal_30_15.rts",
          "line": 26,
          "code": "EMA5:\tEMA(C,5)"
        },
        {
          "file": "samples/goal_30_15_asx.rts",
          "line": 2,
          "code": "this is somewhat an academic exercise, as day-trading and shorting on the ASX may be problematic:"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "EndDate (Import",
      "title": "EndDate (Import)",
      "aliases": [],
      "section": "17.18.143",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Import Specification",
      "description": "The last date to include in imported data Choices Date Constant - a literal date Latest - always use the most recent available date",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.143",
          "title": "EndDate (Import)",
          "line": 4179
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "EndDate (Setting",
      "title": "EndDate (Setting)",
      "aliases": [],
      "section": "17.18.144",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "The last date to include in a scan Choices Date Constant - a literal date Latest - the newest date of any symbol in the current data file",
      "example": null,
      "notes": "If a date range is not specified in a script then the dates from the Settings Panel will be used.To get the most recent N bars, use End Date: Latest with Num Bars but no Start Date.If Date Sym is specified then Latest means the newest date of that specific symbol.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.144",
          "title": "EndDate (Setting)",
          "line": 4184
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "EndOfMonth",
      "title": "EndOfMonth",
      "aliases": [],
      "section": "17.18.145",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Bar Data Values",
      "description": "Indicates whether this bar is the last bar of its month",
      "example": null,
      "notes": "Returns 1 for the last bar of a month, otherwise 0.Note that this function operates on the unified date list for all symbols in the current data file by default, or the date list of the Calendar Sym if specified. To check whether the current bar is the last bar of the month for a specific symbol, use Month[-1] <> Month.To work correctly when generating tomorrow's orders or using negative (future) offsets, a Holiday List should also be provided.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.145",
          "title": "EndOfMonth",
          "line": 4186
        }
      ],
      "sample_examples": [
        {
          "file": "samples/annual_taxes.rts",
          "line": 11,
          "code": "EndOfYear:\tEndOfMonth and Month = eoy_month"
        },
        {
          "file": "samples/cii_rotate.rts",
          "line": 62,
          "code": "EntrySetup:\tEndOfMonth and CanHold"
        },
        {
          "file": "samples/combined.rts",
          "line": 53,
          "code": "EntrySetup:\tEndOfMonth and InNDX and Extern($SPY, C > MA(C,200)) \t// next day will be a new month and symbol was in the NDX and SPY is in an uptrend"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "EndOfQuarter",
      "title": "EndOfQuarter",
      "aliases": [],
      "section": "17.18.146",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Bar Data Values",
      "description": "Indicates whether this bar is the last bar of a calendar quarter",
      "example": null,
      "notes": "Returns 1 for the last bar of a month when month is March, June, September or December, otherwise 0.Note that this function operates on the unified date list for all symbols in the current data file by default, or the date list of the Calendar Sym if specified. To check whether the current bar is the last bar of the quarter for a specific symbol, use Month[-1] <> Month and Month % 3 = 0.To work correctly when generating tomorrow's orders or using negative (future) offsets, a Holiday List should also be provided.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.146",
          "title": "EndOfQuarter",
          "line": 4188
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "EndOfTestExits",
      "title": "EndOfTestExits",
      "aliases": [],
      "section": "17.18.147",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "Controls whether open positions are exited at the end of a backtest Choices True - exit all positions at the end of each test (default) False - do not exit open positions",
      "example": null,
      "notes": "Positions exited because the test has ended will show \"end-of-test\" in the \"Reason\" column of the trade list.When End Of Test Exits is False, open positions will not appear in the trade list.Possible reasons to disable end-of-test exits are:\u00b7 to exclude still-open positions from trade-level stats \u00b7 to keep those position records in memory for inspection in the Debug Panel (previously this was controlled by the Debug choice of the Test Output setting)",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.147",
          "title": "EndOfTestExits",
          "line": 4193
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "EndOfWeek",
      "title": "EndOfWeek",
      "aliases": [],
      "section": "17.18.148",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Bar Data Values",
      "description": "Indicates whether this bar is the last bar of the market week",
      "example": null,
      "notes": "Returns 1 for the last bar of a week (typically Friday), otherwise 0.Note that this function operates on the unified date list for all symbols in the current data file by default, or the date list of the Calendar Sym if specified. To check whether the current bar is the last bar of the week for a specific symbol, use Week[-1] <> Week.To work correctly when generating tomorrow's orders or using negative (future) offsets, a Holiday List should also be provided.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.148",
          "title": "EndOfWeek",
          "line": 4195
        }
      ],
      "sample_examples": [
        {
          "file": "samples/combined.rts",
          "line": 33,
          "code": "EntrySetup:\tEndOfWeek and InList(1) \t// next day will be a new week and symbol comes from first import list"
        },
        {
          "file": "samples/combined_multi_bar_size.rts",
          "line": 3,
          "code": "see also combined.rts, which implements this same set of strategies using daily bars and EndOfWeek / EndOfMonth signals"
        },
        {
          "file": "samples/combined_rebalance.rts",
          "line": 19,
          "code": "// change this ^^^ to: 0 to never revalance, 1 to rebalance daily, or another other condition as desired e.g. EndOfWeek, EndOfMonth and Month %3 = 0, etc."
        }
      ],
      "grammar_match": false
    },
    {
      "name": "EndOfYear",
      "title": "EndOfYear",
      "aliases": [],
      "section": "17.18.149",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Bar Data Values",
      "description": "Indicates whether this bar is the last bar of its year",
      "example": null,
      "notes": "Returns 1 for the last bar of a year, otherwise 0.Note that this function operates on the unified date list for all symbols in the current data file by default, or the date list of the Calendar Sym if specified. To check whether the current bar is the last bar of the year for a specific symbol, use Year[-1] <> Year.To work correctly when generating tomorrow's orders or using negative (future) offsets, a Holiday List should also be provided.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.149",
          "title": "EndOfYear",
          "line": 4200
        }
      ],
      "sample_examples": [
        {
          "file": "samples/annual_taxes.rts",
          "line": 11,
          "code": "EndOfYear:\tEndOfMonth and Month = eoy_month"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "EntryDate",
      "title": "EntryDate",
      "aliases": [],
      "section": "17.18.150",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Current Position Information",
      "description": "The date on which this position was entered",
      "example": null,
      "notes": "The return value is a number in YYYYMMDD format and is the date on which the entry occurred (not the Entry Setup signal day).For a non-daily Bar Size strategy, this will be the actual entry date (e.g. a Monday if Weekly).If used as Combined(Entry Date) when multiple positions are open in the same symbol (whether due to pyramiding or multiple strategies), the most recent entry date for that symbol will be returned.",
      "see_also": [
        "Bars Held."
      ],
      "manual_refs": [
        {
          "section": "17.18.150",
          "title": "EntryDate",
          "line": 4202
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "EntryLimit",
      "title": "EntryLimit",
      "aliases": [],
      "section": "17.18.151",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Price to use when entering a position with a limit order Input Any formula specifying a price per share",
      "example": null,
      "notes": "The price returned by the Entry Limit formula is used to place a one-day limit order. For a long buy, the Low must be less than or equal to the limit price to potentially generate an entry. For a short sale, the High must be greater than or equal to the limit price.If the opening price for a stock is at or beyond the limit price, then the the order is assumed to have been filled at the opening price, otherwise it fills at the limit price. Limit orders that fill at the open are assumed to have filled first when some entries have to be skipped due to position count or investment level caps.If\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.151",
          "title": "EntryLimit",
          "line": 4204
        }
      ],
      "sample_examples": [
        {
          "file": "samples/bensdorp_book.rts",
          "line": 111,
          "code": "EntryLimit:\tc * 1.04"
        },
        {
          "file": "samples/goal_30_15.rts",
          "line": 60,
          "code": "EntryLimit:\tL - 0.5 * ATR5"
        },
        {
          "file": "samples/goal_30_15_asx.rts",
          "line": 61,
          "code": "EntryLimit:\tL - 0.5 * ATR5"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "EntryRank",
      "title": "EntryRank",
      "aliases": [],
      "section": "17.18.152",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Current Position Information",
      "description": "Returns the rank number for this position when Entry Score was evaluated at entry time.",
      "example": null,
      "notes": "Entry Rank can be referred to in any strategy formula except Entry Setup.Entry ranks can also be observed by running a test with Test Output: Log enabled.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.152",
          "title": "EntryRank",
          "line": 4209
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "EntryScore",
      "title": "EntryScore",
      "aliases": [],
      "section": "17.18.153",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Ranks potential entries when a strategy has more setups than can be entered Input Any formula specifying a numeric value",
      "example": null,
      "notes": "Entry Score is a specialized formula that is only needed when modeling strategies that allow more setups than entries. It should NOT be used as a general-purpose setup ranking function -- always use Setup Score for that purpose.",
      "see_also": [
        "Max Entries."
      ],
      "manual_refs": [
        {
          "section": "17.18.153",
          "title": "EntryScore",
          "line": 4211
        }
      ],
      "sample_examples": [
        {
          "file": "samples/oex_tf_top_down.rts",
          "line": 50,
          "code": "SetupScore:\troc(c, len1)\t// always use SetupScore, never EntryScore"
        },
        {
          "file": "samples/turtles.rts",
          "line": 89,
          "code": "EntryScore:\t(C - C[63]) / N // 3-month momentum, one thing they used to \"pick the strongest\" for longs"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "EntrySetup",
      "title": "EntrySetup",
      "aliases": [],
      "section": "17.18.154",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Determines whether a stock is eligible for entry Input Any formula specifying a true/false condition (non-zero means true)",
      "example": "of this tactic:",
      "notes": "Entry Setup is the first formula evaluated for each stock on each date of a backtest. If the return value is non-zero (true) then the stock is set up for entry (is an entry candidate). If a strategy has no Entry Setup formula, then it will produce no trades (unless it uses an Imported Trade List).If a strategy also includes an Entry Limit and/or Entry Stop formula, or if it specifies Entry Time as Next Open (or leaves it unspecified), then all entry-related formulas including Entry Setup are evaluated using the day prior to entry day as the most recent bar in the formula. The only case where\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.154",
          "title": "EntrySetup",
          "line": 4215
        }
      ],
      "sample_examples": [
        {
          "file": "samples/Sample1.rts",
          "line": 19,
          "code": "EntrySetup:\tAvg(C,50) > Avg(C,200)"
        },
        {
          "file": "samples/Sample2.rts",
          "line": 16,
          "code": "EntrySetup:\tAvg(C,ShortMA) > Avg(C,LongMA)"
        },
        {
          "file": "samples/Sample2a.rts",
          "line": 17,
          "code": "EntrySetup:\tAvg(C,ShortMA) > Avg(C,MidMA) and Avg(C,MidMA) > Avg(C,LongMA)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "EntrySkip",
      "title": "EntrySkip",
      "aliases": [],
      "section": "17.18.155",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Enables skipping an entry if a condition applies Input Any formula specifying a true/false condition (non-zero means true)",
      "example": ", Entry Skip: random() < 0.05. This would randomly skip about 5% of entries, e.g. to simulate not being able to borrow shares to short. By running this same test a number of times we can see the probable range of how this would impact the stats of the strategy.",
      "notes": "After all other conditions for entry have been met, the Entry Skip formula is evaluated (if provided). If the result is non-zero (true) or if the formula can't be evaluated (nan) then the entry is not taken.All skipped entries (potential entries that passed the Entry Setup condition but did not become positions for any reason) are optionally included in the Trade List when a test is run. Skipped entries shown in the trade list include a column where the reason the entry was skipped is shown. Trades skipped because the Entry Skip condition was true show \"skip formula\" as their skip reason.A\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.155",
          "title": "EntrySkip",
          "line": 4217
        }
      ],
      "sample_examples": [
        {
          "file": "samples/turtles.rts",
          "line": 90,
          "code": "EntrySkip:\tlongUnits == 12 or lastTradeWin // max 12 units per side in total, no entry for system 1 if last trade was a winner"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "EntryStop",
      "title": "EntryStop",
      "aliases": [],
      "section": "17.18.156",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Price to use when entering a position with a stop order Input Any formula specifying a price per share",
      "example": "to avoid entry at more than 2% above the stop price: Entry Limit: 1.02 * Highest(C,10)",
      "notes": "The price returned by the Entry Stop formula is used to place a one-day stop order. For a long buy, the High must be greater than or equal to the stop price to potentially generate an entry. For a short sale, the Low must be less than or equal to the stop price.If the opening price for a stock is at or beyond the stop price, then the the order is assumed to have been filled at the opening price, otherwise it fills at the stop price. Stop orders that fill at the open are assumed to have filled first when some entries have to be skipped due to position count or investment level caps.If both\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.156",
          "title": "EntryStop",
          "line": 4222
        }
      ],
      "sample_examples": [
        {
          "file": "samples/keltner_pullback.rts",
          "line": 51,
          "code": "EntryStop:\tTrigger"
        },
        {
          "file": "samples/turtles.rts",
          "line": 67,
          "code": "EntryStop:\tHighest(h,20) + TickSize"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "EntryTime",
      "title": "EntryTime",
      "aliases": [],
      "section": "17.18.157",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Specifies when a strategy enters new positions Choices This Close - entries occur at the close of the current day Intraday - entries occur when a trigger price is first touched tomorrow (default for limit and/or stop orders) Next Open - entries occur at tomorrow's open (default for market orders) Next Close - entries occur at tomorrow's close",
      "example": null,
      "notes": "Using This Close implies an ability to generate realtime trading signals using live data. Real Test will not be able to generate Tomorrow's Orders for This Close entries.For strategies with no Entry Limit or Entry Stop, Entry Time controls the time at which a market order is generated. Next Open implies that a standard MKT order is placed before the open, to be filled at the open. (Intraday is interpreted as Next Open for market orders.) Next Close implies that a MOC order is placed before the open, to be filled at the close.Entry Time also applies to strategies that use an Entry Limit and/or\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.157",
          "title": "EntryTime",
          "line": 4224
        }
      ],
      "sample_examples": [
        {
          "file": "samples/keller_baa.rts",
          "line": 43,
          "code": "EntryTime:\tThisClose\t// impractical but what the description says"
        },
        {
          "file": "samples/mr_sample_hedged.rts",
          "line": 17,
          "code": "EntryTime:\tThisClose"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "EntryTradeValue",
      "title": "EntryTradeValue",
      "aliases": [],
      "section": "17.18.158",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Calculates a value to store in T.Value In item in the trade list record for this entry Input Any formula specifying a numeric value",
      "example": null,
      "notes": "This item can be useful in Trade Statistics Functions, especially when applied to Results formulas which do not support access to bar data values or indicator functions.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.158",
          "title": "EntryTradeValue",
          "line": 4228
        }
      ],
      "sample_examples": [
        {
          "file": "samples/mr_sample_long_only.rts",
          "line": 24,
          "code": "EntryTradeValue:\tOrderPrice // becomes TLValueIn in the playback strategy"
        },
        {
          "file": "samples/mr_sample_short_only.rts",
          "line": 22,
          "code": "EntryTradeValue:\tOrderPrice // becomes TLValueIn in the playback strategy"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "ESD",
      "title": "ESD",
      "aliases": [],
      "section": "17.18.159",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Exponential Standard Deviation",
      "example": null,
      "notes": "This function calculates a standard deviation of values as an exponential series using a constant weighting factor represented as a bar count.As in the EMA function, count is converted to a weight factor using the formula factor = 2 / (count + 1).This factor is then used to calculate two intermediate series for an array of values.An EMA is calculated in place of the mean in a typical Std Dev calculation.The average of the squared differences between each value and the mean (i.e. the standard deviation) is also calculated as an EMA using the same weight factor.This function supports one-pass\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.159",
          "title": "ESD",
          "line": 4233
        }
      ],
      "sample_examples": [
        {
          "file": "samples/clenow_stocks_on_move.rts",
          "line": 76,
          "code": "EndDate:\t2023-12-26 // must be a Tuesday (setup day for Wed. entry)"
        },
        {
          "file": "samples/clenow_stocks_on_move_dynamic.rts",
          "line": 68,
          "code": "EndDate:\t2023-12-26 // must be a Tuesday (setup day for Wed. entry)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Event",
      "title": "Event",
      "aliases": [],
      "section": "17.18.160",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Bar Data Values",
      "description": "Get the event code for this bar or the most recent event code",
      "example": null,
      "notes": "If the current data file includes a user-defined Event List, this function looks up an event code for the current symbol and bar.If an event is found that has type as its type number, then its value is returned. If latest is true (non-zero), then the most recent event of this type for this symbol prior to (or on) the current bar is returned.If no matching event is found then 0 is returned.An event is considered to have occurred \"on a bar\" if the event's time value (from the imported event list) <= 16:00 (160000).",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.160",
          "title": "Event",
          "line": 4235
        }
      ],
      "sample_examples": [
        {
          "file": "samples/djia_earnings.rts",
          "line": 2,
          "code": "shows how to use an event list file to backtest earnings events"
        },
        {
          "file": "samples/import_multi.rts",
          "line": 28,
          "code": "DataSource:\tCSV // required to prevent IncludeList below from applying to DataPaths above"
        },
        {
          "file": "samples/multi_moc_top_down.rts",
          "line": 3,
          "code": "shows how to use top-down setup ranking to prevent duplicate positions"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "EventListFile",
      "title": "EventListFile",
      "aliases": [],
      "section": "17.18.161",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Import Specification",
      "description": "Path to a CSV file containing a list of specific event data to include in imported bar data Input File path",
      "example": null,
      "notes": "See Event and Event List Files for details on how this mechanism works and can be used.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.161",
          "title": "EventListFile",
          "line": 4240
        }
      ],
      "sample_examples": [
        {
          "file": "samples/djia_earnings.rts",
          "line": 11,
          "code": "EventListFile:\t?scriptpath?\\djia_earnings.csv"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "ExchangeMap",
      "title": "ExchangeMap",
      "aliases": [],
      "section": "17.18.162",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "Specifies the path to a CSV file which helps Real Test generate orders with correct symbols, exchange names, and GAT/GTD times",
      "example": null,
      "notes": "An exchange map is required in order for Real Test to generate orders in any Orders Mode other than Text.If an Exchange Map Setting is not specified, Real Test looks for a file called Exchange Map.csv in the following locations:1.the current Order Clerk Folder when Orders Mode is Order Clerk2.the Real Test installation folder The default Exchange Map.csv file installed with Real Test looks like this: The columns can be in any sequence but must use the names listed below.The content and purpose of each column is described here:Column Content Purpose Exchange exchange name with optional * or ?\u2026",
      "see_also": [
        "exchangemap_csi.csv or exchangemap_ndu.csv (both are in the Examples folder)."
      ],
      "manual_refs": [
        {
          "section": "17.18.162",
          "title": "ExchangeMap",
          "line": 4242
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "ExcludeIf",
      "title": "ExcludeIf",
      "aliases": [],
      "section": "17.18.163",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Import Specification",
      "description": "Import filter formula (exclude symbol if true) Inputnumber",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.163",
          "title": "ExcludeIf",
          "line": 4253
        }
      ],
      "sample_examples": [
        {
          "file": "samples/dividend_capture.rts",
          "line": 9,
          "code": "ExcludeIf:\tsincetrue(Dividend > 0.2 and C < 100) < 0\t// evaluated for latest bar so need explicit split-unadjustment"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "ExcludeList",
      "title": "ExcludeList",
      "aliases": [],
      "section": "17.18.164",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Import Specification",
      "description": "List of one or more symbols to exclude when importing data",
      "example": null,
      "notes": "An Import Section can have any number of Exclude List statements.Each Exclude List statement can take one of the following forms:\u00b7 One or more symbols, separated by commas (up to a maximum of 260 characters in total) \u00b7 A path to a local file containing a list of symbols If a symbol from any Include List also appears on any Exclude List, then that symbol will not be included in the imported data. Use of an Exclude List is a convenient way to omit a few specific symbols from a data file without having to modify an existing watchlist.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.164",
          "title": "ExcludeList",
          "line": 4255
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "ExitLimit",
      "title": "ExitLimit",
      "aliases": [],
      "section": "17.18.165",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "A price at which to exit a position using a limit order (profit target) Input Any formula specifying a price per share",
      "example": null,
      "notes": "Exit Limit specifies a \"target\" price, implemented by default as a LMT DAY order. The formula is re-evaluated each day, so it can function as either a static or moving target, depending on how it is specified. Exit Limit is always evaluated using the day prior to exit day as the most recent bar in the formula.A simple fixed 5% profit target could be specified as Fill Price * 1.05 for a long position or Fill Price * 0.95 for a short position.An ATR-based target might be expressed as Fill Price + 2 * ATR(14) for a long position or Fill Price - 2 * ATR(14) for a short position.A strategy can\u2026",
      "see_also": [
        "Exit Limit Time for other target-order alternatives.For more information on how the backtest engine works in general",
        "see Backtest Engine Details."
      ],
      "manual_refs": [
        {
          "section": "17.18.165",
          "title": "ExitLimit",
          "line": 4260
        }
      ],
      "sample_examples": [
        {
          "file": "samples/dividend_capture.rts",
          "line": 49,
          "code": "ExitLimit:\tFillPrice + 3 * Dividend[-Bars] // can't use unadjusted prices in strategy price formulas"
        },
        {
          "file": "samples/gc_kelly.rts",
          "line": 34,
          "code": "ExitLimit:\tFillPrice + tgt *atrx"
        },
        {
          "file": "samples/higher_lows.rts",
          "line": 48,
          "code": "ExitLimit:\tFillPrice + tgtatr*atrx[BarsHeld]"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "ExitLimitQty",
      "title": "ExitLimitQty",
      "aliases": [],
      "section": "17.18.166",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Specifies the number of shares or contracts to buy or sell when a position exits on an Exit Limit Input Any formula specifying a number of shares or contracts",
      "example": ".",
      "notes": "Exit Limit Qty can be used to model partial limit (target) exits (scaling out of positions or reducing their size).If Exit Limit Qty is not specified then then entire position is always exited when an Exit Limit triggers.The Exit Limit Qty formula must calculate the number of shares or contracts to exit regardless of the strategy's Qty Type setting.To model partial exits for the other exit types, Exit Qty and/or Exit Stop Qty can also be added to a strategy.See Exit Qty for additional information and an",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.166",
          "title": "ExitLimitQty",
          "line": 4262
        }
      ],
      "sample_examples": [
        {
          "file": "samples/tf_sell_half_at_1R.rts",
          "line": 30,
          "code": "ExitLimitQty:\tShares / 2"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "ExitLimitTime",
      "title": "ExitLimitTime",
      "aliases": [],
      "section": "17.18.167",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Specifies how a strategy exits positions when the Exit Limit formula is used Choices This Close - exit at today's close if today's closing price touches or exceeds the limit price (impractical) Intraday - Exit Limit specifies the price of a live limit order to be placed tomorrow (default) Next Open - exit at tomorrow's open if today's close touched or exceeded the limit price Next Close - exit at tomorrow's close if tomorrow's close touches or exceeds the limit price (calculated from today's bar)",
      "example": null,
      "notes": "Using This Close with Exit Limit equivalent to adding \"and C > n\", where \"n\" is the Exit Limit price (for a long-side strategy), to the Exit Rule of a strategy with Exit Time This Close. In either case, orders could not be generated in advance for this mode.With Intraday, Next Open, or Next Close Exit Limit orders, the trigger price is calculated using the prior bar, and the order can be placed in advance. A Intraday Exit Limit is a standard LMT DAY order.A Next Open Exit Limit is a MKT order that is placed if the prior close touched the limit price.A Next Close Exit Limit is a LOC (limit on\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.167",
          "title": "ExitLimitTime",
          "line": 4267
        }
      ],
      "sample_examples": [
        {
          "file": "samples/weekly_moc_asx_daily_daily.rts",
          "line": 51,
          "code": "ExitLimitTime:\tNextClose"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "ExitNum",
      "title": "ExitNum",
      "aliases": [],
      "section": "17.18.168",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Current Position Information",
      "description": "Returns the number of this exit for this position",
      "example": null,
      "notes": "Exit Num will normally be 1 unless Exit Qty, Exit Limit Qty or Exit Stop Qty was previously used to exit part of the position.Exit Num can be used in any exit-related strategy formula as part of its exit logic.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.168",
          "title": "ExitNum",
          "line": 4269
        }
      ],
      "sample_examples": [
        {
          "file": "samples/tf_sell_half_at_1R.rts",
          "line": 29,
          "code": "ExitLimit:\tif(ExitNum = 1, FillPrice + stop[BarsHeld], 0)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "ExitQty",
      "title": "ExitQty",
      "aliases": [],
      "section": "17.18.169",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Specifies the number of shares or contracts to buy or sell when Exit Rule is true Input Any formula specifying a number of shares or contracts",
      "example": "to exit one fourth of the original position on each of the first four days after entry: This use of Fill Qty rather than Shares is necessary because Shares will be reduced after each partial exit.Partial exits are implemented internally by temporarily cloning the position, changing the clone's quantity to the desired exit quantity, and then processing the exit of that new position. The quantity\u2026",
      "notes": "Exit Qty can be used to model partial exits (scaling out of positions or reducing their size).If Exit Qty is not specified then then entire position is always exited when Exit Rule is true.The Exit Qty formula must calculate the number of shares or contracts to exit regardless of the strategy's Qty Type setting.To model partial exits for the other exit types, Exit Limit Qty and/or Exit Stop Qty can also be added to a strategy.If the specified quantity is less than or equal to 0 then the exit is cancelled (the position is held at its current size).If the quantity is greater than or equal to\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.169",
          "title": "ExitQty",
          "line": 4273
        }
      ],
      "sample_examples": [
        {
          "file": "samples/clenow_stocks_on_move.rts",
          "line": 66,
          "code": "ExitQty:\tif(MustExit, posshares, stratshares - newqty)"
        },
        {
          "file": "samples/hybrid_asset_allocation_dynamic.rts",
          "line": 50,
          "code": "ExitQty:\tcurr_size - new_size"
        },
        {
          "file": "samples/tf_dynamic_size.rts",
          "line": 44,
          "code": "ExitQty:\tcurqty - newqty // shares to remove (may cause multiple sub-positions to be reduced as needed)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "ExitRank",
      "title": "ExitRank",
      "aliases": [],
      "section": "17.18.170",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Current Position Information",
      "description": "Returns the rank number for this position based on Exit Score",
      "example": null,
      "notes": "Exit Score is recalculated each bar for each open position, before any of the exit formulas are evaluated.Positions are then sorted by this score and their resulting rank numbers are stored.Use Exit Rank to access the rank number of the current position based on that evaluation.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.170",
          "title": "ExitRank",
          "line": 4277
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "ExitRule",
      "title": "ExitRule",
      "aliases": [],
      "section": "17.18.171",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Specifies one or more conditions that would trigger a position exit Input Any formula specifying a true/false condition (non-zero means true)",
      "example": "shows how to structure a multi-reason Exit Rule formula using the Select function, and how each reason string is shown in the Trades Window: Note that when used this way, the Select statement must be the entire Exit Rule formula. For , to only check a pair of exit rules only at the end of each month, you must use this: Exit Rule: Select(End Of Month and condition1, \"reason1\", End Of Month and\u2026",
      "notes": "The Exit Rule for a strategy is evaluated for every position every day. If it ever returns true (non-zero), the position is exited either that day at the close or the next day at the open, depending on the Exit Time setting.When exit time is Next Open (the default) or Next Close, Exit Rule is evaluated using the day prior to exit day as the most recent bar in the formula. For This Close exits, the exit day is the most recent bar.This formula is typically used to specify a conditional exits such as C > C[1], or time-based exits such as Bars Held=10.A strategy can include any combination of an\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.171",
          "title": "ExitRule",
          "line": 4282
        }
      ],
      "sample_examples": [
        {
          "file": "samples/Sample1.rts",
          "line": 20,
          "code": "ExitRule:\tAvg(C,50) < Avg(C,200)"
        },
        {
          "file": "samples/Sample2.rts",
          "line": 17,
          "code": "ExitRule:\tAvg(C,ShortMA) < Avg(C,LongMA)"
        },
        {
          "file": "samples/Sample2a.rts",
          "line": 18,
          "code": "ExitRule:\tAvg(C,ShortMA) < Avg(C,MidMA) or Avg(C,MidMA) < Avg(C,LongMA)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "ExitScore",
      "title": "ExitScore",
      "aliases": [],
      "section": "17.18.172",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Calculates a score value for use in ranking open positions prior to evaluating exit criteria each day in a test Input Any formula specifying a numeric value",
      "example": null,
      "notes": "Exit Score is recalculated each bar for each open position, before any of the exit formulas are evaluated.Positions are then sorted by this score and their resulting rank numbers are stored.Use Exit Rank to access the rank number of the current position based on that evaluation.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.172",
          "title": "ExitScore",
          "line": 4291
        }
      ],
      "sample_examples": [
        {
          "file": "samples/clenow_stocks_on_move.rts",
          "line": 68,
          "code": "ExitScore:\t-Shares // exit small sub-positions first to reduce need to divide larger ones"
        },
        {
          "file": "samples/hybrid_asset_allocation_dynamic.rts",
          "line": 51,
          "code": "ExitScore:\t-Shares"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "ExitStop",
      "title": "ExitStop",
      "aliases": [],
      "section": "17.18.173",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "A price at which to exit a position using a stop order (stop loss) Input Any formula specifying a price per share",
      "example": null,
      "notes": "Exit Stop specifies a \"stop\" price, implemented as a STP DAY order. The formula is re-evaluated each day, so it can function as either a static or trailing stop, depending on how it is specified. Exit Stop is always evaluated using the day prior to exit day as the most recent bar in the formula.A simple fixed 5% stop loss could be specified as Fill Price * 0.95 for a long position or Fill Price * 1.05 for a short position.A trailing stop 5% below the highest high since entry could, for a long position, be expressed as 0.95 * Highest(H,Bars Held).A strategy can include any combination of an\u2026",
      "see_also": [
        "Exit Stop Time for other stop-order alternatives.For more information on how the backtest engine works",
        "see Backtest Engine Details."
      ],
      "manual_refs": [
        {
          "section": "17.18.173",
          "title": "ExitStop",
          "line": 4293
        }
      ],
      "sample_examples": [
        {
          "file": "samples/bensdorp_book.rts",
          "line": 102,
          "code": "ExitStop:\tMax(FillPrice - 5 * atr20, HHV(C,BarsHeld)*0.75)"
        },
        {
          "file": "samples/futures_trend_follow_csi.rts",
          "line": 43,
          "code": "ExitStopTime:\tNextOpen\t// define \"stop\" as closing below the stop price (comment out for live stops)"
        },
        {
          "file": "samples/gc_kelly.rts",
          "line": 35,
          "code": "ExitStop:\tFillPrice - stp * atrx"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "ExitStopQty",
      "title": "ExitStopQty",
      "aliases": [],
      "section": "17.18.174",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Specifies the number of shares or contracts to buy or sell when a position exits on an Exit Stop Input Any formula specifying a number of shares or contracts",
      "example": ".",
      "notes": "Exit Stop Qty can be used to model partial stop exits (scaling out of positions or reducing their size).If Exit Stop Qty is not specified then then entire position is always exited when an Exit Stop triggers.The Exit Stop Qty formula must calculate the number of shares or contracts to exit regardless of the strategy's Qty Type setting.To model partial exits for the other exit types, Exit Qty and/or Exit Limit Qty can also be added to a strategy.See Exit Qty for additional information and an",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.174",
          "title": "ExitStopQty",
          "line": 4295
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "ExitStopTime",
      "title": "ExitStopTime",
      "aliases": [],
      "section": "17.18.175",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Specifies how a strategy exits positions when the Exit Stop formula is used Choices This Close - exit at today's close if today's closing price touches or exceeds the stop price (impractical) Intraday - Exit Stop specifies the price of a live stop order to be placed tomorrow (default) Next Open - exit at tomorrow's open if today's close touched or exceeded the stop price Next Close - exit at (or just before) tomorrow's close if tomorrow's close touches or exceeds the stop price (calculated from today's bar)",
      "example": null,
      "notes": "Using This Close with Exit Stop equivalent to adding \"and C < n\", where \"n\" is the Exit Stop price (for a long-side strategy), to the Exit Rule of a strategy with Exit Time This Close. In either case, orders could not be generated in advance for this mode.With Intraday, Next Open, or Next Close Exit Stop orders, the trigger price is calculated using the prior bar, and the order can be placed in advance. A Intraday Exit Stop is a standard STP DAY order.A Next Open Exit Stop is a MKT order that is placed if the prior close touched the stop price.A Next Close Exit Stop is a STP order with a\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.175",
          "title": "ExitStopTime",
          "line": 4299
        }
      ],
      "sample_examples": [
        {
          "file": "samples/futures_trend_follow_csi.rts",
          "line": 43,
          "code": "ExitStopTime:\tNextOpen\t// define \"stop\" as closing below the stop price (comment out for live stops)"
        },
        {
          "file": "samples/ndx_plus_wtf_script.rts",
          "line": 60,
          "code": "ExitStopTime:\tNextOpen"
        },
        {
          "file": "samples/weekly_trend_follow.rts",
          "line": 40,
          "code": "ExitStopTime:\tNextOpen"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "ExitTime",
      "title": "ExitTime",
      "aliases": [],
      "section": "17.18.176",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Specifies when a strategy exits positions at market when the Exit Rule condition is true (non-zero) Choices This Close - exits occur at the close of the current day Next Open - exits occur at tomorrow's open (default) Next Close - exits occur at tomorrow's close",
      "example": null,
      "notes": "Using This Close implies an ability to generate realtime trading signals using live data. Real Test will not be able to generate Tomorrow's Orders for This Close exits.Exit Time controls the time at which a market order is generated. Next Open implies that a standard MKT order is placed before the open, to be filled at the open. Next Close implies that a MOC order is placed before the open, to be filled at the close.For more information on how the backtest engine works in general, see Backtest Engine Details.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.176",
          "title": "ExitTime",
          "line": 4303
        }
      ],
      "sample_examples": [
        {
          "file": "samples/bensdorp_book.rts",
          "line": 114,
          "code": "ExitTime:\tNextClose"
        },
        {
          "file": "samples/goal_30_15.rts",
          "line": 75,
          "code": "ExitTime:\tThisClose"
        },
        {
          "file": "samples/goal_30_15_asx.rts",
          "line": 76,
          "code": "ExitTime:\tThisClose"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "ExitTradeValue",
      "title": "ExitTradeValue",
      "aliases": [],
      "section": "17.18.177",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Calculates a value to store in T.Value Out item in the trade list record for this exit Input Any formula specifying a numeric value",
      "example": null,
      "notes": "This item can be useful in Trade Statistics Functions, especially when applied to Results formulas which do not support access to bar data values or indicator functions.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.177",
          "title": "ExitTradeValue",
          "line": 4305
        }
      ],
      "sample_examples": [
        {
          "file": "samples/mr_sample_long_only.rts",
          "line": 25,
          "code": "ExitTradeValue:\tFillFraction // becomes TLValueOut in the playback strategy"
        },
        {
          "file": "samples/mr_sample_short_only.rts",
          "line": 23,
          "code": "ExitTradeValue:\tFillFraction // becomes TLValueOut in the playback strategy"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Exp",
      "title": "Exp",
      "aliases": [],
      "section": "17.18.178",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Exponential function (e^x)",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.178",
          "title": "Exp",
          "line": 4307
        }
      ],
      "sample_examples": [
        {
          "file": "samples/actual_trades.rts",
          "line": 36,
          "code": "// this works for IB TWS trade log export files with default columns"
        },
        {
          "file": "samples/bottomup/actual_trades.rts",
          "line": 36,
          "code": "// this works for IB TWS trade log export files with default columns"
        },
        {
          "file": "samples/cii_rotate.rts",
          "line": 24,
          "code": "ROC30:\tROC(C,30) // a ranking factor (experiment with others!)"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "Extern",
      "title": "Extern",
      "aliases": [],
      "section": "17.18.179",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Evaluate for a different stock/contract or strategy or bar size",
      "example": ", Extern($SPY, C > MA(C,20)) would be preferable to Extern($SPY,C) > Extern($SPY, MA(C,20)) or, even worse, Extern($SPY,C) > MA(Extern($SPY,C), 20) -- though all would return the same result.It is also possible to refer to a dynamic (non-constant) external strategy or symbol, either by string or number, using Strat Ref or Sym Ref.The Extern function can be nested, e.g. Extern(@mystrat\u2026",
      "notes": "The default context in all formulas is the current stock for bar data items and the current strategy for daily stats items and position information.Extern allows you temporarily change context to a different stock or strategy or bar size.To reference a stock, use a $ to prefix the symbol of the desired stock, e.g. Extern($MSFT, C) If a stock symbol already starts with a $, e.g. $SPX, you will have to add another $, hence Extern($$SPX, C). The special symbol $Cal Sym can be used to reference the Calendar Sym of the current strategy.",
      "see_also": [
        "Symbol References.There are also special types of Extern references available for individual futures contracts and corresponding industry index symbols.To reference a Strategy",
        "Benchmark or Stats Group",
        "use a @ to prefix the name of the desired strategy",
        "e.g. Extern(@mr_short",
        "S.Equity).To reference the automatically-added Tracker benchmark of the current strategy",
        "use @Tracker.To calculate a formula using a specific bar size",
        "use a ~ to prefix the name of the bar size",
        "e.g. Extern(~Weekly",
        "MA(C",
        "20)) Note that the expression referenced can be any formula",
        "and it is most efficient to do as much as possible in a single Extern function. For"
      ],
      "manual_refs": [
        {
          "section": "17.18.179",
          "title": "Extern",
          "line": 4312
        }
      ],
      "sample_examples": [
        {
          "file": "samples/bensdorp_book.rts",
          "line": 42,
          "code": "and extern($spy,c>avgc100)"
        },
        {
          "file": "samples/beta_indicator.rts",
          "line": 17,
          "code": "indroc1:\textern($SPY, roc1)"
        },
        {
          "file": "samples/bottomup/beta_indicator.rts",
          "line": 17,
          "code": "indroc1:\textern($SPY, roc1)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Extra",
      "title": "Extra",
      "aliases": [],
      "section": "17.18.180",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Bar Data Values",
      "description": "Turnover value from Norgate import, or user-defined Extra bar value from CSV import",
      "example": null,
      "notes": "Norgate's Turnover value is not simply Close * Volume. Rather, it is the sum of Price * Quantity of all intraday trades (ticks) in a day. As such, true daily VWAP (volume-weighted average price) can be calculated as Extra / Volume when data is from Norgate.With CSV import this field, which can also be referred to as Extra, will contain whatever values were included in the column defined as Extra in your CSV import.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.180",
          "title": "Extra",
          "line": 4314
        }
      ],
      "sample_examples": [
        {
          "file": "samples/keltner_pullback.rts",
          "line": 47,
          "code": "//\tLimitExtra:\tTrigger * 0.001"
        },
        {
          "file": "samples/mr_sample_common.rts",
          "line": 42,
          "code": "LimitExtra:\t0.001 * C\t// price must go 0.1% beyond limit price to get a fill"
        },
        {
          "file": "samples/mr_sample_orders_alera.rts",
          "line": 40,
          "code": "LimitExtra:\t0.001 * C\t// price must go 0.1% beyond limit price to get a fill"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "F.xxx",
      "title": "F.xxx / F.xxx.Date",
      "aliases": [
        "F.xxx.Date"
      ],
      "section": "17.18.181",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Stock/Contract Information",
      "description": "Value or report date of a current fundamental item that was imported from Norgate",
      "example": "Script fundamentals.rts shows how this all works:",
      "notes": "Norgate current fundamentals can optionally be added to imported data by adding Fundamentals to your Import definition and specifying one or more fundamental items to obtain.Replace xxx with the name of an imported fundamental item, e.g. F.epsactualq, to access a value thus imported.Use F.xxx.Date, e.g. F.epsactualq.Date, to obtain the date on which this item was reported, according to Norgate.The",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.181",
          "title": "F.xxx / F.xxx.Date",
          "line": 4318
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "FeesInOut",
      "title": "FeesInOut",
      "aliases": [],
      "section": "17.18.182",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Syntax Element Details",
      "description": "Specifies deposits and/or withdarawals to/from the current equity of a strategy by formula Input Formula expression returning an amount in dollars",
      "example": "script.",
      "notes": "This formula is evaluated once per day at the beginning of the day, before any trading signals are processed. The resulting amount is added to the equity of the strategy. The formula should return a positive value for deposits or a negative value for withdrawals, or 0 on dates when neither occurs.The simplest way to use this formula in a multi-strategy system is to give it its own strategy, as in the examples below.To provide a list of specific dates and amounts, use Fees List rather than Fees In Out. Unlike Cash In Out, Fees In Out are included in all the stats calculations of a backtest\u2026",
      "see_also": [
        "the management_fees.rts"
      ],
      "manual_refs": [
        {
          "section": "17.18.182",
          "title": "FeesInOut",
          "line": 4322
        }
      ],
      "sample_examples": [
        {
          "file": "samples/annual_taxes.rts",
          "line": 32,
          "code": "//\tFeesInOut:\t-Combined(TaxOwed)[1] // invesetment stats are \"after taxes\""
        },
        {
          "file": "samples/management_fees.rts",
          "line": 32,
          "code": "FeesInOut:\t-Combined(mgmt_fee + perf_fee)[1] // \"Fees\" are included in stats, \"Cash\" is not"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "FeesList",
      "title": "FeesList",
      "aliases": [],
      "section": "17.18.183",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Syntax Element Details",
      "description": "Specifies a CSV file that lists deposits and/or withdrawals to/from the current equity of a strategy Input Path to a CSV file with dates in the first column and amounts in the second column",
      "example": null,
      "notes": "The file can have any number of rows, and can have multiple rows for the same date.The header row is optional.Use positive amounts for deposits and negative amounts for withdrawals.Amounts for each date in a test are applied at the beginning of that day, before any trading signals are processed.If dates are weekend or holiday, they are applied to the next trading day.To specify deposits and withdrawals by formula, use Fees In Out rather than Fees List.Unlike Cash List, items in Fees List are included in all the stats calculations of a backtest, such as the annual return, max drawdown, and\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.183",
          "title": "FeesList",
          "line": 4327
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "FillFraction",
      "title": "FillFraction",
      "aliases": [],
      "section": "17.18.184",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Current Position Information",
      "description": "Equity fraction of current position size at time of initial entry order (or actual entry)",
      "example": null,
      "notes": "Fill Fraction returns the initially ordered position size as a fraction of S.Alloc at the time of the order.This was the same fraction used to check the potential entry against the Max Exposure constraint.Fill Fraction is the same as the actual position size fraction unless a gap causes a difference between order price and entry price.The Fill Fraction of each trade becomes the T.Fraction value in the trade list.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.184",
          "title": "FillFraction",
          "line": 4329
        }
      ],
      "sample_examples": [
        {
          "file": "samples/mr_sample_long_only.rts",
          "line": 25,
          "code": "ExitTradeValue:\tFillFraction // becomes TLValueOut in the playback strategy"
        },
        {
          "file": "samples/mr_sample_short_only.rts",
          "line": 23,
          "code": "ExitTradeValue:\tFillFraction // becomes TLValueOut in the playback strategy"
        },
        {
          "file": "samples/mr_sample_tradelist.rts",
          "line": 10,
          "code": "TLValueOut is the FillFraction (T.Fraction) of each entry (ditto)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "FillPrice",
      "title": "FillPrice",
      "aliases": [],
      "section": "17.18.185",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Current Position Information",
      "description": "Entry fill price (or exit fill price when calculating commission or slippage for exit transactions)",
      "example": null,
      "notes": "Fill Price is generally the price per share at which this position was entered. This will match the Price In value from the backtest Trade List.In formulas evaluated at the same time as Entry Setup -- before tomorrow's entry price could have been known -- Fill Price returns Order Price by default.This automatic substitution of Order Price for Fill Price typically applies to:\u00b7 Quantity\u00b7 Exit Limit and/or Exit Stop for exit orders attached to an entry order The purpose of this automatic substitution is to ensure that a future backtest will match the orders that would have been generated and\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.185",
          "title": "FillPrice",
          "line": 4333
        }
      ],
      "sample_examples": [
        {
          "file": "samples/bensdorp_book.rts",
          "line": 92,
          "code": "Slippage:\t0.002 * FillPrice\t// slippage for non-limit orders"
        },
        {
          "file": "samples/dividend_capture.rts",
          "line": 49,
          "code": "ExitLimit:\tFillPrice + 3 * Dividend[-Bars] // can't use unadjusted prices in strategy price formulas"
        },
        {
          "file": "samples/futures_trend_follow_simple.rts",
          "line": 37,
          "code": "ExitRule:\tC <= Max(FillPrice - Stop[BarsHeld+1], Lowest(C, Breaklen))"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "FillPriceAvg",
      "title": "FillPriceAvg",
      "aliases": [],
      "section": "17.18.186",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Current Position Information",
      "description": "Average entry fill price of current position when pyramiding (Max Same Sym > 1)",
      "example": null,
      "notes": "For pyrmiding strategies, Fill Price Avg returns the volume-weighted average price of all entry transactions in the current position.For non-pyramiding strategies, Fill Price Avg simply returns Fill Price.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.186",
          "title": "FillPriceAvg",
          "line": 4335
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "FillPriceMax",
      "title": "FillPriceMax",
      "aliases": [],
      "section": "17.18.187",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Current Position Information",
      "description": "Highest entry fill price of current position when pyramiding (Max Same Sym > 1)",
      "example": null,
      "notes": "For pyrmiding strategies, Fill Price Max returns the highest price of all entry transactions in the current position.For non-pyramiding strategies, Fill Price Max simply returns Fill Price.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.187",
          "title": "FillPriceMax",
          "line": 4337
        }
      ],
      "sample_examples": [
        {
          "file": "samples/turtles.rts",
          "line": 91,
          "code": "ExitStop:\tmax(Lowest(L, len_out) - TickSize, Combined(FillPriceMax - 2 * N[BarsHeld]))"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "FillPriceMin",
      "title": "FillPriceMin",
      "aliases": [],
      "section": "17.18.188",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Current Position Information",
      "description": "Lowest entry fill price of current position when pyramiding (Max Same Sym > 1)",
      "example": null,
      "notes": "For pyrmiding strategies, Fill Price Min returns the lowest price of all entry transactions in the current position.For non-pyramiding strategies, Fill Price Min simply returns Fill Price.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.188",
          "title": "FillPriceMin",
          "line": 4342
        }
      ],
      "sample_examples": [
        {
          "file": "samples/martingale.rts",
          "line": 1,
          "code": "Notes:\tshows how to use MaxSameSym and FillPriceMin to implement a martingale-ish strategy"
        },
        {
          "file": "samples/turtles.rts",
          "line": 99,
          "code": "ExitStop:\tmin(Highest(H, len_out) + TickSize, Combined(FillPriceMin + 2 * N[BarsHeld]))"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "FillQty",
      "title": "FillQty",
      "aliases": [],
      "section": "17.18.189",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Current Position Information",
      "description": "Shares or contracts in current position at time of entry",
      "example": "to exit one fourth of the original position on each of the first four days after entry, simply write:",
      "notes": "For most positions Fill Qty will be the same as Shares.The only time these quantities can differ is after a partial exit.Partial exits can be specified using Exit Qty, Exit Limit Qty, and/or Exit Stop Qty.Indeed the main purpose of Fill Qty is to facilitate expression of partial exit quantities in the above formulas.For",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.189",
          "title": "FillQty",
          "line": 4344
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "FillValue",
      "title": "FillValue",
      "aliases": [],
      "section": "17.18.190",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Current Position Information",
      "description": "Dollar value of current position at time of entry",
      "example": null,
      "notes": "Fill Value returns the initial position size, in notional dollars, of the current position.This same value could be simply calculated as Fill Price * Shares * Point Value.The one exception to Fill Value being the initial position size is when it is used in the Commission or Slippage formulas. Since those formulas are evaluated separately for the entry and exit sides of each round-trip trade, Fill Value automatically retrieves the exit position size when these two formulas are evaluated at position exit time.If you need Fill Value to be negative for short positions, multiply it by Side.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.190",
          "title": "FillValue",
          "line": 4346
        }
      ],
      "sample_examples": [
        {
          "file": "samples/goal_30_15.rts",
          "line": 48,
          "code": "Commission:\tMin(0.01 * FillValue, Max(1, 0.005 * Shares)) // IB US commissions"
        },
        {
          "file": "samples/goal_30_15_asx.rts",
          "line": 49,
          "code": "Commission:\t1.1 * Max(6.00, 0.0008 * FillValue) // IB ASX commissions"
        },
        {
          "file": "samples/goal_30_15_tsx.rts",
          "line": 47,
          "code": "Commission:\tMin(0.005 * FillValue, Max(1, 0.01 * Shares)) // IB TSX commissions"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "FilterNum",
      "title": "FilterNum",
      "aliases": [],
      "section": "17.18.191",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Stock/Contract Information",
      "description": "Filter formula number which the current stock passed on the current date during scan evaluation",
      "example": ".",
      "notes": "This",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.191",
          "title": "FilterNum",
          "line": 4351
        }
      ],
      "sample_examples": [
        {
          "file": "samples/multi_filter_scan.rts",
          "line": 29,
          "code": "Action:\tif(FilterNum == 1, \"BUY\", \"SHORT\")"
        },
        {
          "file": "samples/simple_day_trade_basket_scan.rts",
          "line": 21,
          "code": "Filter2:\tsetup // FilterNum is used below to differentiate these rows"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "Find",
      "title": "Find",
      "aliases": [],
      "section": "17.18.192",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "String Functions",
      "description": "Find a string within another string and return its offset",
      "example": null,
      "notes": "All string comparisons in Real Test are case-insensitive.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.192",
          "title": "Find",
          "line": 4353
        }
      ],
      "sample_examples": [
        {
          "file": "samples/Sample2.rts",
          "line": 3,
          "code": "find out which crossover MA lengths would have done best"
        },
        {
          "file": "samples/Sample2a.rts",
          "line": 3,
          "code": "find out which crossover MA lengths would have done best"
        },
        {
          "file": "samples/dividend_capture.rts",
          "line": 24,
          "code": "// look ahead to next ex-div date to find dividend amount (but is this practical?)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Format",
      "title": "Format",
      "aliases": [],
      "section": "17.18.193",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "String Functions",
      "description": "Format a string with embedded items",
      "example": "this would be Format(\"5-day ROC {%2}\", c / c[5] - 1).Use {?} to insert a string within another string. The parameter that corresponds with {?} can be either a literal string or a function that returns a string. You can even write nested Format functions if you can think of a reason to do so.",
      "notes": "The string parameter can contain one or more embedded Format Specifiers. Each one will correspond to a parameter passed to the function. The corresponding parameter (formula) is evaluated and its result is inserted in the string in place of the format specifier.An",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.193",
          "title": "Format",
          "line": 4355
        }
      ],
      "sample_examples": [
        {
          "file": "samples/actual_trades.rts",
          "line": 33,
          "code": "// below are tempates for some other trade list formats"
        },
        {
          "file": "samples/bottomup/actual_trades.rts",
          "line": 33,
          "code": "// below are tempates for some other trade list formats"
        },
        {
          "file": "samples/djia_use_syminfo.rts",
          "line": 2,
          "code": "shows how to use a symbol information file to add metadata to an import"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "FormatDate",
      "title": "FormatDate",
      "aliases": [],
      "section": "17.18.194",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "String Functions",
      "description": "Convert a date to a string in any format",
      "example": null,
      "notes": "In script-specified output such as Scan items with {//} as their output format, dates are automatically formatted using the currently defined Date Display or the default as defined in Program Options. Format Date is provided for the rare case where you need a specific date formatted differently from the current setting.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.194",
          "title": "FormatDate",
          "line": 4360
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "FunBar",
      "title": "FunBar",
      "aliases": [],
      "section": "17.18.196",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Bar Data Values",
      "description": "Ordinal number of a data bar within the the calculation of a multi-bar function.",
      "example": "of how this works, the following shows the evaluation steps of Sum(Fun Bar, 5): Within the internal calculation loop of the Sum function, Fun Bar starts at 1 for the earliest bar, then is incremented as the calculation proceeds.For a more complex , see the ehlers_windows.rts script.",
      "notes": "A typical use case for Fun Bar is as the second argument to the Correl function when correlating a data series with a linear growth line.",
      "see_also": [
        "Fun Stat for the stats series version.Fun Bar makes it possible",
        "in some cases",
        "to calculate with a one-line function call a complex formula that otherwise need to be written with looping code. As a simple"
      ],
      "manual_refs": [
        {
          "section": "17.18.196",
          "title": "FunBar",
          "line": 4367
        }
      ],
      "sample_examples": [
        {
          "file": "samples/clenow_stocks_on_move.rts",
          "line": 33,
          "code": "R2:\t#SlowCalc Correl(Log(C), FunBar, lookback) ^ 2"
        },
        {
          "file": "samples/clenow_stocks_on_move_dynamic.rts",
          "line": 33,
          "code": "R2:\t#SlowCalc Correl(Log(C), FunBar, lookback) ^ 2"
        },
        {
          "file": "samples/ehlers_windows.rts",
          "line": 20,
          "code": "trifunc:\tif(FunBar <= len/2, FunBar, len+1-FunBar)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Fundamentals",
      "title": "Fundamentals",
      "aliases": [],
      "section": "17.18.195",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Import Specification",
      "description": "List of one or more current fundamental items to include when importing Norgate data",
      "example": "Script fundamentals.rts shows how this all works:",
      "notes": "Norgate provides more than 160 current fundamental data items for each stock. To see the names and descriptions of these fields, add \"Fundamentals: \" to your Import section and then press F2 or start typing something. The auto-complete mechanism will guide you. Another way to quickly view all of the available fundamental items for a stock is to open a Chart and then select Get Information from the Chart Menu. To access the items thus imported, use F.xxx (where xxx is the item name) to get the value or F.xxx.Date to get its release date.The",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.195",
          "title": "Fundamentals",
          "line": 4362
        }
      ],
      "sample_examples": [
        {
          "file": "samples/fundamentals.rts",
          "line": 3,
          "code": "use auto-complete in the Fundamentals statement to see all the available values"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "FunStat",
      "title": "FunStat",
      "aliases": [],
      "section": "17.18.197",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "Ordinal number of a stat period within the calculation of a multi-bar function",
      "example": null,
      "notes": "A typical use case for Fun Stat is as the second argument to the Correl function for correlating a stats series with a linear growth line.",
      "see_also": [
        "Fun Bar for the data series version."
      ],
      "manual_refs": [
        {
          "section": "17.18.197",
          "title": "FunStat",
          "line": 4373
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "FuturesMargin",
      "title": "FuturesMargin",
      "aliases": [],
      "section": "17.18.198",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Futures margin requirement per contract Input Formula specifying dollars per contract of required margin",
      "example": null,
      "notes": "Real Test uses futures margin requirement data if available when a strategy trades futures and specifies either Cash Int Pct or Min Free Cash. Futures positions never \"use margin\" in the sense of having to borrow funds from the broker. Rather, futures margin is the cash collateral required to hold a position. Brokers typically do not pay interest on the cash used as collateral for futures positions and do not allow a position to be opened if there is insufficient cash to cover the margin requirement.Historical futures data typically does not include historical margin requirements. Norgate\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.198",
          "title": "FuturesMargin",
          "line": 4375
        }
      ],
      "sample_examples": [
        {
          "file": "samples/futures_trend_follow_csi.rts",
          "line": 41,
          "code": "FuturesMargin:\t10 * NDlr \t// estimated margin requirement per contract"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "FxRatio",
      "title": "FxRatio",
      "aliases": [],
      "section": "17.18.199",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Current Position Information",
      "description": "Foreign currency exchange ratio for this position on this date",
      "example": null,
      "notes": "If Currency was specified and the current symbol does not trade in that base currency and the needed FX conversion symbol was also imported then Fx Ratio will report the current currency conversion ratio for this position on this date.If any of the above conditions is not true then Fx Ratio will simply return 1.Since Real Test manages currency conversions at position entry and exit and adjusts daily mark-to-market position values by FX ratio, you're unlikely to need to use Fx Ratio directly. It is intended for use cases such as an informational daily Test Scan output of open positions for all\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.199",
          "title": "FxRatio",
          "line": 4380
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "GetField",
      "title": "GetField",
      "aliases": [],
      "section": "17.18.200",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "String Functions",
      "description": "Extract a delimited substring from a string",
      "example": "Get Field(\"a-b-c\", \"-\", 2) returns \"b\".",
      "notes": "Though delimiter is typically one character such as \",\" it can also be multiple characters.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.200",
          "title": "GetField",
          "line": 4382
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Graphs",
      "title": "Graphs",
      "aliases": [],
      "section": "17.18.202",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Script Sections",
      "description": "Daily stats graph content definitions",
      "example": null,
      "notes": "See Graphs Section and Daily Stats Graph Windows.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.202",
          "title": "Graphs",
          "line": 4391
        }
      ],
      "sample_examples": [
        {
          "file": "samples/management_fees.rts",
          "line": 31,
          "code": "StartPercent:\t0 // graphs descending from $0"
        },
        {
          "file": "samples/mr_sample_tracking.rts",
          "line": 4,
          "code": "open Graphs after running this example to see the four equity curves"
        },
        {
          "file": "samples/oex_tf_auto_track.rts",
          "line": 60,
          "code": "Tracker:\tHidden // change to Visible to see their equity graphs and stats"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "GreedyScoring",
      "title": "GreedyScoring",
      "aliases": [],
      "section": "17.18.201",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Determines whether strategy uses a special variant of top-down setup selection Choices True - use greedy scoring mode False - don't use greedy scoring mode (default)",
      "example": "): Setup Score: Select(Order Sum(1) = 0 and Position Sum(1) = 0, score1, -Correl Avg(Is Order or Shares > 0, roc1, bars)) In this \"score1\" is calculated in Data and is only used when there are no open positions and no other setups selected yet, so nothing to correlate the new setup with:score1: if(setup, -Correl Avg(setup, roc1, bars), nan) As can easily be imagined, re-evaluating Correl Avg for\u2026",
      "notes": "Greedy Scoring mode provides a way to employ a greedy algorithm within the top-down setup selection process.When enabled, this mode causes Setup Score to be re-evaluated for each setup at each step of the selection loop.This allows a kind of dynamic scoring process that includes each already-selected setup in the score for the next one.The main use case for this mode is to produce an optimally uncorrelated portfolio.The algorithm to do so works like this:while setup slots remain, select the available setup with the lowest average correlation to open positions and other setups selected so far\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.201",
          "title": "GreedyScoring",
          "line": 4387
        }
      ],
      "sample_examples": [
        {
          "file": "samples/optimal_diversity.rts",
          "line": 5,
          "code": "this is enabled by the \"GreedyScoring: True\" strategy setting"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "High",
      "title": "High or H",
      "aliases": [
        "H"
      ],
      "section": "17.18.203",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Bar Data Values",
      "description": "Current bar high price",
      "example": null,
      "notes": "Either High or H can be used as the name of this value.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.203",
          "title": "High or H",
          "line": 4396
        }
      ],
      "sample_examples": [
        {
          "file": "samples/Sample1.rts",
          "line": 3,
          "code": "to run for the first time, first click on Import, then click on Test"
        },
        {
          "file": "samples/Sample2.rts",
          "line": 3,
          "code": "find out which crossover MA lengths would have done best"
        },
        {
          "file": "samples/Sample2a.rts",
          "line": 3,
          "code": "find out which crossover MA lengths would have done best"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "Highest",
      "title": "Highest or HHV",
      "aliases": [
        "HHV"
      ],
      "section": "17.18.204",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Highest (largest) value in a series",
      "example": null,
      "notes": "Either Highest or HHV can be used as the name of this function.This function supports one-pass calculation when used in the Data Section with a non-variable count.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.204",
          "title": "Highest or HHV",
          "line": 4398
        }
      ],
      "sample_examples": [
        {
          "file": "samples/bensdorp_book.rts",
          "line": 102,
          "code": "ExitStop:\tMax(FillPrice - 5 * atr20, HHV(C,BarsHeld)*0.75)"
        },
        {
          "file": "samples/beta_indicator.rts",
          "line": 27,
          "code": "// show the current highest-beta members of $SPX"
        },
        {
          "file": "samples/bottomup/beta_indicator.rts",
          "line": 27,
          "code": "// show the current highest-beta members of $SPX"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "HMA",
      "title": "HMA or HAvg",
      "aliases": [
        "HAvg"
      ],
      "section": "17.18.205",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Hull moving average",
      "example": null,
      "notes": "Either HMA or HAvg can be used as the name of this function.The Hull moving average is calculated using nested weighted moving averages (WMA). HMA(expr, count) could be calculated as WMA((2 * WMA(expr, count/2) - WMA(expr, count)), SQR(count)).",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.205",
          "title": "HMA or HAvg",
          "line": 4400
        }
      ],
      "sample_examples": [
        {
          "file": "samples/cii_rotate.rts",
          "line": 65,
          "code": "Benchmark: SPY // compare to SPY with dividend reinvestement"
        },
        {
          "file": "samples/clenow_stocks_on_move.rts",
          "line": 70,
          "code": "Benchmark: buy_and_hold"
        },
        {
          "file": "samples/clenow_stocks_on_move_dynamic.rts",
          "line": 62,
          "code": "Benchmark: buy_and_hold"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "HolidayList",
      "title": "HolidayList",
      "aliases": [],
      "section": "17.18.206",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings or Strategy Elements",
      "description": "Specifies the path to a text file which contains a list of future holidays, or \"us_auto\"",
      "example": null,
      "notes": "The purpose of the holiday list is to enable Real Test to know the next market date when generating orders.For backtesting, Real Test does not require a holiday list because there are simply no data bars with market holiday dates.There is therefore no reason to provide a holiday list except when generating orders.A settings-level Holiday List will apply to all strategies in the script.A strategy-level Holiday List only applies to that strategy and will override the settings-level list of both are provided.For US stock strategies you can specify Holiday List: us_auto and Real Test will\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.206",
          "title": "HolidayList",
          "line": 4405
        }
      ],
      "sample_examples": [
        {
          "file": "samples/combined.rts",
          "line": 21,
          "code": "HolidayList:\t?scriptpath?\\holidays.us.txt \t// only needed for generating tomorrow's orders"
        },
        {
          "file": "samples/combined_multi_bar_size.rts",
          "line": 19,
          "code": "HolidayList:\t?scriptpath?\\holidays.us.txt \t// only needed for generating tomorrow's orders"
        },
        {
          "file": "samples/namespace_example.rts",
          "line": 18,
          "code": "HolidayList: \tus_auto"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "HVOL",
      "title": "HVOL",
      "aliases": [],
      "section": "17.18.207",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Indicator Functions",
      "description": "Historical volatility",
      "example": null,
      "notes": "HVOL(len) could be calculated as Std Dev(log(c/c[1]),len) * 100 * Sqr(ppy).ppy defaults to S.BPY if the current bar size is Daily, 52 for Weekly, 12 for Monthly, 4 for Quarterly, 1 for Yearly.This function supports one-pass calculation when used in the Data Section with a non-variable count.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.207",
          "title": "HVOL",
          "line": 4407
        }
      ],
      "sample_examples": [
        {
          "file": "samples/bensdorp_book.rts",
          "line": 28,
          "code": "hv100:\thvol(100)"
        },
        {
          "file": "samples/flipper.rts",
          "line": 41,
          "code": "SetupScore:\thvol(50)"
        },
        {
          "file": "samples/radge_bbo.rts",
          "line": 37,
          "code": "TradeRank:\t1/HVOL(26)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "ICDF",
      "title": "ICDF",
      "aliases": [],
      "section": "17.18.208",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Inverse Cumulative Distribution Function",
      "example": null,
      "notes": "The inverse CDF converts cumulative probabilities into data values for a specified distribution, such as the normal distribution. This aids in trading indicator development by mapping normalized data back to meaningful price levels, helping to identify significant market thresholds.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.208",
          "title": "ICDF",
          "line": 4412
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "IF",
      "title": "IF",
      "aliases": [],
      "section": "17.18.209",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Conditional choice function",
      "example": null,
      "notes": "Only one the two formulas gets evaluated, depending on the condition. The function returns the result of evaluating the selected formula.This function can also be referred to as \"IIF\" if you prefer.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.209",
          "title": "IF",
          "line": 4414
        }
      ],
      "sample_examples": [
        {
          "file": "samples/actual_trades.rts",
          "line": 50,
          "code": "// the TLTimeShift setting tells RT how to shift the date/time values so they're aligned with ASX data bars"
        },
        {
          "file": "samples/annual_taxes.rts",
          "line": 12,
          "code": "SinceEOY:\tif(EndOfYear, SinceTrue(EndOfYear)[1], 0)"
        },
        {
          "file": "samples/bensdorp_book.rts",
          "line": 36,
          "code": "// strategy-specific setup criteria are pre-calculated here so tests will run faster"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "IgnoreDividends",
      "title": "IgnoreDividends",
      "aliases": [],
      "section": "17.18.210",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Determines whether trade profits in a test include dividends paid while the position was held Choices True - don't include dividends in trade and test P/LFalse - include dividends in trade and test P/L (default)",
      "example": null,
      "notes": "This strategy-level setting is only relevant if your imported data includes dividends as per-share amounts paid on ex-dividend dates rather than as dividend-adjusted prices.The default Adjustment mode for most Data Source choices (e.g. Norgate) is Capital, i.e. only adjust for stock splits, not for dividends.In this mode, Real Test by default applies each dividend received to the P/L of the trade and the test. For a long position, the dividend is a credit. For a short position it is a debit.Most users prefer to see the impact of dividends in their test results without having to use\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.210",
          "title": "IgnoreDividends",
          "line": 4419
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Import",
      "title": "Import",
      "aliases": [],
      "section": "17.18.211",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Script Sections",
      "description": "Data import specification",
      "example": null,
      "notes": "See Import Section.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.211",
          "title": "Import",
          "line": 4421
        }
      ],
      "sample_examples": [
        {
          "file": "samples/Sample1.rts",
          "line": 3,
          "code": "to run for the first time, first click on Import, then click on Test"
        },
        {
          "file": "samples/Sample2.rts",
          "line": 6,
          "code": "DataFile:\tsample1.rtd // see Sample1.rts for import instructions"
        },
        {
          "file": "samples/Sample2a.rts",
          "line": 6,
          "code": "DataFile:\tsample1.rtd // see Sample1.rts for import instructions"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "Include",
      "title": "Include",
      "aliases": [],
      "section": "17.18.212",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Script Sections",
      "description": "Allows a script to include another script",
      "example": ", include just one part of a Strategy definition such as a set of exit-related items.The combined scripts are parsed as one large script, so each item name (Data items etc.) must be unique across the combined scripts.Suggested names in the script editor (auto-complete) will include any names defined in included scripts.Include is applied in all script run modes. To include another script in a\u2026",
      "notes": "A script can include any number of other scripts by using multiple include statements.Included scripts can include other scripts, and so on (it's recursive).Real Test ensures that each specific script is included only once.Included scripts must contain entire script section definitions -- they cannot, for",
      "see_also": [
        "Include Section."
      ],
      "manual_refs": [
        {
          "section": "17.18.212",
          "title": "Include",
          "line": 4423
        }
      ],
      "sample_examples": [
        {
          "file": "samples/Sample1.rts",
          "line": 8,
          "code": "IncludeList:\tSPY"
        },
        {
          "file": "samples/actual_trades.rts",
          "line": 9,
          "code": "IncludeList:\t?scriptpath?\\actual_trades.csv // uses Symbol column as import list"
        },
        {
          "file": "samples/anchored_vwap.rts",
          "line": 8,
          "code": "IncludeList:\tSPY"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "IncludeList",
      "title": "IncludeList",
      "aliases": [],
      "section": "17.18.213",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Import Specification",
      "description": "List of one or more symbols to include when importing data",
      "example": ", when importing special symbols for risk-free interest rates, currency conversion etc. Often these symbols will include bars for dates which are otherwise market holidays. To prevent the symbols in an Include List from being added to the global date list, add the comment {//} to the same line in the script. If the list also requires a list name, use the same special comment, e.g. {\"currency\"//}.",
      "notes": "An Import Section can have any number of Include List statements.Each Include List statement can take one of the following forms:\u00b7 One or more symbols, separated by commas (up to a maximum of 260 characters in total)\u00b7 A path to a TXT file containing a list of symbols (one symbol per line with no commas)\u00b7 A path to a CSV file in which a column of symbols has a name that contains \"symbol\" or \"ticker\" or \"underlying\"\u00b7 The name of a Norgate watchlist, preceded by a dot (Norgate only) The symbols from all of the specified include lists are combined into a single internal list.If there are\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.213",
          "title": "IncludeList",
          "line": 4428
        }
      ],
      "sample_examples": [
        {
          "file": "samples/Sample1.rts",
          "line": 8,
          "code": "IncludeList:\tSPY"
        },
        {
          "file": "samples/actual_trades.rts",
          "line": 9,
          "code": "IncludeList:\t?scriptpath?\\actual_trades.csv // uses Symbol column as import list"
        },
        {
          "file": "samples/anchored_vwap.rts",
          "line": 8,
          "code": "IncludeList:\tSPY"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "InfoDelist",
      "title": "InfoDelist / InfoExpiry",
      "aliases": [
        "InfoExpiry"
      ],
      "section": "17.18.216",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Stock/Contract Information",
      "description": "Stock delisting date or futures contract expiration date",
      "example": null,
      "notes": "When using CSI Futures continuous contract data, Info Expiry returns the expiration date of the individual contract that would be held on the date of the current bar for which the formula is being evaluated.When using Norgate futures data, Info Expiry is only provided for individual contract symbols.With Norgate stock data, Info Delist shows the delisting date for delisted symbols.To provide this field in your own Sym Info File, use the Delist Date column.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.216",
          "title": "InfoDelist / InfoExpiry",
          "line": 4442
        }
      ],
      "sample_examples": [
        {
          "file": "samples/cl_term_structure.rts",
          "line": 14,
          "code": "DaysToExp:\tDays(BarDate, InfoExpiry)"
        },
        {
          "file": "samples/futures_calendar_spread.rts",
          "line": 17,
          "code": "DaysToExp:\tDays(BarDate, InfoExpiry)"
        },
        {
          "file": "samples/futures_volume_rank.rts",
          "line": 35,
          "code": "ExpDate: InfoExpiry {//}"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "InfoFloat",
      "title": "InfoFloat",
      "aliases": [],
      "section": "17.18.217",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Stock/Contract Information",
      "description": "The number of shares in circulation (float) for a stock",
      "example": null,
      "notes": "This piece of information is provided automatically when data is imported from Norgate.This is not a historical data series. The number returned is always the current value.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.217",
          "title": "InfoFloat",
          "line": 4444
        }
      ],
      "sample_examples": [
        {
          "file": "samples/djia_make_syminfo.rts",
          "line": 37,
          "code": "Float:\tInfoFloat"
        },
        {
          "file": "samples/djia_use_syminfo.rts",
          "line": 38,
          "code": "Float:\tInfoFloat"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "InfoGICS",
      "title": "InfoGICS",
      "aliases": [],
      "section": "17.18.218",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Stock/Contract Information",
      "description": "Global Industry Classification Standard code",
      "example": null,
      "notes": "Automatically provided when data is imported from Norgate.See the GICS entry in Wikipedia for details.The Info GICS code is available regardless of the Classification scheme used during import. To isolate the upper digits of the code, use the Top function.If the import classification scheme was GICS then level-specific names such as ?Sector are also available.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.218",
          "title": "InfoGICS",
          "line": 4446
        }
      ],
      "sample_examples": [
        {
          "file": "samples/djia_make_syminfo.rts",
          "line": 35,
          "code": "GICS:\tInfoGICS"
        },
        {
          "file": "samples/djia_use_syminfo.rts",
          "line": 36,
          "code": "GICS:\tInfoGICS"
        },
        {
          "file": "samples/gics_indu_rank.rts",
          "line": 27,
          "code": "GICS:\tInfoGICS"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "InfoID",
      "title": "InfoID",
      "aliases": [],
      "section": "17.18.215",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Stock/Contract Information",
      "description": "Norgate Asset ID for this symbol",
      "example": null,
      "notes": "Automatically provided when data is imported from Norgate.To provide this field in your own Sym Info File, use the Asset Id column.The Asset ID is an integer.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.215",
          "title": "InfoID",
          "line": 4437
        }
      ],
      "sample_examples": [],
      "grammar_match": true
    },
    {
      "name": "InfoMargin",
      "title": "InfoMargin",
      "aliases": [],
      "section": "17.18.219",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Stock/Contract Information",
      "description": "Futures contract margin requirement",
      "example": null,
      "notes": "Automatically provided when data is imported from Norgate.To provide this field in your own Sym Info File, use the Margin column.Note that this is just a current value, not a historical data series.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.219",
          "title": "InfoMargin",
          "line": 4451
        }
      ],
      "sample_examples": [
        {
          "file": "samples/futures_volume_rank.rts",
          "line": 36,
          "code": "Margin: InfoMargin"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "InfoShares",
      "title": "InfoShares",
      "aliases": [],
      "section": "17.18.220",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Stock/Contract Information",
      "description": "Number of shares in existence (outstanding) for a stock",
      "example": null,
      "notes": "This piece of information is provided automatically when data is imported from Norgate.This is not a historical data series. The number returned is always the current value.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.220",
          "title": "InfoShares",
          "line": 4453
        }
      ],
      "sample_examples": [
        {
          "file": "samples/djia_make_syminfo.rts",
          "line": 36,
          "code": "Shr:\tInfoShares\t{\"Shares\"}"
        },
        {
          "file": "samples/djia_use_syminfo.rts",
          "line": 37,
          "code": "Shr:\tInfoShares\t{\"Shares\"}"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "InfoTRBC",
      "title": "InfoTRBC",
      "aliases": [],
      "section": "17.18.221",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Stock/Contract Information",
      "description": "Thomson Reuters Business Classification code",
      "example": null,
      "notes": "Automatically provided when data is imported from Norgate.See the TRBC entry in Wikipedia for details.The Info TRBC code is available regardless of the Classification scheme used during import.To isolate the upper digits of the code, use the Top function.If the import classification scheme was TRBC then level-specific names such as ?Sector are also available.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.221",
          "title": "InfoTRBC",
          "line": 4455
        }
      ],
      "sample_examples": [
        {
          "file": "samples/djia_make_syminfo.rts",
          "line": 34,
          "code": "TRBC:\tInfoTRBC"
        },
        {
          "file": "samples/djia_use_syminfo.rts",
          "line": 35,
          "code": "TRBC:\tInfoTRBC"
        },
        {
          "file": "samples/goal_30_15.rts",
          "line": 33,
          "code": "CanHoldShort:\tC < 2 * EMA100 and Top(InfoTRBC, 4) <> 5620"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "InList",
      "title": "InList",
      "aliases": [],
      "section": "17.18.222",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Stock/Contract Information",
      "description": "Checks whether this symbol was part of a specific Include List when it was imported",
      "example": ": A breadth indicator is constructed using NDX components by counting how many of them are above their 20-day averages.The strategy trades only DJIA components and only when the NDX breadth indicator is above 80.This could also have used Constituency: $NDX, $DJI and replaced the In List(1) with In NDX and In List(2) with In DJI. Using historical index constituency (requires Norgate Platinum\u2026",
      "notes": "If the current data file was imported using multiple Include List statements, In List can be used to filter symbols based on their include list membership.This is especially useful when a strategy uses one set of symbols for trading and a different set of symbols for calculating an indicator.Here is a contrived",
      "see_also": [
        "List Num",
        "which returns the number of the first list that included a symbol."
      ],
      "manual_refs": [
        {
          "section": "17.18.222",
          "title": "InList",
          "line": 4459
        }
      ],
      "sample_examples": [
        {
          "file": "samples/cl_term_structure.rts",
          "line": 15,
          "code": "AgeRank:\t#Rank if(InList(1), -DaysToExp, nan)"
        },
        {
          "file": "samples/combined.rts",
          "line": 33,
          "code": "EntrySetup:\tEndOfWeek and InList(1) \t// next day will be a new week and symbol comes from first import list"
        },
        {
          "file": "samples/combined_multi_bar_size.rts",
          "line": 32,
          "code": "EntrySetup:\tInList(1) \t// next day will be a new week and symbol comes from first import list"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "InSet",
      "title": "InSet",
      "aliases": [],
      "section": "17.18.223",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Whether a value is in a specific set of values",
      "example": null,
      "notes": "In Set(Symbol, $AAPL, $GOOGL, $MSFT) is equivalent to:Symbol = $AAPL or Symbol = $GOOGL or Symbol = $MSFTArguments can be numeric or strings. If strings then comparison is case-insensitive.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.223",
          "title": "InSet",
          "line": 4462
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "InXXX",
      "title": "InXXX",
      "aliases": [],
      "section": "17.18.214",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Bar Data Values",
      "description": "Norgate Index constituency lookup (if specified during import)",
      "example": ", In SPX > In SPX[1] would be a way to find dates on which stocks were added to the S&P 500, and In SPX < In SPX[1] would find dates on which they were removed.",
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.214",
          "title": "InXXX",
          "line": 4435
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "IsExit",
      "title": "IsExit",
      "aliases": [],
      "section": "17.18.224",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Current Position Information",
      "description": "True when the formula being evaluated pertains to a position being exited",
      "example": "in a long strategy you could account for the extra SEC Section 31 fee on the sale of shares:",
      "notes": "Is Exit is provided for the few strategy formulas that are evaluated at both entry time and exit time.This include:\u00b7 Commission\u00b7 Slippage\u00b7 Order Note / Order Extra Use Is Exit in any of the above formulas as needed to differentiate entry vs. exit values.For",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.224",
          "title": "IsExit",
          "line": 4467
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "IsNan",
      "title": "IsNan",
      "aliases": [],
      "section": "17.18.225",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Returns 1 (true) if formula can't be evaluated, or 0 (false) if it can.",
      "example": ", if you import data for SPY starting 1/2/2010 and then try to calculate a 200-day moving average for 2/1/2010, there are not enough bars yet, so Avg(C,200) will return NAN, and Is Nan(AVG(C,200)) will return TRUE.Once any term of any formula evaluates to NAN, the result of the entire formula becomes NAN. This is why it can be useful to find out if a specific term is NAN before evaluating the\u2026",
      "notes": "The most common reason that a formula can't be evaluated is that it tries to refer to more bars of data than are currently available. For",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.225",
          "title": "IsNan",
          "line": 4469
        }
      ],
      "sample_examples": [
        {
          "file": "samples/futures_calendar_spread.rts",
          "line": 30,
          "code": "Filter:\tnot IsNan(Spread)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "IsOrder",
      "title": "IsOrder",
      "aliases": [],
      "section": "17.18.226",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Current Position Information",
      "description": "Returns 1 (true) if the current stock passed Entry Setup for the specified strategy and was not \"skipped\" for any reason (Max Setups, Max Positions, etc.)",
      "example": null,
      "notes": "Without Combined or Extern, Is Order applies only to the current stock in the current strategy.When used with Combined or Extern, Is Order returns the count of strategies for which the current stock is a setup and has not been \"skipped\".",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.226",
          "title": "IsOrder",
          "line": 4477
        }
      ],
      "sample_examples": [
        {
          "file": "samples/optimal_diversity.rts",
          "line": 40,
          "code": "SetupScore:\tSelect(OrderSum(1) = 0 and PositionSum(1) = 0, score1, -CorrelAvg(IsOrder or Shares > 0, roc1, bars))"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "IsSetup",
      "title": "IsSetup",
      "aliases": [],
      "section": "17.18.227",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Current Position Information",
      "description": "Returns 1 (true) if the current stock passed Entry Setup for the specified strategy",
      "example": null,
      "notes": "Without Combined or Extern, Is Setup will by definition be 0 (false) when referenced in Entry Setup, or 1 (true) in any other entry-related formula, since the others are only evaluated for setups.When used with Combined or Extern, Is Setup returns the count of strategies for which the current stock met the Entry Setup condition.Since Is Setup remains true even for skipped setups, Is Order is generally more useful for avoiding duplicate entries in the same symbol.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.227",
          "title": "IsSetup",
          "line": 4479
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "IsTracker",
      "title": "IsTracker",
      "aliases": [],
      "section": "17.18.228",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Current Strategy Information",
      "description": "Indicates whether the strategy is being processed as itself or as its tracking benchmark in the Strat Data section topic for a more complex",
      "example": "script for a simple of Tracker and Is Tracker usage.See the oex_tf_auto_track.rts script and its .",
      "notes": "When a strategy specifies Tracker as either Visible or Hidden, a Benchmark copy of the strategy is internally added.This means that each formula defined by the strategy is evaluated twice per test day: once for the strategy and once for its tracking benchmark.Is Tracker can be used in any formula that needs to do something different depending on which one is being evaluated.See the mr_sample_tracking.rts",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.228",
          "title": "IsTracker",
          "line": 4481
        }
      ],
      "sample_examples": [
        {
          "file": "samples/mr_sample_tracking.rts",
          "line": 10,
          "code": "SetupSkip:\tif(not IsTracker, Extern(@tracker, S.Equity < Avg(S.Equity, 150)), 0)"
        },
        {
          "file": "samples/oex_tf_auto_track.rts",
          "line": 56,
          "code": "srank:\t#Rank  if(IsTracker, factor, nan) // nan excludes strategies themselves"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Item",
      "title": "Item",
      "aliases": [],
      "section": "17.18.229",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Reference a Data Item, Library Item or Test Parameter by name",
      "example": ", Item(\"entry_rule_{#}\", rule_num) would look for an item called \"entry_rule_1\" if rule_num had a value of 1.The referenced item must be the name of an item in either the Data or Library section of the current script (or an included script).One use of this feature is to have a set of different factors that could be parts of an Entry Setup or Exit Rule, for which you can run a kind of optimization\u2026",
      "notes": "This function works the same way Format does in terms of its",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.229",
          "title": "Item",
          "line": 4486
        }
      ],
      "sample_examples": [
        {
          "file": "samples/combined.rts",
          "line": 24,
          "code": "// just one item needed, for the VIX strategy"
        },
        {
          "file": "samples/combined_multi_bar_size.rts",
          "line": 23,
          "code": "// just one item needed, for the VIX strategy"
        },
        {
          "file": "samples/combined_rebalance.rts",
          "line": 12,
          "code": "// just one item needed, for the VIX strategy"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "KAMA",
      "title": "KAMA",
      "aliases": [],
      "section": "17.18.230",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Kaufman Adaptive Moving Average",
      "example": null,
      "notes": "KAMA is a kind of exponential moving average which adapts its weighting factor (often mistaken for a lookback length) at each bar of its calculation by computing the Kaufman Efficiency Ratio and using that to determine that bar's weighting.The most common",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.230",
          "title": "KAMA",
          "line": 4489
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "KBBot",
      "title": "KBBot",
      "aliases": [],
      "section": "17.18.231",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Indicator Functions",
      "description": "Keltner band (channel) bottom",
      "example": null,
      "notes": "It's not clear that there's a \"standard\" way to implement Keltner channels. The center line could be either a simple or an exponential average. The ATR might use a simple average, EMA, or Wilder's smoothing. This function is a shortcut for EMA(C, len) - atrs * EMA(TR, len).This indicator supports one-pass calculation when used in the Data Section with a non-variable length.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.231",
          "title": "KBBot",
          "line": 4494
        }
      ],
      "sample_examples": [
        {
          "file": "samples/keltner_pullback.rts",
          "line": 32,
          "code": "KBot:\tKBBOT(20, 2)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "KBTop",
      "title": "KBTop",
      "aliases": [],
      "section": "17.18.232",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Indicator Functions",
      "description": "Keltner band (channel) top",
      "example": null,
      "notes": "It's not clear that there's a \"standard\" way to implement Keltner channels. The center line could be either a simple or an exponential average. The ATR might use a simple average, EMA, or Wilder's smoothing. This function is a shortcut for EMA(C, len) + atrs * EMA(TR, len).This indicator supports one-pass calculation when used in the Data Section with a non-variable length.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.232",
          "title": "KBTop",
          "line": 4496
        }
      ],
      "sample_examples": [
        {
          "file": "samples/keltner_pullback.rts",
          "line": 31,
          "code": "KTop:\tKBTOP(20, 2)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "KeepAdjusted",
      "title": "KeepAdjusted",
      "aliases": [],
      "section": "17.18.233",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Import Specification",
      "description": "Whether to keep imported price and volume data values split-adjusted rather than as-traded Choices False - don't keep adjusted (default) True - keep adjusted",
      "example": null,
      "notes": "In most cases, False is the recommended choice.If True is selected, all prices used or shown in any context are adjusted for future splits. If True is selected and the data source provides it, the Extra field is used to store the unadjusted close in each bar.See Split Handling for details on how Real Test uses unadjusted data with knowledge of split factors to provide realistic as-traded backtests.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.233",
          "title": "KeepAdjusted",
          "line": 4501
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "KeepNonIncluded",
      "title": "KeepNonIncluded",
      "aliases": [],
      "section": "17.18.234",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Import Specification",
      "description": "Whether to keep all files found in local file data path when Include List is used Choices False - only import the symbols in the Include List if specified (default) True - import all files (symbols) found even when Include List is specified",
      "example": null,
      "notes": "With database (whether local or cloud) data sources (Norgate, Tiingo, Yahoo, etc.) it is always true that only the symbols listed in one or more Include List definitions will be imported. With local file data sources (CSV, CSIFutures, CSIStocks, Metastock) we often want to simply import all the files found in the specified Data Path locations.By default, with local file sources, the use of an Include List acts like a filter, meaning \"only include these symbols\".Keep Non Included enables Include List to be used to define named/numbered subsets of the available symbols while still importing all\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.234",
          "title": "KeepNonIncluded",
          "line": 4503
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "KeepRedundant",
      "title": "KeepRedundant",
      "aliases": [],
      "section": "17.18.235",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Import Specification",
      "description": "Whether to keep multiple redundant stocks of the same company in the data file Choices False - don't keep redundant stocks (default) True - keep redundant stocks",
      "example": "for the Norgate Nasdaq 100 Current & Past watchlist:",
      "notes": "By default, when you import data that includes company names, Real Test uses the names to look for redundancies. Specifically, if two names include \" class \" or \" series \" (note the spaces on either side of each string), and the strings up to and including that word are identical, then the two stocks are considered redundant.When a pair of redundant stocks is found, the most recent 20-day average turnover is calculated for each, and only the one with the larger average turnover is kept.Redundant stocks that were removed are shown in the Import Log if one was created, like this",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.235",
          "title": "KeepRedundant",
          "line": 4508
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "KeepTrades",
      "title": "KeepTrades",
      "aliases": [],
      "section": "17.18.236",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "Specifies which categories of trades to store in each test results record Choices (multiple, separated by commas) None - don't keep any trades (a good choice when running large optimizations) Strategy - keep regular strategy trades (the most common choice) Benchmark - keep benchmark strategy trades Skipped - keep trades (setups) that were skipped for various reasons All - a one-word shortcut for all of the above (except none)",
      "example": null,
      "notes": "If Keep Trades is not specified in a script then the choices from the Settings Panel will be used.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.236",
          "title": "KeepTrades",
          "line": 4512
        }
      ],
      "sample_examples": [
        {
          "file": "samples/mr_sample_long_only.rts",
          "line": 11,
          "code": "KeepTrades:\tStrategy"
        },
        {
          "file": "samples/mr_sample_short_only.rts",
          "line": 9,
          "code": "KeepTrades:\tStrategy"
        },
        {
          "file": "samples/ndx_rotate_weekly_reduce.rts",
          "line": 15,
          "code": "KeepTrades:\tStrategy,Benchmark // so you can see the original strategy (now a bencyhmark) trades as well"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Kurtosis",
      "title": "Kurtosis",
      "aliases": [],
      "section": "17.18.237",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Statistical measure of the heaviness of the tail of a distribution of values",
      "example": null,
      "notes": "Kurtosis is calculated in the way that Excel would calculate a KURT.P function if it had one, i.e., as if the set of count values is the entire population.The specific formula used is shown below, in the \"kurt\" item: This also illustrates how these statistical functions could be calculated in the Data Section of a script, though since they're provided built-in, there's no reason to do so.This function supports one-pass calculation when used in the Data Section with a non-variable count.",
      "see_also": [
        "Std Dev and Skewness."
      ],
      "manual_refs": [
        {
          "section": "17.18.237",
          "title": "Kurtosis",
          "line": 4514
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Left",
      "title": "Left",
      "aliases": [],
      "section": "17.18.238",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "String Functions",
      "description": "Return the left end of a string",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.238",
          "title": "Left",
          "line": 4517
        }
      ],
      "sample_examples": [
        {
          "file": "samples/futures_trend_follow_simple.rts",
          "line": 21,
          "code": "Liquid:\tLowest(V,5) > VolMin and BarsLeft > 5"
        },
        {
          "file": "samples/futures_volume_rank.rts",
          "line": 15,
          "code": "MktRank: #rank #ByMkt if(InList(2) and BarsLeft >= 5, Volume, -1)"
        },
        {
          "file": "samples/turtles.rts",
          "line": 31,
          "code": "Universe:\tInList(list) and Liquid and (list==1 or BarsLeft > 63)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Length",
      "title": "Length",
      "aliases": [],
      "section": "17.18.239",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "String Functions",
      "description": "Return the number of characters in a string",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.239",
          "title": "Length",
          "line": 4521
        }
      ],
      "sample_examples": [
        {
          "file": "samples/Sample2.rts",
          "line": 3,
          "code": "find out which crossover MA lengths would have done best"
        },
        {
          "file": "samples/Sample2a.rts",
          "line": 3,
          "code": "find out which crossover MA lengths would have done best"
        },
        {
          "file": "samples/beta_indicator.rts",
          "line": 13,
          "code": "len:\t100 // beta lookback length (arbitrary)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Library",
      "title": "Library",
      "aliases": [],
      "section": "17.18.240",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Script Sections",
      "description": "Named formulas calculated when they are referenced, using the current context .",
      "example": null,
      "notes": "See Library Section for a more detailed",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.240",
          "title": "Library",
          "line": 4523
        }
      ],
      "sample_examples": [
        {
          "file": "samples/annual_taxes.rts",
          "line": 2,
          "code": "library script to add capital gains and dividend income tax calculations to any set of strategies"
        },
        {
          "file": "samples/clenow_stocks_on_move.rts",
          "line": 46,
          "code": "Library:"
        },
        {
          "file": "samples/clenow_stocks_on_move_dynamic.rts",
          "line": 46,
          "code": "Library:"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "LimitExtra",
      "title": "LimitExtra",
      "aliases": [],
      "section": "17.18.241",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Excursion beyond a limit price to require before assuming the limit order was filled Input Any formula specifying dollars per share (points)",
      "example": null,
      "notes": "If this element is not specified or evaluates to 0, then limit orders are assumed to fill completely whenever the limit price is within the range of the day. This will be true even if the price happens to match the exact high or low. In live trading it is not realistic to assume that limit orders very near the high or low of the day will be filled.By using Limit Extra, you can make your trading model more realistic.The value returned by this formula should specify a number of points (price per share) to require as the minimum extra excursion beyond the limit price.A very simple assumption is\u2026",
      "see_also": [
        "Entry Limit",
        "Exit Limit."
      ],
      "manual_refs": [
        {
          "section": "17.18.241",
          "title": "LimitExtra",
          "line": 4525
        }
      ],
      "sample_examples": [
        {
          "file": "samples/keltner_pullback.rts",
          "line": 47,
          "code": "//\tLimitExtra:\tTrigger * 0.001"
        },
        {
          "file": "samples/mr_sample_common.rts",
          "line": 42,
          "code": "LimitExtra:\t0.001 * C\t// price must go 0.1% beyond limit price to get a fill"
        },
        {
          "file": "samples/mr_sample_orders_alera.rts",
          "line": 40,
          "code": "LimitExtra:\t0.001 * C\t// price must go 0.1% beyond limit price to get a fill"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "LimitSlip",
      "title": "LimitSlip",
      "aliases": [],
      "section": "17.18.242",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Slippage amount, in points (dollars per share or contract), for each limit order transaction Input Any formula specifying dollars per share or contract (points)",
      "example": null,
      "notes": "Defines the amount of slippage to apply to each limit order transaction, in price points. Limit Slip is applied to any transaction that occurs at an Entry Limit or Exit Limit price.If Limit Slip is not specified then Slippage is applied instead.When a strategy uses both Entry Stop and Entry Limit (enters positions with a stop-limit order) and the fill is at the stop price, Stop Slip is applied.When using Limit Slip: 0 consider testing with non-zero Limit Extra.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.242",
          "title": "LimitSlip",
          "line": 4530
        }
      ],
      "sample_examples": [
        {
          "file": "samples/bensdorp_book.rts",
          "line": 93,
          "code": "LimitSlip:\t0\t// slippage for limit orders"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "LinReg",
      "title": "LinReg",
      "aliases": [],
      "section": "17.18.243",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Linear regression",
      "example": null,
      "notes": "Calculates the endpoint of a linear regression of expr evaluated for the previous count bars.This is equivalent to YInt + (Slope * latest_x_value).This function is equivalent to =FORECAST in Excel.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.243",
          "title": "LinReg",
          "line": 4532
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "ListNum",
      "title": "ListNum",
      "aliases": [],
      "section": "17.18.244",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Stock/Contract Information",
      "description": "The number of the first import Include List which contained this symbol",
      "example": null,
      "notes": null,
      "see_also": [
        "In List",
        "which can be used to check whether the current symbol was in a specific Include List.For an import where each symbol only appears in one include list",
        "List Num==n is equivalent to In List(n).In List(n) will always be true when List Num==n",
        "but List Num==n will only be true if n is the first list to contain the symbol.When CIIFamily and CIILevel are used with Norgate Import",
        "corresponding industry index symbols are automatically imported for each specific symbol that has one. These automatically imported symbols are placed in a virtual include list with the number 99. See cii_rotate.rts in the Examples folder for further clarification on how this CII mechanism works."
      ],
      "manual_refs": [
        {
          "section": "17.18.244",
          "title": "ListNum",
          "line": 4537
        }
      ],
      "sample_examples": [
        {
          "file": "samples/cii_rotate.rts",
          "line": 6,
          "code": "a special ListNum value of 99 is used to identify these ETFs by include list"
        },
        {
          "file": "samples/futures_calendar_spread.rts",
          "line": 29,
          "code": "Spread:\tItem(\"Spread{#}\",ListNum)"
        },
        {
          "file": "samples/industry_indices.rts",
          "line": 5,
          "code": "After running the import, data wil include all the current SPX component symbols (ListNum = 1),"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "Log",
      "title": "Log",
      "aliases": [],
      "section": "17.18.245",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Natural logarithm of a number",
      "example": null,
      "notes": "A daily log return could be calculated as Log(S.Equity/S.Equity[1]).Weekly would be Log(S.Equity/S.Equity[5]).The log return of a trade (for display in the trade list window, assuming long side) would be Log(T.Price Out/T.Price In).",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.245",
          "title": "Log",
          "line": 4539
        }
      ],
      "sample_examples": [
        {
          "file": "samples/actual_trades.rts",
          "line": 36,
          "code": "// this works for IB TWS trade log export files with default columns"
        },
        {
          "file": "samples/bottomup/actual_trades.rts",
          "line": 36,
          "code": "// this works for IB TWS trade log export files with default columns"
        },
        {
          "file": "samples/clenow_stocks_on_move.rts",
          "line": 30,
          "code": "// AdjSlope calculation (#SlowCalc is required because log(c) of unadjusted prices can't be buffered)"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "LogFile",
      "title": "LogFile",
      "aliases": [],
      "section": "17.18.246",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Import Specification",
      "description": "Path and name of an import log file to create",
      "example": "where the DJIA components were imported but stocks above $100/share were excluded from the import. The log shows which those were. The \"Events\" column in this case shows how many ex-dividend dates there were in this time period for each stock. If a custom event list is used, the count of those events would be shown here as well.",
      "notes": "If Log File is specified, the file is created at the start of the import, written to during the import, and then opened to a Log Window when the import finishes.Here is a simple",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.246",
          "title": "LogFile",
          "line": 4544
        }
      ],
      "sample_examples": [
        {
          "file": "samples/djia_earnings.rts",
          "line": 14,
          "code": "//LogFile:\tDJIA.TXT // uncomment to see event counts for each symbol, and any date errors that were found"
        },
        {
          "file": "samples/import_multi.rts",
          "line": 42,
          "code": "LogFile:\tmulti.log"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Logit",
      "title": "Logit",
      "aliases": [],
      "section": "17.18.247",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Inverse Logistic Function",
      "example": null,
      "notes": "The Logit function transforms probabilities from the range [0, 1] back to the real number line In trading, it can be used to revert normalized probability-based data to meaningful market values, aiding in the interpretation of logistic regression models.Logit(value) is calculated as Log(value / (1 - value)).",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.247",
          "title": "Logit",
          "line": 4549
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Low",
      "title": "Low or L",
      "aliases": [
        "L"
      ],
      "section": "17.18.248",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Bar Data Values",
      "description": "Current bar low price",
      "example": null,
      "notes": "Either Low or L can be used as the name of this value.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.248",
          "title": "Low or L",
          "line": 4552
        }
      ],
      "sample_examples": [
        {
          "file": "samples/Sample1.rts",
          "line": 2,
          "code": "Simplest Example -- 50/200 crossover on SPY"
        },
        {
          "file": "samples/Sample2.rts",
          "line": 2,
          "code": "2-Parameter optimization example"
        },
        {
          "file": "samples/Sample2a.rts",
          "line": 2,
          "code": "2-Parameter optimization example"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "Lowest",
      "title": "Lowest or LLV",
      "aliases": [
        "LLV"
      ],
      "section": "17.18.249",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Lowest (smallest) value in a series",
      "example": null,
      "notes": "Either Lowest or LLV can be used as the name of this function.This function supports one-pass calculation when used in the Data Section with a non-variable count.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.249",
          "title": "Lowest or LLV",
          "line": 4554
        }
      ],
      "sample_examples": [
        {
          "file": "samples/bensdorp_book.rts",
          "line": 165,
          "code": "EntrySetup:\tSymbol = $SPY and c = llv(c,50)"
        },
        {
          "file": "samples/dividend_capture.rts",
          "line": 22,
          "code": "Universe:\tC >= 5 and C < 55 and LLV(V,10) > 50000"
        },
        {
          "file": "samples/futures_trend_follow_csi.rts",
          "line": 29,
          "code": "Liquid:\tInList(\"CSI\") and Lowest(V, 5) > VolMin"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "MA",
      "title": "MA or Avg",
      "aliases": [
        "Avg"
      ],
      "section": "17.18.250",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Simple Moving Average",
      "example": null,
      "notes": "Either MA or Avg can be used as the name of this function.This function supports one-pass calculation when used in the Data Section with a non-variable count.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.250",
          "title": "MA or Avg",
          "line": 4559
        }
      ],
      "sample_examples": [
        {
          "file": "samples/Sample1.rts",
          "line": 19,
          "code": "EntrySetup:\tAvg(C,50) > Avg(C,200)"
        },
        {
          "file": "samples/Sample2.rts",
          "line": 3,
          "code": "find out which crossover MA lengths would have done best"
        },
        {
          "file": "samples/Sample2a.rts",
          "line": 3,
          "code": "find out which crossover MA lengths would have done best"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "MACD",
      "title": "MACD",
      "aliases": [],
      "section": "17.18.251",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Indicator Functions",
      "description": "Moving Average Convergence Divergence",
      "example": null,
      "notes": "MACD is the difference between two moving averages. It is calculated as EMA(C,len1) - EMA(C,len2).This indicator supports one-pass calculation when used in the Data Section with non-variable lengths.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.251",
          "title": "MACD",
          "line": 4561
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "MACDH",
      "title": "MACDH",
      "aliases": [],
      "section": "17.18.252",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Indicator Functions",
      "description": "MACD Histogram",
      "example": null,
      "notes": "MACDH is the difference between MACD and its signal line.It is calculated as MACD(len1,len2) - MACDS(len1, len2, len3).This indicator supports one-pass calculation when used in the Data Section with non-variable lengths.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.252",
          "title": "MACDH",
          "line": 4563
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "MACDS",
      "title": "MACDS",
      "aliases": [],
      "section": "17.18.253",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Indicator Functions",
      "description": "MACD Signal Line",
      "example": null,
      "notes": "MACDS is an EMA-smoothed version of MACD.This is also know as the \"signal line\".It is calculated as EMA(MACD(len1,len2),len3).This indicator supports one-pass calculation when used in the Data Section with non-variable lengths.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.253",
          "title": "MACDS",
          "line": 4567
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "MarginIntPct",
      "title": "MarginIntPct",
      "aliases": [],
      "section": "17.18.254",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "Interest rate paid for negative daily excess cash (margin loan)",
      "example": "if your broker charges 1.5% more than the fed funds rate for margin loans then specify Margin Int Pct: 1.5.If Margin Int Pct is provided when there is no Risk Free Rate Sym setting then Margin Int Pct is simply the annualized margin interest rate, e.g. Margin Int Pct: 6.5.Daily net interest received or paid is added to combined S.Equity and therefore becomes part of the total return of the\u2026",
      "notes": "If the settings also provide a Risk Free Rate Sym then Margin Int Pct is added to the current daily interest rate as determined by today's value of the risk-free rate series. For",
      "see_also": [
        "Cash Int Pct which specifies the interest rate received for positive excess cash."
      ],
      "manual_refs": [
        {
          "section": "17.18.254",
          "title": "MarginIntPct",
          "line": 4569
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "MarkToMarket",
      "title": "MarkToMarket",
      "aliases": [],
      "section": "17.18.255",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Determines whether strategy equity includes open-position mark-to-market value Choices True - equity includes mark-to-market (default) False - equity is closed-trade-basis",
      "example": null,
      "notes": "This setting changes the value of S.Equity. By default, S.Equity is updated daily as (starting capital) + (net closed trade profits) + (net open position mark to market values). If Mark To Market: False is added to a strategy, then its S.Equity series becomes (starting capital) + (net closed trade profits).This setting also affects the internal calculations of S.DDDlr, S.DDPct, S.Max DDDlr, S.Max DDPct, S.Net Dlr and S.Net Pct. It also affects the default value of Allocation if no formula is provided, since that default is Combined(S.Equity).",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.255",
          "title": "MarkToMarket",
          "line": 4574
        }
      ],
      "sample_examples": [
        {
          "file": "samples/turtles.rts",
          "line": 60,
          "code": "MarkToMarket:\tFalse\t// causes drawdowns to be based on closed trades only as per Jerry Parker et all."
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Match",
      "title": "Match",
      "aliases": [],
      "section": "17.18.256",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "String Functions",
      "description": "Determine whether a string matches a pattern",
      "example": null,
      "notes": "The string and pattern are compared character by character.? in the pattern can match any single character in the string. * in the pattern can match zero or more characters in the string.Otherwise, the characters must match exactly (ignoring case for letters).Examples Match(\"test1\", \"test2\") is False Match(\"test1\", \"test?\") is True Match(\"test1\", \"*test\") is False Match(\"test1\", \"test*\") is True Common Uses Does string contain \"XYZ\"?\u00d8Match(string, \"*XYZ*\") Does a string start with \"XYZ\"?\u00d8Match(string, \"XYZ*\") Does string end with \"XYZ\"?\u00d8Match(string, \"*XYZ\") Symbol Information (Norgate) Was a\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.256",
          "title": "Match",
          "line": 4576
        }
      ],
      "sample_examples": [
        {
          "file": "samples/actual_trades.rts",
          "line": 24,
          "code": "Strategy: longs // must exactly match a name found in the strategy column in the trade list"
        },
        {
          "file": "samples/bottomup/actual_trades.rts",
          "line": 24,
          "code": "Strategy: longs // must exactly match a name found in the strategy column in the trade list"
        },
        {
          "file": "samples/mr_sample_tradelist.rts",
          "line": 11,
          "code": "Quantity uses these to calculate the number of shares required to match the fractions of the imported trades"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Max",
      "title": "Max",
      "aliases": [],
      "section": "17.18.257",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Largest of a group of values",
      "example": null,
      "notes": "This function evaluates each of the formulas passed to it and returns the largest value found.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.257",
          "title": "Max",
          "line": 4581
        }
      ],
      "sample_examples": [
        {
          "file": "samples/annual_taxes.rts",
          "line": 16,
          "code": "TaxOwed:\tmax(LTGain, 0) * lt_gain_rate + max(STGain, 0) * st_gain_rate + max(Dividends, 0) * div_rate"
        },
        {
          "file": "samples/bensdorp_book.rts",
          "line": 90,
          "code": "MaxPositions:\t10"
        },
        {
          "file": "samples/cii_rotate.rts",
          "line": 61,
          "code": "MaxPositions:\t15"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "MaxCatExp",
      "title": "MaxCatExp",
      "aliases": [],
      "section": "17.18.259",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements for a strategy or group of strategies Input Any formula specifying a percentage would not exceed the percent of S.Alloc expressed as Max Cat Exp.Use the formula to define the of any security.If a setup cannot be selected due to this constraint and the strategy specifies Reduce: True, then the position's Quantity will be reduced to allow the position to be ordered for entry at smaller size if possible.Setups skipped for this reason display \"max cat exp\" in the Reason column of the Trade List, provided that the Keep Trades setting included Skipped.If Max Cat Exp is not\u2026",
      "description": "Percent exposure limit for positions in the same",
      "example": null,
      "notes": "Max Cat Exp is one of the Capacity Constraints formulas used in the setup selection process.A setup is only selected if its position size plus those of other setups and open positions in that",
      "see_also": [
        ": Backtest Engine Details and Capacity Constraints"
      ],
      "manual_refs": [
        {
          "section": "17.18.259",
          "title": "MaxCatExp",
          "line": 4587
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "MaxCatInv",
      "title": "MaxCatInv",
      "aliases": [],
      "section": "17.18.260",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements for a strategy or group of strategies Input Any formula specifying a dollar amount would not exceed the dollar value expressed as Max Cat Inv.Use the formula to define the of any security.If a setup cannot be selected due to this constraint and the strategy specifies Reduce: True, then the position's Quantity will be reduced to allow the position to be ordered for entry at smaller size if possible.Setups skipped for this reason display \"max cat inv\" in the Reason column of the Trade List, provided that the Keep Trades setting included Skipped.If Max Cat Inv is not specified\u2026",
      "description": "Dollar investment limit for positions in the same",
      "example": null,
      "notes": "Max Cat Inv is one of the Capacity Constraints formulas used in the setup selection process.A setup is only selected if its position size plus those of other setups and open positions in that",
      "see_also": [
        ": Backtest Engine Details and Capacity Constraints"
      ],
      "manual_refs": [
        {
          "section": "17.18.260",
          "title": "MaxCatInv",
          "line": 4589
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "MaxEntries",
      "title": "MaxEntries",
      "aliases": [],
      "section": "17.18.261",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Caps the number of actual position entries per day Input Any formula that returns a count",
      "example": null,
      "notes": "Max Entries is a specialized formula that is only needed when modeling strategies that allow more setups than entries. It should NOT be used as a general-purpose strategy constraint. Use Max New Pos if you want to cap the daily new position count at order time.",
      "see_also": [
        "Entry Score."
      ],
      "manual_refs": [
        {
          "section": "17.18.261",
          "title": "MaxEntries",
          "line": 4593
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "MaxExposure",
      "title": "MaxExposure",
      "aliases": [],
      "section": "17.18.262",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Open position exposure limit for a strategy or group of strategies Input Any formula specifying a percentage",
      "example": null,
      "notes": "Max Exposure is one of the Capacity Constraints formulas used in the setup selection process.A setup is only selected if its position size plus those of other setups selected so far plus current S.Invested of open positions divided by current S.Alloc would not exceed the percentage expressed as Max Exposure.If a setup cannot be selected due to this constraint and the strategy specifies Reduce: True, then the position's Quantity will be reduced to allow the position to be ordered for entry at smaller size if possible.Setups skipped for this reason display \"max exposure\" in the Reason column of\u2026",
      "see_also": [
        ": Backtest Engine Details and Capacity Constraints"
      ],
      "manual_refs": [
        {
          "section": "17.18.262",
          "title": "MaxExposure",
          "line": 4595
        }
      ],
      "sample_examples": [
        {
          "file": "samples/clenow_stocks_on_move.rts",
          "line": 60,
          "code": "MaxExposure:\t100"
        },
        {
          "file": "samples/clenow_stocks_on_move_dynamic.rts",
          "line": 59,
          "code": "MaxExposure:\t100"
        },
        {
          "file": "samples/futures_trend_follow_simple.rts",
          "line": 36,
          "code": "MaxExposure:\t1000\t// notional 10x of account"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "MaxInvested",
      "title": "MaxInvested",
      "aliases": [],
      "section": "17.18.263",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Dollar investment limit for a strategy or group of strategies Input Any formula specifying a dollar amount",
      "example": null,
      "notes": "Max Invested is one of the Capacity Constraints formulas used in the setup selection process.A setup is only selected if its position size plus those of other setups selected so far plus current S.Invested of open positions would not exceed the dollar value expressed as Max Invested.If a setup cannot be selected due to this constraint and the strategy specifies Reduce: True, then the position's Quantity will be reduced to allow the position to be ordered for entry at smaller size if possible.Setups skipped for this reason display \"max invested\" in the Reason column of the Trade List, provided\u2026",
      "see_also": [
        ": Backtest Engine Details and Capacity Constraints"
      ],
      "manual_refs": [
        {
          "section": "17.18.263",
          "title": "MaxInvested",
          "line": 4600
        }
      ],
      "sample_examples": [
        {
          "file": "samples/dividend_capture.rts",
          "line": 45,
          "code": "MaxInvested:\tS.Alloc"
        },
        {
          "file": "samples/higher_lows.rts",
          "line": 44,
          "code": "MaxInvested:\tS.Alloc"
        },
        {
          "file": "samples/keltner_pullback.rts",
          "line": 48,
          "code": "MaxInvested:\tS.Equity"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "MaxLongExp",
      "title": "MaxLongExp",
      "aliases": [],
      "section": "17.18.264",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Open long position exposure limit for a strategy or group of strategies Input Any formula specifying a percentage",
      "example": null,
      "notes": "Max Long Exp is one of the Capacity Constraints formulas used in the setup selection process.A long setup is only selected if its position size plus those of other long setups selected so far plus current S.Long Inv of open positions divided by current S.Alloc would not exceed the percentage expressed as Max Long Exp.If a setup cannot be selected due to this constraint and the strategy specifies Reduce: True, then the position's Quantity will be reduced to allow the position to be ordered for entry at smaller size if possible.Setups skipped for this reason display \"max long exp\" in the Reason\u2026",
      "see_also": [
        ": Backtest Engine Details and Capacity Constraints"
      ],
      "manual_refs": [
        {
          "section": "17.18.264",
          "title": "MaxLongExp",
          "line": 4604
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "MaxLongInv",
      "title": "MaxLongInv",
      "aliases": [],
      "section": "17.18.265",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Dollar investment limit in long positions for a strategy or group of strategies Input Any formula specifying a dollar amount",
      "example": null,
      "notes": "Max Long Inv is one of the Capacity Constraints formulas used in the setup selection process.A long setup is only selected if its position size plus those of other long setups selected so far plus current S.Long Inv of open positions would not exceed the dollar value expressed as Max Long Inv.If a setup cannot be selected due to this constraint and the strategy specifies Reduce: True, then the position's Quantity will be reduced to allow the position to be ordered for entry at smaller size if possible.Setups skipped for this reason display \"max long inv\" in the Reason column of the Trade\u2026",
      "see_also": [
        ": Backtest Engine Details and Capacity Constraints"
      ],
      "manual_refs": [
        {
          "section": "17.18.265",
          "title": "MaxLongInv",
          "line": 4606
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "MaxN",
      "title": "MaxN",
      "aliases": [],
      "section": "17.18.258",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Nth largest of a group of values",
      "example": null,
      "notes": "This function evaluates each of the formulas passed to it and returns the Nth largest value found.Max N(1, value1, value2) is the same as Max(value1, value2).",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.258",
          "title": "MaxN",
          "line": 4585
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "MaxNetExp",
      "title": "MaxNetExp",
      "aliases": [],
      "section": "17.18.266",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Maximum net long-short position exposure for a strategy or group of strategies Input Any formula specifying a percentage",
      "example": null,
      "notes": "Max Net Exp is one of the Capacity Constraints formulas used in the setup selection process.A setup is only selected if its signed position size plus those of other setups selected so far plus current net S.Long Exp - S.Short Exp of open positions divided by current S.Alloc would not exceed the percentage expressed as Max Net Exp. (In practice only a long setup could trigger this constraint.) If a setup cannot be selected due to this constraint and the strategy specifies Reduce: True, then the position's Quantity will be reduced to allow the position to be ordered for entry at smaller size if\u2026",
      "see_also": [
        ": Backtest Engine Details and Capacity Constraints"
      ],
      "manual_refs": [
        {
          "section": "17.18.266",
          "title": "MaxNetExp",
          "line": 4611
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "MaxNetInv",
      "title": "MaxNetInv",
      "aliases": [],
      "section": "17.18.267",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Maximum net long-short dollar investment for a strategy or group of strategies Input Any formula specifying a dollar amount",
      "example": null,
      "notes": "Max Net Inv is one of the Capacity Constraints formulas used in the setup selection process.A setup is only selected if its signed position size plus those of other setups selected so far plus current net S.Long Inv - S.Short Inv of open positions would not exceed the dollar value expressed as Max Net Inv. (In practice only a long setup could trigger this constraint.) If a setup cannot be selected due to this constraint and the strategy specifies Reduce: True, then the position's Quantity will be reduced to allow the position to be ordered for entry at smaller size if possible.Setups skipped\u2026",
      "see_also": [
        ": Backtest Engine Details and Capacity Constraints"
      ],
      "manual_refs": [
        {
          "section": "17.18.267",
          "title": "MaxNetInv",
          "line": 4613
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "MaxNewExp",
      "title": "MaxNewExp",
      "aliases": [],
      "section": "17.18.268",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Caps the added exposure from entry orders placed per day by a strategy Input Any formula that returns a percentage",
      "example": ", Max New Exp is 20 and there have already been two other setups with 10% position size selected for order placement, this setup will be rejected even if adding it would not violate any other constraint.",
      "notes": "At each step of the setup selection process, Max New Exp is considered along with each of the other top-down constraints.If, for",
      "see_also": [
        ": Backtest Engine Details and Capacity Constraints"
      ],
      "manual_refs": [
        {
          "section": "17.18.268",
          "title": "MaxNewExp",
          "line": 4618
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "MaxNewInv",
      "title": "MaxNewInv",
      "aliases": [],
      "section": "17.18.269",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Caps the added investment from entry orders placed per day by a strategy Input Any formula that returns a dollar amount",
      "example": ", Max New Inv is $10,000 and there have already been two other setups with $5,000 position size selected for order placement, this setup will be rejected even if adding it would not violate any other constraint.",
      "notes": "At each step of the setup selection process, Max New Inv is considered along with each of the other top-down constraints.If, for",
      "see_also": [
        ": Backtest Engine Details and Capacity Constraints"
      ],
      "manual_refs": [
        {
          "section": "17.18.269",
          "title": "MaxNewInv",
          "line": 4620
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "MaxNewPos",
      "title": "MaxNewPos",
      "aliases": [],
      "section": "17.18.270",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Caps the number of entry orders placed per day when a strategy has more setups than can be entered Input Any formula that returns a count",
      "example": ", Max New Pos is 3 and there have already been three other setups selected for order placement, this setup will be rejected even if adding it would not violate any other constraint.",
      "notes": "At each step of the setup selection process, Max New Pos is considered along with each of the other top-down constraints.If, for",
      "see_also": [
        ": Backtest Engine Details and Capacity Constraints"
      ],
      "manual_refs": [
        {
          "section": "17.18.270",
          "title": "MaxNewPos",
          "line": 4622
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "MaxPerTurn",
      "title": "MaxPerTurn",
      "aliases": [],
      "section": "17.18.271",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Defines how many setups per turn a strategy can select during the top-down setup selection process Input Any formula that returns a count",
      "example": null,
      "notes": "The default is 1, meaning that each strategy selects only one setup per turn of the selection process.To allow a strategy to select all of its setups on its first turn, use a large number (e.g. its maximum positions).Selecting a setup means adding that setup to the list of tomorrow's entry orders.",
      "see_also": [
        ": Backtest Engine Details and Capacity Constraints"
      ],
      "manual_refs": [
        {
          "section": "17.18.271",
          "title": "MaxPerTurn",
          "line": 4627
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "MaxPositions",
      "title": "MaxPositions",
      "aliases": [],
      "section": "17.18.272",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Open position count limit for a strategy or group of strategies Input Any formula specifying a count",
      "example": null,
      "notes": "Max Positions is one of the Capacity Constraints formulas used in the setup selection process.A setup is only selected if the count of currently open positions plus previously selected setups plus one would not exceed the value returned by this formula.Setups skipped for this reason display \"max positions\" in the Reason column of the Trade List, provided that the Keep Trades setting included Skipped. If Max Positions is not specified then there is no limit placed on the number of open positions, though there might still be investment limits if the strategy specifies Max Exposure and/or Max\u2026",
      "see_also": [
        ": Backtest Engine Details and Capacity Constraints"
      ],
      "manual_refs": [
        {
          "section": "17.18.272",
          "title": "MaxPositions",
          "line": 4629
        }
      ],
      "sample_examples": [
        {
          "file": "samples/bensdorp_book.rts",
          "line": 90,
          "code": "MaxPositions:\t10"
        },
        {
          "file": "samples/cii_rotate.rts",
          "line": 61,
          "code": "MaxPositions:\t15"
        },
        {
          "file": "samples/combined.rts",
          "line": 34,
          "code": "MaxPositions:\t1"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "MaxSameCat",
      "title": "MaxSameCat",
      "aliases": [],
      "section": "17.18.273",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements positions that can be open simultaneously in a strategy or group of strategies Input Any formula specifying a count as this setup of currently open positions plus previously selected setups plus one would not exceed the value returned by this formula.Use the formula to define the of any security.Setups skipped for this reason display \"max same \" in the Reason column of the Trade List, provided that the Keep Trades setting included Skipped.If Max Same Cat is not specified then there is no limit placed on the number of same- positions.",
      "description": "Limits the number of same-",
      "example": null,
      "notes": "Max Same Cat is one of the Capacity Constraints formulas used in the setup selection process.A setup is only selected if the count with the same",
      "see_also": [
        ": Backtest Engine Details and Capacity Constraints"
      ],
      "manual_refs": [
        {
          "section": "17.18.273",
          "title": "MaxSameCat",
          "line": 4634
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "MaxSameSym",
      "title": "MaxSameSym",
      "aliases": [],
      "section": "17.18.274",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Count limit for positions in the same symbol for a strategy or group of strategies Input Any formula specifying a count",
      "example": null,
      "notes": "Max Same Sym is one of the Capacity Constraints formulas used in the setup selection process.A setup is only selected if the count of currently open positions plus previously selected setups plus one in that symbol would not exceed the value returned by this formula.Setups skipped for this reason display \"max same symbol\" in the Reason column of the Trade List, provided that the Keep Trades setting included Skipped.The default Max Same Sym for each individual Strategy is 1, i.e., by default no strategy can hold more than one position in the same symbol.For Stats Group or Combined, the default\u2026",
      "see_also": [
        ": Backtest Engine Details and Capacity Constraints"
      ],
      "manual_refs": [
        {
          "section": "17.18.274",
          "title": "MaxSameSym",
          "line": 4636
        }
      ],
      "sample_examples": [
        {
          "file": "samples/clenow_stocks_on_move.rts",
          "line": 59,
          "code": "MaxSameSym:\t99 // required for adding to a position (not clear whether he does this)"
        },
        {
          "file": "samples/hybrid_asset_allocation_dynamic.rts",
          "line": 46,
          "code": "MaxSameSym:\t99"
        },
        {
          "file": "samples/martingale.rts",
          "line": 1,
          "code": "Notes:\tshows how to use MaxSameSym and FillPriceMin to implement a martingale-ish strategy"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "MaxSetups",
      "title": "MaxSetups",
      "aliases": [],
      "section": "17.18.275",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Caps the number of entry setups per day when a strategy has more setups than can be entered Input Any formula that returns a count",
      "example": null,
      "notes": "Max Setups is applied before any other capacity constraints. After building the list of symbols that meet the Entry Setup conditions, the list is sorted by Setup Score. The setup list is then truncated at Max Setups.The only common use case for this constraint is to make tests run faster by trimming the setup list before processing the setups.",
      "see_also": [
        ": Backtest Engine Details and Capacity Constraints"
      ],
      "manual_refs": [
        {
          "section": "17.18.275",
          "title": "MaxSetups",
          "line": 4641
        }
      ],
      "sample_examples": [
        {
          "file": "samples/mr_sample_scan.rts",
          "line": 3,
          "code": "this is because the MaxSetups / SetupScore mechanism is only available during tests, not for scans"
        },
        {
          "file": "samples/mr_sample_test_scan.rts",
          "line": 3,
          "code": "this is because the MaxSetups / SetupScore mechanism is only available during tests, not for scans (even test output ones)"
        },
        {
          "file": "samples/optimal_diversity.rts",
          "line": 39,
          "code": "MaxSetups:\tpositions"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "MaxShortExp",
      "title": "MaxShortExp",
      "aliases": [],
      "section": "17.18.276",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Open short position exposure limit for a strategy or group of strategies Input Any formula specifying a percentage",
      "example": null,
      "notes": "Max Short Exp is one of the Capacity Constraints formulas used in the setup selection process.A short setup is only selected if its position size plus those of other short setups selected so far plus current S.Short Inv of open positions divided by current S.Alloc would not exceed the percentage expressed as Max Short Exp.If a setup cannot be selected due to this constraint and the strategy specifies Reduce: True, then the position's Quantity will be reduced to allow the position to be ordered for entry at smaller size if possible.Setups skipped for this reason display \"max short exp\" in the\u2026",
      "see_also": [
        ": Backtest Engine Details and Capacity Constraints"
      ],
      "manual_refs": [
        {
          "section": "17.18.276",
          "title": "MaxShortExp",
          "line": 4643
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "MaxShortInv",
      "title": "MaxShortInv",
      "aliases": [],
      "section": "17.18.277",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Dollar investment limit in short positions for a strategy or group of strategies Input Any formula specifying a dollar amount",
      "example": null,
      "notes": "Max Short Inv is one of the Capacity Constraints formulas used in the setup selection process.A short setup is only selected if its position size plus those of other short setups selected so far plus current S.Short Inv of open positions would not exceed the dollar value expressed as Max Short Inv.If a setup cannot be selected due to this constraint and the strategy specifies Reduce: True, then the position's Quantity will be reduced to allow the position to be ordered for entry at smaller size if possible.Setups skipped for this reason display \"max short inv\" in the Reason column of the\u2026",
      "see_also": [
        ": Backtest Engine Details and Capacity Constraints"
      ],
      "manual_refs": [
        {
          "section": "17.18.277",
          "title": "MaxShortInv",
          "line": 4648
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "MaxSymExp",
      "title": "MaxSymExp",
      "aliases": [],
      "section": "17.18.278",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Percent exposure limit for positions in the same symbol for a strategy or group of strategies Input Any formula specifying a percentage",
      "example": null,
      "notes": "Max Sym Exp is one of the Capacity Constraints formulas used in the setup selection process.A setup is only selected if its position size plus those of other setups and open positions in that symbol would not exceed the percent of S.Alloc expressed as Max Sym Exp.If a setup cannot be selected due to this constraint and the strategy specifies Reduce: True, then the position's Quantity will be reduced to allow the position to be ordered for entry at smaller size if possible.Setups skipped for this reason display \"max sym exp\" in the Reason column of the Trade List, provided that the Keep Trades\u2026",
      "see_also": [
        ": Backtest Engine Details and Capacity Constraints"
      ],
      "manual_refs": [
        {
          "section": "17.18.278",
          "title": "MaxSymExp",
          "line": 4650
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "MaxSymInv",
      "title": "MaxSymInv",
      "aliases": [],
      "section": "17.18.279",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Dollar investment limit for positions in the same symbol for a strategy or group of strategies Input Any formula specifying a dollar amount",
      "example": null,
      "notes": "Max Sym Inv is one of the Capacity Constraints formulas used in the setup selection process.A setup is only selected if its position size plus those of other setups and open positions in that symbol would not exceed the dollar value expressed as Max Sym Inv.If a setup cannot be selected due to this constraint and the strategy specifies Reduce: True, then the position's Quantity will be reduced to allow the position to be ordered for entry at smaller size if possible.Setups skipped for this reason display \"max sym inv\" in the Reason column of the Trade List, provided that the Keep Trades\u2026",
      "see_also": [
        ": Backtest Engine Details and Capacity Constraints"
      ],
      "manual_refs": [
        {
          "section": "17.18.279",
          "title": "MaxSymInv",
          "line": 4655
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "MDI",
      "title": "MDI",
      "aliases": [],
      "section": "17.18.280",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Indicator Functions",
      "description": "Wilder's Minus Directional Index",
      "example": null,
      "notes": "This is the negative component of the ADX indicator, often referred to as -DI.This indicator supports one-pass calculation when used in the Data Section with a non-variable length.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.280",
          "title": "MDI",
          "line": 4657
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Median",
      "title": "Median",
      "aliases": [],
      "section": "17.18.281",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Median of a series of values",
      "example": null,
      "notes": "Values are calculated and sorted, then the middle one is returned.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.281",
          "title": "Median",
          "line": 4662
        }
      ],
      "sample_examples": [
        {
          "file": "samples/index_breadth.rts",
          "line": 15,
          "code": "MedC:\t#Median C"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Mid",
      "title": "Mid",
      "aliases": [],
      "section": "17.18.282",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "String Functions",
      "description": "Return a segment of a string",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.282",
          "title": "Mid",
          "line": 4664
        }
      ],
      "sample_examples": [
        {
          "file": "samples/Sample2a.rts",
          "line": 13,
          "code": "MidMA:\t30, 50, 70"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Min",
      "title": "Min",
      "aliases": [],
      "section": "17.18.283",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Smallest of a group of values",
      "example": null,
      "notes": "This function evaluates each of the formulas passed to it and returns the smallest value found.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.283",
          "title": "Min",
          "line": 4666
        }
      ],
      "sample_examples": [
        {
          "file": "samples/bensdorp_book.rts",
          "line": 99,
          "code": "Quantity:\tlfrac * Min(S.Alloc/10/C, (S.Alloc*0.02)/(5*atr20))"
        },
        {
          "file": "samples/breadth.rts",
          "line": 10,
          "code": "SymInfoFile:\t?scriptpath?\\spx_syminfo.csv"
        },
        {
          "file": "samples/cl_term_structure.rts",
          "line": 3,
          "code": "determins the 8 newest ones for each date"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "MinFreeCash",
      "title": "MinFreeCash",
      "aliases": [],
      "section": "17.18.285",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Minimum free cash to keep on hand in the trading account Input Any formula specifying a dollar amount",
      "example": null,
      "notes": "Min Free Cash is one of the Capacity Constraints formulas used in the setup selection process.A setup is only selected if current S.Cash minus cash required to enter this position and other setups selected so far would not go below Min Free Cash.For a futures position the cash required to enter is the number of contracts to enter times the S.Futures Margin required per contract.For a long stock position the cash required to enter is the number of shares to buy times the expected entry price.For a short stock position cash is received upon entry so a short setup cannot trigger this constraint\u2026",
      "see_also": [
        ": Backtest Engine Details and Capacity Constraints"
      ],
      "manual_refs": [
        {
          "section": "17.18.285",
          "title": "MinFreeCash",
          "line": 4673
        }
      ],
      "sample_examples": [
        {
          "file": "samples/futures_trend_follow_csi.rts",
          "line": 42,
          "code": "MinFreeCash:\t0.5 * S.Alloc\t// allow up to half NLV to be used as margin, else skip entries"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "MinN",
      "title": "MinN",
      "aliases": [],
      "section": "17.18.284",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Nth Smallest of a group of values",
      "example": null,
      "notes": "This function evaluates each of the formulas passed to it and returns the Nth smallest value found.Min N(1, value1, value2) is the same as Min(value1, value2).",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.284",
          "title": "MinN",
          "line": 4671
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "MinNetExp",
      "title": "MinNetExp",
      "aliases": [],
      "section": "17.18.286",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Minimum net long-short position exposure for a strategy or group of strategies Input Any formula specifying a percentage",
      "example": null,
      "notes": "Min Net Exp is one of the Capacity Constraints formulas used in the setup selection process.A setup is only selected if its signed position size plus those of other setups selected so far plus current net S.Long Exp - S.Short Exp of open positions divided by current S.Alloc would not be less than the percentage expressed as Min Net Exp. (In practice only a short setup could trigger this constraint.) If a setup cannot be selected due to this constraint and the strategy specifies Reduce: True, then the position's Quantity will be reduced to allow the position to be ordered for entry at smaller\u2026",
      "see_also": [
        ": Backtest Engine Details and Capacity Constraints"
      ],
      "manual_refs": [
        {
          "section": "17.18.286",
          "title": "MinNetExp",
          "line": 4678
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "MinNetInv",
      "title": "MinNetInv",
      "aliases": [],
      "section": "17.18.287",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Minimum net long-short dollar investment for a strategy or group of strategies Input Any formula specifying a dollar amount",
      "example": null,
      "notes": "Min Net Inv is one of the Capacity Constraints formulas used in the setup selection process. A setup is only selected if its signed position size plus those of other setups selected so far plus current net S.Long Inv - S.Short Inv of open positions would not be less than the dollar value expressed as Min Net Inv. (In practice only a short setup could trigger this constraint.) If a setup cannot be selected due to this constraint and the strategy specifies Reduce: True, then the position's Quantity will be reduced to allow the position to be ordered for entry at smaller size if possible.Setups\u2026",
      "see_also": [
        ": Backtest Engine Details and Capacity Constraints"
      ],
      "manual_refs": [
        {
          "section": "17.18.287",
          "title": "MinNetInv",
          "line": 4680
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "MissingBars",
      "title": "MissingBars",
      "aliases": [],
      "section": "17.18.288",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Number of bars missing before the current bar in this symbol",
      "example": null,
      "notes": "A \"missing bar\" is a bar that is absent in this stock while being present in most other stocks from the same exchange.This function returns a count of missing bars preceding the current bar. (By definition the current bar must be present.) For most symbols on most dates, Missing Bars() will return 0.A missing bar is detected when the comparison symbol has a bar for that date but the current symbol does not.The default comparison symbol is the Calendar Sym for the current strategy.The optional argument can be used to specify a different comparison symbol if desired.",
      "see_also": [
        "the Allow Missing Bar strategy setting",
        "which determines whether trades can occur on a bar for which Missing Bars() returns > 0."
      ],
      "manual_refs": [
        {
          "section": "17.18.288",
          "title": "MissingBars",
          "line": 4685
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Month",
      "title": "Month",
      "aliases": [],
      "section": "17.18.289",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Bar Data Values",
      "description": "Current bar month number Negative offsets, e.g. Month[-5], can be legitimately used to obtain the month of a future bar. This works even if the offset goes beyond the range of the currently loaded data file. For best results when future dates are required, a Holiday List should also be provided.",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.289",
          "title": "Month",
          "line": 4687
        }
      ],
      "sample_examples": [
        {
          "file": "samples/annual_taxes.rts",
          "line": 5,
          "code": "eoy_month:\t12\t// fiscal year end month"
        },
        {
          "file": "samples/cii_rotate.rts",
          "line": 62,
          "code": "EntrySetup:\tEndOfMonth and CanHold"
        },
        {
          "file": "samples/combined.rts",
          "line": 49,
          "code": "// monthly rotation into the 5 NDX components with the strongest IBD RS"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Namespace",
      "title": "Namespace",
      "aliases": [],
      "section": "17.18.290",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Script Sections",
      "description": "Specifies a prefix for user-defined items, to prevent duplication when including multiple scripts",
      "example": ", Data: Universe: In SPX would internally become Data: xxx.Universe: In SPX.Subsequent statements in the same script could then refer to Universe as EITHER Universe or xxx.Universe.However, if the above Data statement was in an Included script, references in the including script would be required to use xxx.Universe.The most common use case for Namespace is e.g.:Namespace: ns1Include\u2026",
      "notes": "All names defined after a Namespace statement are internally converted to have the specified prefix.For",
      "see_also": [
        "Combining Scripts."
      ],
      "manual_refs": [
        {
          "section": "17.18.290",
          "title": "Namespace",
          "line": 4692
        }
      ],
      "sample_examples": [
        {
          "file": "samples/namespace_example.rts",
          "line": 2,
          "code": "COMBINED VERSION - using namespaces / includes"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "NextOpen",
      "title": "NextOpen",
      "aliases": [],
      "section": "17.18.291",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Bar Data Values",
      "description": "Next bar open price",
      "example": ", if you enter long positions using limit orders and want to skip those entries where the gap down is larger than 5%, you could use Next Open < 0.95 * C as an Entry Skip formula.",
      "notes": "The ability to look ahead to the next open is included as a feature because it is often possible to learn approximately where a stock will open based on its pre-open live trading.For",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.291",
          "title": "NextOpen",
          "line": 4696
        }
      ],
      "sample_examples": [
        {
          "file": "samples/dividend_capture.rts",
          "line": 48,
          "code": "ExitRule:\tBars = ExitBars + 1 // because NextOpen exit time"
        },
        {
          "file": "samples/futures_trend_follow_csi.rts",
          "line": 43,
          "code": "ExitStopTime:\tNextOpen\t// define \"stop\" as closing below the stop price (comment out for live stops)"
        },
        {
          "file": "samples/ndx_plus_wtf_script.rts",
          "line": 60,
          "code": "ExitStopTime:\tNextOpen"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "NoNan",
      "title": "NoNan",
      "aliases": [],
      "section": "17.18.292",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Evaluate an expression with no possibility a of Na N result",
      "example": null,
      "notes": "The default (when only one argument) is to replace Na N with 0. You can optionally specify a different replacement value as needed.It is not usually necessary to use No Nan in any of the strategy element formulas. The backtest engine already equates \"can't be evaluated\" (Na N) with \"false\" or 0 in those formulas. The only exception is Entry Skip, for which \"can't be evaluated\" means \"true\" (do skip the entry).",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.292",
          "title": "NoNan",
          "line": 4698
        }
      ],
      "sample_examples": [
        {
          "file": "samples/vx_futures.rts",
          "line": 30,
          "code": "BL1:\tnonan(extern(&-1,BarsLeft))"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Notes",
      "title": "Notes",
      "aliases": [],
      "section": "17.18.293",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Script Sections",
      "description": "A free-form section in which to organize any",
      "example": null,
      "notes": "about the script This section of a script is not parsed. It is therefore not necessary to use comments to avoid",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.293",
          "title": "Notes",
          "line": 4700
        }
      ],
      "sample_examples": [
        {
          "file": "samples/Sample1.rts",
          "line": 1,
          "code": "Notes:"
        },
        {
          "file": "samples/Sample2.rts",
          "line": 1,
          "code": "Notes:"
        },
        {
          "file": "samples/Sample2a.rts",
          "line": 1,
          "code": "Notes:"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "NoWeekends",
      "title": "NoWeekends",
      "aliases": [],
      "section": "17.18.294",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Import Specification",
      "description": "Whether to remove weekend bars from the data Choices False - keep all bars (default) True - remove weekend bars",
      "example": null,
      "notes": "As of this writing, only crypto-currency data is known to have weekend bars.The purpose of this option is to facilitate data alignment, e.g. for correlation studies between crypto and non-crypto series.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.294",
          "title": "NoWeekends",
          "line": 4704
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "NthOfMonth",
      "title": "NthOfMonth",
      "aliases": [],
      "section": "17.18.295",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Whether current bar date is nth specific weekday of current month",
      "example": "Monday September 9 is the second Monday in US markets even though the 2nd was a holiday (labor day).Examples Is Third Friday: Nth Of Month(5, 3) Is Final Tuesday: Nth Of Month(2, -1) To find a past or future Nth Of Month date, use e.g.Prev First Monday Date: When True(Nth Of Month(1, 1), Bar Date) Next Third Friday Date: When True(Nth Of Month(5, 3), Bar Date, 0, -1) Note that future Nth Of Month\u2026",
      "notes": "This function applies to the date of the current bar being evaluated.The current bar must be the specified weekday for the result to be true.The other instances of that weekday that determine whether the current bar is the \"nth\" do NOT have to be market days.For",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.295",
          "title": "NthOfMonth",
          "line": 4706
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "NumBars",
      "title": "NumBars",
      "aliases": [],
      "section": "17.18.296",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "Number of data bars to include in a scan or test",
      "example": "This is a convenient way to run a daily scan for live trading candidates:",
      "notes": "Use in conjunction with either Start Date or End Date to specify a bar count anchored to a date.(If all three of these date settings are specified then Num Bars will count back from End Date and Start Date will be ignored.) If a date range is not specified in a script then the dates from the Settings Panel will be used.When Bar Size is Daily, Num Bars is a count of market days. Otherwise it is a count of weeks or months, depending on Bar Size.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.296",
          "title": "NumBars",
          "line": 4711
        }
      ],
      "sample_examples": [
        {
          "file": "samples/beta_indicator.rts",
          "line": 24,
          "code": "NumBars:\t1"
        },
        {
          "file": "samples/bottomup/beta_indicator.rts",
          "line": 24,
          "code": "NumBars:\t1"
        },
        {
          "file": "samples/cii_rotate.rts",
          "line": 46,
          "code": "NumBars:\t1"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "OBV",
      "title": "OBV",
      "aliases": [],
      "section": "17.18.297",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Indicator Functions",
      "description": "On Balance Volume indicator",
      "example": null,
      "notes": "Traditional OBV is simply the sum of up-bar volume minus the sum of down-bar volume for the specified period.Real Test divides this value by the sum of all volume for the specified period to express it as a percentage. This indicator could be written as (Sum((C > C[1]) * V, len) - Sum((C < C[1]) * V, len)) / Sum(V, len).",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.297",
          "title": "OBV",
          "line": 4713
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Open",
      "title": "Open or O",
      "aliases": [
        "O"
      ],
      "section": "17.18.298",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Bar Data Values",
      "description": "Current bar open price",
      "example": null,
      "notes": "Either Open or O can be used as the name of this value.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.298",
          "title": "Open or O",
          "line": 4718
        }
      ],
      "sample_examples": [
        {
          "file": "samples/Sample1.rts",
          "line": 1,
          "code": "Notes:"
        },
        {
          "file": "samples/Sample2.rts",
          "line": 1,
          "code": "Notes:"
        },
        {
          "file": "samples/Sample2a.rts",
          "line": 1,
          "code": "Notes:"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "OpenSlip",
      "title": "OpenSlip",
      "aliases": [],
      "section": "17.18.299",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Slippage amount, in points (dollars per share or contract), for each transaction that simulates a market order filling at the open Input Any formula specifying dollars per share or contract (points)",
      "example": null,
      "notes": "Defines the amount of slippage to apply to each market-at-open transaction, in price points. Open Slip is applied to any transaction that logically occurs at the open and not at a specified limit or stop price.If Open Slip is not specified then Slippage is applied instead.Note that Open Slip will be applied to limit or stop orders when the fill is at the open but not at the limit or stop price, i.e., when the open gaps beyond the specified price.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.299",
          "title": "OpenSlip",
          "line": 4720
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "OptimizeSettings",
      "title": "OptimizeSettings",
      "aliases": [],
      "section": "17.18.300",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Script Sections",
      "description": "Defines the settings to use only when the script run mode is Optimize. Opt Anchor True or False whether and how to anchor multi-interval optimizations / walk-forward Opt By Strategy True or False run optimization separately for each strategy Opt By Symbol True or False run optimization separately for each symbol Opt Clear Results True or False clear the active results window before running an optimization Optimize Mode Combinatorial, Genetic, etc. type of optimization to be performed Opt Iterations number run the same optimization multiple times (e.g. for randomization) Opt Keep Best number\u2026",
      "example": null,
      "notes": "The table below lists all of the available Optimize Settings items. These correspond to the choices in the Multiple Tests and Optimization dialog box.Any optimize settings applied by a script become the new defaults for the dialog box and vice versa.The only optimize setting that is not in the dialog box is Opt No Dialog. Setting Type",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.300",
          "title": "OptimizeSettings",
          "line": 4722
        }
      ],
      "sample_examples": [
        {
          "file": "samples/spy_tlt_uis.rts",
          "line": 36,
          "code": "OptimizeSettings:"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "OrderClerkFolder",
      "title": "OrderClerkFolder",
      "aliases": [],
      "section": "17.18.301",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings or Order Settings",
      "description": "Path of the folder that Order Clerk uses for the strategies in this script.",
      "example": null,
      "notes": "This setting is required to run a script as \"Orders\" when Orders Mode is Order Clerk or Order Clerk Stats.This will be the same folder that is selected at the top of the Order Clerk main window: Real Test will use the Order Clerk Trades.csv file in that folder as the Trade List to play back before generating tomorrow's orders, and will place the new order list in this folder to be processed by Order Clerk.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.301",
          "title": "OrderClerkFolder",
          "line": 4728
        }
      ],
      "sample_examples": [
        {
          "file": "samples/mr_sample_orders.rts",
          "line": 18,
          "code": "//\tOrderClerkFolder:\tc:\\OrderClerk\\Folder1"
        },
        {
          "file": "samples/simple_day_trade.rts",
          "line": 23,
          "code": "OrderClerkFolder:\tc:\\OrderClerk\\TEST"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "OrderNote",
      "title": "OrderNote / OrderExtra",
      "aliases": [
        "OrderExtra"
      ],
      "section": "17.18.302",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "String to add to the text of each order and as the \"note\" value in a CSV Order Basket",
      "example": "of how this works in a text order list: This shows how Order Note might be used with Orders Template to allow different strategies from the same script to send their orders to different linked IB accounts: In addition to Order Note, up to nine other strategy-specific values can be added to an orders template. The strategy formula names for these are Order Extra1, Order Extra2, ... Order\u2026",
      "notes": "Here is an",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.302",
          "title": "OrderNote / OrderExtra",
          "line": 4733
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "OrderPrice",
      "title": "OrderPrice",
      "aliases": [],
      "section": "17.18.303",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Current Position Information",
      "description": "Entry order price",
      "example": null,
      "notes": "Order Price is the actual or implied price per share or contract of the entry order of this position.For a strategy with Entry Limit and/or Entry Stop this will be the limit or stop price that would have been used in an order generated by Real Test.For a market-order strategy, Order Price is the Close of the most recently completed bar when the order is made.Use Fill Price to obtain the actual entry price of the current position, which may differ from Order Price when there is a price gap between the close and next open.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.303",
          "title": "OrderPrice",
          "line": 4739
        }
      ],
      "sample_examples": [
        {
          "file": "samples/mr_sample_long_only.rts",
          "line": 24,
          "code": "EntryTradeValue:\tOrderPrice // becomes TLValueIn in the playback strategy"
        },
        {
          "file": "samples/mr_sample_short_only.rts",
          "line": 22,
          "code": "EntryTradeValue:\tOrderPrice // becomes TLValueIn in the playback strategy"
        },
        {
          "file": "samples/mr_sample_tradelist.rts",
          "line": 9,
          "code": "TLValueIn is the OrderPrice of each entry (see mr_sample_long_only.rts)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "OrderRank",
      "title": "OrderRank",
      "aliases": [],
      "section": "17.18.304",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Current Position Information",
      "description": "Returns the Top Down Mode order rank number for this position's entry across all strategies.",
      "example": null,
      "notes": "The top-down order ranking mechanism can be observed in detail by running a test with both Keep Trades: Skipped and Test Output: Log enabled.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.304",
          "title": "OrderRank",
          "line": 4741
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "OrdersComment",
      "title": "OrdersComment",
      "aliases": [],
      "section": "17.18.305",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "An optional string to add to the top of the order list when orders are generated.",
      "example": null,
      "notes": "The Orders Comment setting is interpreted as a formula. Use the Format function to build a string that displays whatever information from your script variables that would be useful to see in an order list.Note that formula output strings are limited to 80 characters in length.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.305",
          "title": "OrdersComment",
          "line": 4746
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "OrderSettings",
      "title": "OrderSettings",
      "aliases": [],
      "section": "17.18.306",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Script Sections",
      "description": "Defines the settings to use only when the script run mode is Orders.",
      "example": null,
      "notes": "The general-purpose Settings section is always applied first, then modified by any items specified in Order Settings when applicable.See Settings Sections for details.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.306",
          "title": "OrderSettings",
          "line": 4748
        }
      ],
      "sample_examples": [
        {
          "file": "samples/mr_sample_orders.rts",
          "line": 7,
          "code": "OrderSettings:"
        },
        {
          "file": "samples/mr_sample_orders_alera.rts",
          "line": 17,
          "code": "OrderSettings:\t// additional settings applied when script is run in \"Orders\" mode"
        },
        {
          "file": "samples/mr_sample_orders_basket.rts",
          "line": 17,
          "code": "OrderSettings:\t// additional settings applied when script is run in \"Orders\" mode"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "OrdersFile",
      "title": "OrdersFile",
      "aliases": [],
      "section": "17.18.307",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings or Order Settings or Strategy Elements",
      "description": "Path and name of the order list file to create when generating orders.",
      "example": null,
      "notes": "If Orders File is not specified then the default path is c:\\Real Test\\Output\\Orders (assuming Real Test is installed in c:\\Real Test) and the default file is script_date_orders.txt (where script is the current script name and date is the order date).When Orders Mode is anything other than the default Text mode, two orders file are created: script_date_orders.txt and script_date_orders.csv.When Orders File is specified, the file name should end in .txt for the default Orders Mode or in .csv in any other mode. A settings-level Orders File path will override the default and will apply to every\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.307",
          "title": "OrdersFile",
          "line": 4750
        }
      ],
      "sample_examples": [
        {
          "file": "samples/mr_sample_orders_alera.rts",
          "line": 18,
          "code": "OrdersMode:\tAlera // each strategy must specify its own OrdersFile"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "OrdersFreeCash",
      "title": "OrdersFreeCash",
      "aliases": [],
      "section": "17.18.308",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings or Order Settings or Strategy Elements",
      "description": "Path and name of a text file that contains the current Free Cash Value (cash available to invest or withdraw) of your brokerage account",
      "example": null,
      "notes": "This setting can be used to ensure that orders are generated using the correct Min Free Cash constraint for your actual account.",
      "see_also": [
        "Orders Net Liq."
      ],
      "manual_refs": [
        {
          "section": "17.18.308",
          "title": "OrdersFreeCash",
          "line": 4755
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "OrdersInclude",
      "title": "OrdersInclude",
      "aliases": [],
      "section": "17.18.309",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Script Sections",
      "description": "Allows a script to include another script when run in Orders Mode",
      "example": null,
      "notes": "See the general-purpose Include statement for further details.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.309",
          "title": "OrdersInclude",
          "line": 4757
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "OrdersLiveData",
      "title": "OrdersLiveData",
      "aliases": [],
      "section": "17.18.310",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings or Order Settings",
      "description": "Allows generation of intraday market orders when running in Orders mode Choices True - generate today's live market orders False - (default) generate tomorrow's orders as usual",
      "example": null,
      "notes": "This is an advanced option provided for users who have found a way to import live \"daily bars so far\" just before the market close and wish to generate market orders for strategies that use This Close as their Entry Time and/or Exit Time.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.310",
          "title": "OrdersLiveData",
          "line": 4759
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "OrdersMktAsLmtPct",
      "title": "OrdersMktAsLmtPct",
      "aliases": [],
      "section": "17.18.311",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings or Order Settings or Strategy Elements",
      "description": "Allows generated market orders to optionally be converted to limit orders X% beyond the last close.Value A number expressing the desired percentage, e.g. 3 for 3%, or 0 if no conversion is desired",
      "example": ", if 10 is the specificed percentage, then a long entry (buy) order would use Close * 1.1 as its limit price, and a long exit (sell) order would use Close * 0.9 as its limit price. The idea is to allow plenty of extra room to ensure a fill while still using a limit order.To selectively apply this option, e.g. in a strategy that trades on multiple exchanges, use a formula such as:Orders Mkt As Lmt\u2026",
      "notes": "The purpose of this strategy option is to allow what is logically a market-order to be executed as a marketable limit order. This option provided to support order generation for exchanges that do not permit market orders, without having to convert the strategy to one that always uses limit orders.Market orders are typically generated in the following situations:\u00b7 entry orders when Entry Time is Next Open (or omitted) and neither Entry Limit nor Entry Stop is specified\u00b7 exit orders when Exit Rule is true and Exit Time is Next Open (or omitted)\u00b7 exit orders when Exit Limit touches the last\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.311",
          "title": "OrdersMktAsLmtPct",
          "line": 4764
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "OrdersMode",
      "title": "OrdersMode",
      "aliases": [],
      "section": "17.18.312",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings or Order Settings",
      "description": "Specifies which format to use when generating Tomorrow's Orders Choices Text - (default) only generate human-readable text orders Order Clerk - run the backtest in Hybrid Trade List mode using the Order Clerk Trades.csv in the specified Order Clerk Folder to play back past live trades, then generate an Order Clerk-compatible CSV order list in the same Order Clerk Folder.Order Clerk Sync - identical to Order Clerk mode unless there was a gap in time between the last trade in that mode and the end of available data, i.e., one or more recent days when orders were not generated. In that case\u2026",
      "example": null,
      "notes": "See Generated Order Types for details about how Real Test maps strategy rules to generated orders.To generate any kind of orders other than Text, Orders Mode must always be specified in Settings or Order Settings.Orders are only generated when a script is run by pressing the Orders button (not the Test button).Text orders are also generated for every other mode unless Always show text orders is unchecked in View / Program Options",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.312",
          "title": "OrdersMode",
          "line": 4766
        }
      ],
      "sample_examples": [
        {
          "file": "samples/mr_sample_orders.rts",
          "line": 13,
          "code": "//\tOrdersMode:\tTemplate"
        },
        {
          "file": "samples/mr_sample_orders_alera.rts",
          "line": 18,
          "code": "OrdersMode:\tAlera // each strategy must specify its own OrdersFile"
        },
        {
          "file": "samples/mr_sample_orders_basket.rts",
          "line": 18,
          "code": "OrdersMode:\tTemplate"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "OrdersNetLiq",
      "title": "OrdersNetLiq",
      "aliases": [],
      "section": "17.18.313",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings or Order Settings or Strategy Elements",
      "description": "Path and name of a text file that contains the current Net Liquidation Value (mark to market account balance) of your brokerage account",
      "example": null,
      "notes": "This setting can be used to ensure that orders are generated with the correct Quantity (position size) for your current account value.If you have a way to automatically recreate this one-line text file each day, or a habit of doing so manually, this is the simplest way to get your order sizes right.The value found in the file becomes the value of S.Alloc for the purpose of order generation.To clarify how this works, imagine that daily order generation for live trading began at the start of this year with an account balance of $100K.Your Settings might look like this:Settings: Account Size\u2026",
      "see_also": [
        "Orders Free Cash."
      ],
      "manual_refs": [
        {
          "section": "17.18.313",
          "title": "OrdersNetLiq",
          "line": 4771
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "OrdersTemplate",
      "title": "OrdersTemplate",
      "aliases": [],
      "section": "17.18.314",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings or Order Settings or Strategy Elements",
      "description": "Path and name of the CSV order list template file to use for generating this test's order basket",
      "example": null,
      "notes": "An Orders Template path must be specified when Orders Mode: Template is used and can optionally be specified for Orders Mode: Order Clerk.A settings-level Orders Template path will apply to every strategy in the script that does not provide its own path.A strategy-level Orders Template path will apply only to the strategy that specifies it.See Orders File and CSV Order Baskets for details about CSV order lists.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.314",
          "title": "OrdersTemplate",
          "line": 4780
        }
      ],
      "sample_examples": [
        {
          "file": "samples/mr_sample_orders.rts",
          "line": 14,
          "code": "//\tOrdersTemplate:\t?scriptpath?\\ib_basket_template.csv"
        },
        {
          "file": "samples/mr_sample_orders_basket.rts",
          "line": 19,
          "code": "OrdersTemplate:\t?scriptpath?\\ib_basket_template.csv"
        },
        {
          "file": "samples/simple_day_trade_basket_orders.rts",
          "line": 10,
          "code": "OrdersTemplate:\t?scriptpath?\\ib_basket_template.csv"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "OrderSum",
      "title": "OrderSum",
      "aliases": [],
      "section": "17.18.316",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Evaluates an expression for each non-skipped setup and returns the sum of the values",
      "example": null,
      "notes": "This is a specialized function meant to be used in entry-related formulas that want to the sum of something across all current non-skipped setups (stocks for which an entry order will be placed).Order Sum(1) can be used to count today's orders for the current strategy.Use Setup Sum to count or calculate something for all setups, not just the non-skipped ones.Note that Order Sum cannot be used to refer to past setups in a strategy. It only has access to setups for the current date in the test. Therefore Order Sum(expression)[offset] will probably not have meaningful results.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.316",
          "title": "OrderSum",
          "line": 4786
        }
      ],
      "sample_examples": [
        {
          "file": "samples/multi_moc_top_down.rts",
          "line": 80,
          "code": "StrategyScore:\t-OrderSum(1)\t// fewest new orders so far today"
        },
        {
          "file": "samples/optimal_diversity.rts",
          "line": 40,
          "code": "SetupScore:\tSelect(OrderSum(1) = 0 and PositionSum(1) = 0, score1, -CorrelAvg(IsOrder or Shares > 0, roc1, bars))"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "OrdersUseQtyIn",
      "title": "OrdersUseQtyIn",
      "aliases": [],
      "section": "17.18.315",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings or Order Settings",
      "description": "Forces generated exit order quantities to match the position's entry quantity Choices True - change exit quantity to match entry quantity if needed (ignore any splits between them) False - (default) adjust exit quantity for any splits that happened since entry",
      "example": null,
      "notes": "This is an advanced option provided for users who want to use Adjustment: Total Return data in their strategies.Total-return adjustment literally means convert dividends to splits. Once data is imported that way, dividends become indistinguishable from normal stock splits (which are more rare).A normal stock split changes the number of shares held in any open positions on the ex-split date. Real Test by default accounts for this fact when it generates exit orders (also in the trade lists of backtests).It is generally recommended to avoid using total-return adjustment for any live strategies\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.315",
          "title": "OrdersUseQtyIn",
          "line": 4784
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "PadAlignSym",
      "title": "PadAlignSym",
      "aliases": [],
      "section": "17.18.317",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Import Specification",
      "description": "Symbol to use for Padding: Align With Symbol",
      "example": null,
      "notes": "The Align With Symbol Padding choice forces all imported stocks to have the same set of bar dates as the Pad Align Sym stock by adding missing bars and removing extra bars.This alignment is performed only within the existing date range of each stock. Extra bars are not added before the start or after the end of its data.Since this setting is always simply one symbol, it should not be preceded by a $ as is normally done to reference a symbol within a formula.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.317",
          "title": "PadAlignSym",
          "line": 4788
        }
      ],
      "sample_examples": [
        {
          "file": "samples/namespace_example.rts",
          "line": 11,
          "code": "PadAlignSym:\tSPY"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Padding",
      "title": "Padding",
      "aliases": [],
      "section": "17.18.318",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Import Specification",
      "description": "Import data padding type",
      "example": null,
      "notes": "When Norgate is the data source, padding of any of the above types is provided by Norgate.For other data sources, Real Test does the padding in the same way that Norgate does.When data is imported for multiple markets that have different holiday schedules, \"All Market Days\" means any day where any of the included markets is open.",
      "see_also": [
        "the general topic of Calendar Alignment."
      ],
      "manual_refs": [
        {
          "section": "17.18.318",
          "title": "Padding",
          "line": 4792
        }
      ],
      "sample_examples": [
        {
          "file": "samples/dividend_yield_series.rts",
          "line": 4,
          "code": "assumes holidays and weekends are not added as padding bars"
        },
        {
          "file": "samples/import_norgate.rts",
          "line": 13,
          "code": "Padding:\tNone\t// rare to need padding, but available if you want it"
        },
        {
          "file": "samples/namespace_example.rts",
          "line": 10,
          "code": "Padding:\tAlignWithSymbol"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Parameters",
      "title": "Parameters",
      "aliases": [],
      "section": "17.18.319",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Script Sections",
      "description": "Optimization Parameter Definitions",
      "example": null,
      "notes": "See",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.319",
          "title": "Parameters",
          "line": 4794
        }
      ],
      "sample_examples": [
        {
          "file": "samples/Sample2.rts",
          "line": 11,
          "code": "Parameters:"
        },
        {
          "file": "samples/Sample2a.rts",
          "line": 11,
          "code": "Parameters:"
        },
        {
          "file": "samples/anchored_vwap.rts",
          "line": 18,
          "code": "Parameters:"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "PDI",
      "title": "PDI",
      "aliases": [],
      "section": "17.18.320",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Indicator Functions",
      "description": "Wilder's Plus Directional Index",
      "example": null,
      "notes": "This is the positive component of the ADX indicator, often referred to as +DI.This indicator supports one-pass calculation when used in the Data Section with a non-variable length.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.320",
          "title": "PDI",
          "line": 4799
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Peak",
      "title": "Peak",
      "aliases": [],
      "section": "17.18.321",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Value of the nth most recent peak of a series of prices or other values",
      "example": null,
      "notes": "The definition of a Peak is the highest value which is then followed by one or more values that are at least n% below that most recent high.Most technical analysis software (which is designed primarily for charting purposes) attaches Peak and Trough values to the bars on which they occur. Real Test (being designed for realistic backtesting) does not commit this look-ahead error. Instead, the most recent peak is only returned starting with the subsequent bar that completes the n% drop following that peak. This makes it completely safe and legitimate to use these functions in backtesting.The\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.321",
          "title": "Peak",
          "line": 4801
        }
      ],
      "sample_examples": [
        {
          "file": "samples/anchored_vwap.rts",
          "line": 23,
          "code": "pivotPrice:\tTrough(price, trPct) // and/or use Peak"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "PeakBars",
      "title": "PeakBars",
      "aliases": [],
      "section": "17.18.322",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Count of bars since the nth most recent peak of a series of prices or other values",
      "example": null,
      "notes": "The definition of a Peak is the highest value which is then followed by one or more values that are at least n% below that most recent high.See Peak for important additional information about how these functions work in Real Test.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.322",
          "title": "PeakBars",
          "line": 4806
        }
      ],
      "sample_examples": [
        {
          "file": "samples/anchored_vwap.rts",
          "line": 24,
          "code": "pivotBars:\tTroughBars(price, trPct) // and PeakBars"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "PercentRank",
      "title": "PercentRank",
      "aliases": [],
      "section": "17.18.323",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Percent rank among values",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.323",
          "title": "PercentRank",
          "line": 4808
        }
      ],
      "sample_examples": [
        {
          "file": "samples/clenow_stocks_on_move.rts",
          "line": 37,
          "code": "Percentile:\t#PercentRank 100 * CanRank + AdjSlope"
        },
        {
          "file": "samples/clenow_stocks_on_move_dynamic.rts",
          "line": 37,
          "code": "Percentile:\t#PercentRank 100 * CanRank + AdjSlope"
        },
        {
          "file": "samples/ibd_rs.rts",
          "line": 15,
          "code": "pctrnk:\t#PercentRank strength // \"inclusive\" (0-100) percent rank of strength"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "PercentRankN",
      "title": "PercentRankN",
      "aliases": [],
      "section": "17.18.324",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Value with a specific percent rank (the Nth percentile value)",
      "example": null,
      "notes": "Performs the Percen Rank function and then returns the value with the requested percentile.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.324",
          "title": "PercentRankN",
          "line": 4813
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "PointValue",
      "title": "PointValue",
      "aliases": [],
      "section": "17.18.325",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Stock/Contract Information",
      "description": "Futures contract point value",
      "example": null,
      "notes": "Specifies the notional value of a 1-point change in price for a futures contract. This is also known as the \"multiple\".Point values are obtained automatically when importing futures data from Norgate.For CSV futures data import, it would be necessary to provide point values for each contract using a Sym Info file.Point Value is assumed to always be $1.00 for stocks.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.325",
          "title": "PointValue",
          "line": 4815
        }
      ],
      "sample_examples": [
        {
          "file": "samples/futures_trend_follow_csi.rts",
          "line": 26,
          "code": "NDlr:\tN * PointValue"
        },
        {
          "file": "samples/futures_trend_follow_simple.rts",
          "line": 19,
          "code": "NDlr:\tN * PointValue"
        },
        {
          "file": "samples/futures_volume_rank.rts",
          "line": 16,
          "code": "DlrAtr: ATR(5) * PointValue"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "PositionSum",
      "title": "PositionSum",
      "aliases": [],
      "section": "17.18.329",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Evaluates an expression for each currently open position and returns the sum of the values",
      "example": ", in most use cases it is not necessary to deliberately calculate how many position slots will be available after tomorrow's exits. Real Test handles this automatically in both backtests and automatic order generation. In these more typical scenarios, S.Positions, Position Sum(1), and Position Sum(Not(my_rule)) will all return the same value.Another possible use of Position Sum would be to\u2026",
      "notes": "This is a specialized function meant to be used in entry-related formulas that need to know how many positions are open or will still be open after tomorrow's exits.Referring to Position Sum(1) is equivalent to referring to S.Positions in that context.Assuming a strategy uses Exit Rule: my_rule where my_rule is an exit condition formula, and does exits at the next open (the default), Position Sum(Not(my_rule)) can be used to count the number of positions that will be open after tomorrow morning's exits but before any new entries. This kind of logic may be necessary when using a Test Scan to\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.329",
          "title": "PositionSum",
          "line": 4828
        }
      ],
      "sample_examples": [
        {
          "file": "samples/dalio_all_weather_maxdiff.rts",
          "line": 29,
          "code": "Rebalance:\tPositionSum(Diff > maxDiff) > 0"
        },
        {
          "file": "samples/hybrid_asset_allocation_dynamic.rts",
          "line": 41,
          "code": "curr_size:\tPositionSum(Shares, symbol)"
        },
        {
          "file": "samples/optimal_diversity.rts",
          "line": 40,
          "code": "SetupScore:\tSelect(OrderSum(1) = 0 and PositionSum(1) = 0, score1, -CorrelAvg(IsOrder or Shares > 0, roc1, bars))"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "PrevExitLimit",
      "title": "PrevExitLimit",
      "aliases": [],
      "section": "17.18.326",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Current Position Information",
      "description": "Previous exit limit (target) price",
      "example": null,
      "notes": "At position entry time, Prev Exit Limit is set to 0. On each bar that the position is open, after the Exit Limit formula is calculated, its value is placed in Prev Exit Limit. This makes it possible to implement a \"trailing target\", or any type of price target concept that needs to refer to its own prior value to be calculated. (Previously this required using the Data Section and was therefore more complex.) It is also possible for a strategy to refer to the current exit limit price of another strategy by using Extern(@other, Prev Exit Limit).",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.326",
          "title": "PrevExitLimit",
          "line": 4820
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "PrevExitStop",
      "title": "PrevExitStop",
      "aliases": [],
      "section": "17.18.327",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Current Position Information",
      "description": "Previous exit stop price",
      "example": null,
      "notes": "At position entry time, Prev Exit Stop is set to 0. On each bar that the position is open, after the Exit Stop formula is calculated, its value is placed in Prev Exit Stop. This makes it possible to implement a \"trailing stop\", or any type of price stop concept that needs to refer to its own prior value to be calculated. (Previously this required using the Data Section and was therefore more complex.) It is also possible for a strategy to refer to the current exit stop price of another strategy by using Extern(@other, Prev Exit Stop).Examples This is a very simple trend-following strategy\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.327",
          "title": "PrevExitStop",
          "line": 4822
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "PriceRound",
      "title": "PriceRound",
      "aliases": [],
      "section": "17.18.330",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Specifies how to round trade prices in backtests and order lists Input Any formula specifying a rounding interval (step value)",
      "example": null,
      "notes": "If not specified, the default rounding interval is the Tick Size of the symbol.Price Round: 0.01 means round to the nearest penny (which is also the default Tick Size if not known) Price Round: 0 means don't do any rounding (include all available decimal places).Price Round: if(C < 1, 0.0001, 0.01) means round to nearest penny for stocks above $1/share or nearest hundredth of a penny for penny stocks Prices are rounded before being used to calculate trade profits/losses, which makes those figures more realistic.Since Real Test always uses split-unadjusted (as-traded) prices in formulas, we do\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.330",
          "title": "PriceRound",
          "line": 4833
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Product",
      "title": "Product",
      "aliases": [],
      "section": "17.18.328",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Product of values",
      "example": null,
      "notes": "Evaluates expr for each of count bars and returns the product of the values.This function supports one-pass calculation when used in the Data Section with a non-variable count.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.328",
          "title": "Product",
          "line": 4826
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "QtyFinal",
      "title": "QtyFinal",
      "aliases": [],
      "section": "17.18.331",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Can be used to modify entry position sizes after top-down setup selection has been completed",
      "example": "use case might be: This sets the initial position sizes to 10%.After selecting today's setups while applying the Max Exposure constraint, positions are resized to use all remaining capital divided equally among the new orders to be placed (S.Entry Orders).(Arbitrarily growing position sizes to use available exposure may increase position-specific risk and is probably not advisable, but if you\u2026",
      "notes": "The initial desired Quantity of each setup must be specified prior to application of constraints such as Max Exposure or Max Invested.The final count of setups that can become orders is therefore not known yet when initial quantities are set.Qty Final is provided for cases where you want position sizes to be influenced by the number of orders that will be placed after constraints have been applied.An",
      "see_also": [
        ": Backtest Engine Details and Capacity Constraints"
      ],
      "manual_refs": [
        {
          "section": "17.18.331",
          "title": "QtyFinal",
          "line": 4835
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "QtyPrice",
      "title": "QtyPrice",
      "aliases": [],
      "section": "17.18.332",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Specifies which price to use when calculating Quantity (Percent or Value types), trade fraction, and exposure Choices Order Price - use the order price (default) Fill Price - use the entry price",
      "example": null,
      "notes": "This new strategy-level setting replaces and augments the former Percent Order and Value Order selections for Qty Type.The Qty Price setting has several implications:\u00b7 which price to use when calculating Quantity for types other than shares\u00b7 how to interpret Fill Price on the day a position is entered, e.g. when used in Exit Limit or Exit Stop\u00b7 which price to use when calculating T.Fraction \u00b7 which fraction value to therefore use when checking Max Exposure and calculating S.Exposure and S.Usage In most cases the best practice will be to accept the default for this setting.Using Qty Price: Fil\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.332",
          "title": "QtyPrice",
          "line": 4840
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "QtyRound",
      "title": "QtyRound",
      "aliases": [],
      "section": "17.18.333",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Specifies how to round the result of the Quantity formula Input Any formula specifying a rounding interval (step value)",
      "example": null,
      "notes": "If not specified, the default rounding interval is 1 (whole shares).Qty Round: 0 means don't do any rounding (include all available decimal places).Qty Round: 10 means round to the next lower ten-share interval.Qty Round: 0.1 means round to the next lower tenth-of-a-share interval.When rounded, Quantity is always rounded down (truncated), e.g. 12.99 will be rounded to 12 if Qty Round: 1 is in use.Quantity is rounded down by default to avoid the possibility of share rounding pushing a position value slightly over the Max Invested threshold.If you want to round up, or round nearest, specify Qty\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.333",
          "title": "QtyRound",
          "line": 4844
        }
      ],
      "sample_examples": [
        {
          "file": "samples/mhp_classic.rts",
          "line": 35,
          "code": "QtyRound:\t100"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "QtyType",
      "title": "QtyType",
      "aliases": [],
      "section": "17.18.334",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Specifies how to interpret the Quantity formula Choices Shares - Quantity represents the number of shares or contracts (default if not specified) Value - Quantity represents the notional value of the position (e.g. dollars) based on entry fill price Percent - Quantity represents a percentage of current allocation (S.Alloc)",
      "example": null,
      "notes": "During setup selection, Quantity is calculated and constraints (such as Max Invested) are applied based on the Order Price of the Entry Setup. To \"look ahead\" to the actual entry price when calculating position sizes, specify Qty Price: Fill Price. The following are all equal position sizes:",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.334",
          "title": "QtyType",
          "line": 4846
        }
      ],
      "sample_examples": [
        {
          "file": "samples/bensdorp_book.rts",
          "line": 89,
          "code": "QtyType:\tShares"
        },
        {
          "file": "samples/cii_rotate.rts",
          "line": 60,
          "code": "QtyType:\tPercent"
        },
        {
          "file": "samples/combined.rts",
          "line": 32,
          "code": "QtyType:\tPercent"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Quantity",
      "title": "Quantity",
      "aliases": [],
      "section": "17.18.335",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Specifies the number of shares or contracts to buy or sell short when opening a new position Input Any formula specifying a number of shares or contracts, or a position value, or an allocation percentage",
      "example": null,
      "notes": "The Quantity formula specifies the position size to use each trade in a strategy. Quantity is calculated at setup selection time using the same current bar context as Entry Setup. If there is no Quantity formula then a strategy will always invest 100% of current Allocation in each position.If Quantity returns 0 then the entry is skipped and \"zero quantity\" is displayed as the skip reason.Quantity can optionally be used to specify the Side (long vs. short) of a trade in a strategy that can go either way, such as a hedging strategy.If Side is specified for a strategy, then the strategy always\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.335",
          "title": "Quantity",
          "line": 4850
        }
      ],
      "sample_examples": [
        {
          "file": "samples/bensdorp_book.rts",
          "line": 99,
          "code": "Quantity:\tlfrac * Min(S.Alloc/10/C, (S.Alloc*0.02)/(5*atr20))"
        },
        {
          "file": "samples/cii_rotate.rts",
          "line": 59,
          "code": "Quantity:\t100/15"
        },
        {
          "file": "samples/clenow_stocks_on_move.rts",
          "line": 63,
          "code": "Quantity:\tnewqty - curqty"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Random",
      "title": "Random",
      "aliases": [],
      "section": "17.18.336",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Returns a uniformly distributed random number",
      "example": null,
      "notes": "If called with no",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.336",
          "title": "Random",
          "line": 4852
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "RandomSeed",
      "title": "RandomSeed",
      "aliases": [],
      "section": "17.18.337",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "Permits use of the same sequence of pseudo-random numbers every time a script is run",
      "example": null,
      "notes": "Pseudo-random numbers can be used explicitly by scripts via the Random function and are used implicitly in Optimization (some modes) and Monte-Carlo analysis.If Random Seed is not specfied or is 0 then random numbers are different every time Real Test runs and are selected from a much larger set of possible values (the C runtime library function rand_s is used).When Random Seed is specified, the provided value is passed to the C srand function and the rand function is then used for each random value needed.It is recommended to not specify a Random Seed unless you have a particular need for\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.337",
          "title": "RandomSeed",
          "line": 4857
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Range",
      "title": "Range or R",
      "aliases": [
        "R"
      ],
      "section": "17.18.338",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Bar Data Values",
      "description": "Current bar intraday range",
      "example": null,
      "notes": "This is simply H-L of a bar. Either Range or R can be used.",
      "see_also": [
        "True Range."
      ],
      "manual_refs": [
        {
          "section": "17.18.338",
          "title": "Range or R",
          "line": 4859
        }
      ],
      "sample_examples": [
        {
          "file": "samples/Sample1.rts",
          "line": 2,
          "code": "Simplest Example -- 50/200 crossover on SPY"
        },
        {
          "file": "samples/Sample2.rts",
          "line": 2,
          "code": "2-Parameter optimization example"
        },
        {
          "file": "samples/Sample2a.rts",
          "line": 2,
          "code": "2-Parameter optimization example"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "Rank",
      "title": "Rank",
      "aliases": [],
      "section": "17.18.339",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Numeric rank among values",
      "example": null,
      "notes": null,
      "see_also": [
        "Percent Rank."
      ],
      "manual_refs": [
        {
          "section": "17.18.339",
          "title": "Rank",
          "line": 4863
        }
      ],
      "sample_examples": [
        {
          "file": "samples/cii_rotate.rts",
          "line": 2,
          "code": "demonstrates multi-level ranking using the Norgate Corresponding Industry Index data"
        },
        {
          "file": "samples/cl_term_structure.rts",
          "line": 15,
          "code": "AgeRank:\t#Rank if(InList(1), -DaysToExp, nan)"
        },
        {
          "file": "samples/clenow_stocks_on_move.rts",
          "line": 36,
          "code": "CanRank:\tInSPX and C > MA(C,100) and CountTrue(ABS(ROC(C,1))>=15, 90) == 0"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "RankN",
      "title": "RankN",
      "aliases": [],
      "section": "17.18.340",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Value with a specific numeric rank",
      "example": null,
      "notes": "Performs the Rank function and then returns the value with the requested rank.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.340",
          "title": "RankN",
          "line": 4865
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Reason",
      "title": "Reason",
      "aliases": [],
      "section": "17.18.341",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Returns both a value and a string of the condition that triggered the exit in its T.Reason field.This capability was previously supported only in Exit Rule by using Select. That worked implicitly because Exit Rule is a true/false condition. If the formula returned any string value, that was interpreted as \"true\".In contrast, Exit Limit and Exit Stop need to return a specific price, so a function that can return both a value and a string was required to enable reason strings.",
      "example": "Exit Stop: if(Extern($SPY, C > MA(C, 100)), Reason(Fill Price * 0.6, \"bull market stop\"), Reason(Fill Price * 0.9, \"bear market stop\"))",
      "notes": "This special-purpose function serves to allow a single Exit Limit or Exit Stop formula to return different prices under different conditions and cause the resulting trade record to include a",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.341",
          "title": "Reason",
          "line": 4867
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Reduce",
      "title": "Reduce",
      "aliases": [],
      "section": "17.18.342",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Specifies whether to reduce quantity when a new position's size would push total investment above a capacity constraint Input0 or false - don't reduce (default)value or true - reduce to available capacity (but not less than this dollar size value) if necessary",
      "example": null,
      "notes": "If a non-zero value is specified, a new position that would exceed a capacity constraint is reduced to the size of the remaining available capacity, provided it is not less than the dollar value specified. Otherwise the entry is skipped.When \"true\" is specified, this is internally represented as 1, so the minimum position size is $1.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.342",
          "title": "Reduce",
          "line": 4872
        }
      ],
      "sample_examples": [
        {
          "file": "samples/clenow_stocks_on_move.rts",
          "line": 61,
          "code": "Reduce:\tTrue"
        },
        {
          "file": "samples/clenow_stocks_on_move_dynamic.rts",
          "line": 60,
          "code": "Reduce:\tTrue"
        },
        {
          "file": "samples/higher_lows.rts",
          "line": 45,
          "code": "Reduce:\tTrue"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "RemoveLatest",
      "title": "RemoveLatest",
      "aliases": [],
      "section": "17.18.343",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Import Specification",
      "description": "Whether to remove the global latest bar from any symbol that has it Choices False - don't remove the latest bar (default) True - remove the latest bar",
      "example": null,
      "notes": "When this import setting is true, the latest bar is removed from any symbol that had the global latest (latest latest) bar.No bars are removed from symbols that do not have the global latest bar.This option can be used either to remove the latest bar from all symbols when they all have the same latest bar, or to equalize the latest bar when some symbols have an extra bar (e.g. in a mixed US and ASX import done between the ASX and US closes).",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.343",
          "title": "RemoveLatest",
          "line": 4874
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Replace",
      "title": "Replace",
      "aliases": [],
      "section": "17.18.344",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "String Functions",
      "description": "Replace all instances of a string within another string",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.344",
          "title": "Replace",
          "line": 4879
        }
      ],
      "sample_examples": [
        {
          "file": "samples/simple_day_trade_basket_scan.rts",
          "line": 24,
          "code": "Sym:\t{\"Symbol\" !1} Replace(?Symbol, \".\", \" \")"
        },
        {
          "file": "samples/supertrend.rts",
          "line": 6,
          "code": "the \"trend\" data item uses self reference to replace loop code"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "ReportContent",
      "title": "ReportContent",
      "aliases": [],
      "section": "17.18.345",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "Specifies which optional sections to include when a Test Summary Report is generated Choices (multiple, separated by commas) Settings - include the test settings and parameter list Stats - include the test summary stats Monthly - include the monthly returns table Correl - include the strategy correlation matrix Graphs - include the stats graphs Plots - include trade scatter and Monte Carlo plots Script - include the script used to run the test",
      "example": null,
      "notes": "When Report Content is specified by a script, the choices persist until changed later, either by script or in the Report Options Dialog.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.345",
          "title": "ReportContent",
          "line": 4881
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "ReportsFolder",
      "title": "ReportsFolder",
      "aliases": [],
      "section": "17.18.346",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings or Test Settings",
      "description": "Path of the folder in which Test Summary Reports are created.",
      "example": null,
      "notes": "The default Reports Folder is (Real Test Installation Folder)\\Output\\Reports.If Output has been changed under Default Folder Paths in Program Options then the default is Reports in that folder.Each new report is created in a separate sub-folder of the Reports folder.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.346",
          "title": "ReportsFolder",
          "line": 4883
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Rescale",
      "title": "Rescale",
      "aliases": [],
      "section": "17.18.347",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Maps a value from one scale to another",
      "example": "Normalized Turnover: Rescale(Close * Volume, 1e5, 1e12, 1, 10, 1)",
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.347",
          "title": "Rescale",
          "line": 4888
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Results",
      "title": "Results",
      "aliases": [],
      "section": "17.18.348",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Script Sections",
      "description": "Results column definitions",
      "example": null,
      "notes": "See Results Section and Results Windows.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.348",
          "title": "Results",
          "line": 4890
        }
      ],
      "sample_examples": [
        {
          "file": "samples/breadth.rts",
          "line": 4,
          "code": "Results shown via scan output and/or chart"
        },
        {
          "file": "samples/clenow_stocks_on_move.rts",
          "line": 5,
          "code": "(these two examples produce slightly different results due to the implementation details)"
        },
        {
          "file": "samples/clenow_stocks_on_move_dynamic.rts",
          "line": 5,
          "code": "(these two examples produce slightly different results due to the implementation details)"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "ResultsFile",
      "title": "ResultsFile",
      "aliases": [],
      "section": "17.18.349",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "Path and name of a results file (RTR) to open or create before a test is run, and save at the end of the run",
      "example": null,
      "notes": "By default when a test is run, Real Test uses the most recently opened results window, or creates a new untitled one for the purpose.This setting allows you to choose a specific RTR file to use when running tests with this script.Unlike some Scan and Test Settings, there is no Settings Panel equivalent for this particular option and the setting does not persist. See File Path Specification for helpful tips including special path expansion variables.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.349",
          "title": "ResultsFile",
          "line": 4892
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Right",
      "title": "Right",
      "aliases": [],
      "section": "17.18.350",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "String Functions",
      "description": "Return the right end of a string",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.350",
          "title": "Right",
          "line": 4896
        }
      ],
      "sample_examples": [
        {
          "file": "samples/djia_earnings.rts",
          "line": 5,
          "code": "rightmost bar will always be the ex-earnings date"
        },
        {
          "file": "samples/mr_sample.rts",
          "line": 7,
          "code": "Include: ?scriptpath?\\mr_sample_common.rts // right-click on file name to open"
        },
        {
          "file": "samples/mr_sample_benchmark.rts",
          "line": 3,
          "code": "Include:\t?scriptpath?\\mr_sample.rts // right-click to open"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "RiskFreeRateSym",
      "title": "RiskFreeRateSym",
      "aliases": [],
      "section": "17.18.351",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "Symbol of an imported data series to store in the test statistics for later use when calculating Sharpe or other stats that require this.",
      "example": null,
      "notes": "The daily closing values of this data series are stored in S.Risk Free Rate when a test is run.This in turn is used in the calculation of Sharpe Ratio in the default Results.rts formula: For this to work correctly the data must be a rate series, e.g. close=5 means 5%, as in the Norgate symbols %FFYE or %3MTCM.Do not prefix the symbol with $ -- that is only required for symbol references within formulas.The referenced symbol must also have been added to the Import of the current data file.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.351",
          "title": "RiskFreeRateSym",
          "line": 4898
        }
      ],
      "sample_examples": [
        {
          "file": "samples/radge_bbo.rts",
          "line": 20,
          "code": "RiskFreeRateSym:    %AUCRT"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "ROC",
      "title": "ROC or PctChg",
      "aliases": [
        "PctChg"
      ],
      "section": "17.18.352",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "%gain/loss",
      "example": null,
      "notes": "Either ROC or Pct Chg can be used as the name of this function.Return value is equivalent to 100 * (expr / expr[count] - 1).",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.352",
          "title": "ROC or PctChg",
          "line": 4903
        }
      ],
      "sample_examples": [
        {
          "file": "samples/beta_indicator.rts",
          "line": 16,
          "code": "roc1:\troc(c,1)"
        },
        {
          "file": "samples/bottomup/beta_indicator.rts",
          "line": 16,
          "code": "roc1:\troc(c,1)"
        },
        {
          "file": "samples/cii_rotate.rts",
          "line": 24,
          "code": "ROC30:\tROC(C,30) // a ranking factor (experiment with others!)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "RollCost",
      "title": "RollCost",
      "aliases": [],
      "section": "17.18.353",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Total cost of each roll transaction while holding a futures position.Input Formula specifying a dollar amount.",
      "example": "If your Commission is $1.50 per contract and your Slippage averages one tick, then your formula would be:Roll Cost: 2 * Contracts * (1.5 + (1 * Tick Size * Point Value))",
      "notes": "Roll Cost is only applied to trades in a strategy that uses CSI Futures back-adjusted data.Each time an open position is held across a roll date boundary, the Roll Cost formula is evaluated. The dollar amount that it returns is added to the running total of roll costs for this position.When the trade exits, this total is subtracted from its net profit calculation (similarly to commissions).To see the total roll costs for a trade, add a column to your Trades.rts that shows T.Roll Costs.To see the total daily roll costs for all trades exited that day, add an item to your Graphs.rts that shows\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.353",
          "title": "RollCost",
          "line": 4905
        }
      ],
      "sample_examples": [
        {
          "file": "samples/futures_trend_follow_csi.rts",
          "line": 40,
          "code": "RollCost:\t4 * Contracts + 4 * TickSize * PointValue // commission and slippage for each full roll"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Round",
      "title": "Round",
      "aliases": [],
      "section": "17.18.354",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Round value to nearest step",
      "example": ", to round a calculated price to the nearest penny, use Round(price, 0.01).Note that negative values are always rounded \"away from zero\", e.g.\u00b7 round(-1.5, 1, 0) = -2\u00b7 round(-1.5, 1, 1) = -2\u00b7 round(-1.5, 1, -1) = -1In other words negative values are rounded as if they were positive and then the minus sign is applied to the result.(This is consistent with how =Round, =Round Up, and =Round Down\u2026",
      "notes": "The direction parameter is interpreted as follows:\u00b7 0 means round to the nearest step, e.g. if step is 1, round UP if the decimal part of value is >= 0.5 else round down\u00b7 1 means always round up\u00b7 -1 means always round down For",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.354",
          "title": "Round",
          "line": 4909
        }
      ],
      "sample_examples": [
        {
          "file": "samples/clenow_stocks_on_move.rts",
          "line": 53,
          "code": "newqty:\tround(extern(@clenow_stocks, S.Alloc) * riskfactor / atr20)"
        },
        {
          "file": "samples/clenow_stocks_on_move_dynamic.rts",
          "line": 49,
          "code": "newqty:\tround(S.Alloc * riskfactor / ATR(20))"
        },
        {
          "file": "samples/hybrid_asset_allocation_dynamic.rts",
          "line": 42,
          "code": "new_size:\tround(new_pct / 100 * S.Alloc / Close, -1)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "RRSI",
      "title": "RRSI",
      "aliases": [],
      "section": "17.18.356",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Indicator Functions",
      "description": "Reverse RSI (price required for RSI to reach level)",
      "example": null,
      "notes": "This function can be used to calculate entry or exit limit prices based on RSI reaching a specific level.Calculation uses the original Welles Wilder formula. Wilder's exponential smoothing is equivalent to using 2*len-1 in a regular exponential moving average.This indicator supports one-pass calculation when used in the Data Section with a non-variable length.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.356",
          "title": "RRSI",
          "line": 4916
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "RSI",
      "title": "RSI",
      "aliases": [],
      "section": "17.18.355",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Indicator Functions",
      "description": "Wilder's relative strength index",
      "example": null,
      "notes": "Calculation uses the original Welles Wilder formula. Wilder's exponential smoothing is equivalent to using 2*len-1 in a regular exponential moving average.It's a little-known fact RSI(len) crossing above or below 50 is the same as C crossing above or below EMA(C,2*len-1).This indicator supports one-pass calculation when used in the Data Section with a non-variable length.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.355",
          "title": "RSI",
          "line": 4911
        }
      ],
      "sample_examples": [
        {
          "file": "samples/Sample1.rts",
          "line": 16,
          "code": "BarSize:\tDaily"
        },
        {
          "file": "samples/Sample2.rts",
          "line": 9,
          "code": "BarSize:\tDaily"
        },
        {
          "file": "samples/Sample2a.rts",
          "line": 9,
          "code": "BarSize:\tDaily"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "RsiF",
      "title": "RsiF",
      "aliases": [],
      "section": "17.18.357",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "RSI as a function",
      "example": null,
      "notes": "The standard RSI indicator always uses the series of closing prices for its calculations. This function makes it possible to calculate RSI for any series of values.Calculation uses the original Welles Wilder formula. Wilder's exponential smoothing is equivalent to using 2*len-1 in a regular exponential moving average.This function supports one-pass calculation when used in the Data Section with a non-variable count.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.357",
          "title": "RsiF",
          "line": 4918
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.Alloc",
      "title": "S.Alloc",
      "aliases": [],
      "section": "17.18.358",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The amount of money allocated to this strategy on this test date",
      "example": null,
      "notes": "S.Alloc is the most recently calculated value of the Allocation formula.If no Allocation formula was given, S.Alloc defaults to Combined(S.Equity).S.Alloc is calculated once per backtest date, before any trade entries or exits are processed. Think of it as the \"overnight\" account value. Use S.Alloc to access your current allocation value in the Quantity (position size) formula, if your Qty Type is Shares (default) or Value. If Qty Type is Percent, then S.Alloc is automatically used as the value of which to calculate the percentage.In contrast to S.Alloc, S.Equity is updated every time a trade\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.358",
          "title": "S.Alloc",
          "line": 4923
        }
      ],
      "sample_examples": [
        {
          "file": "samples/bensdorp_book.rts",
          "line": 99,
          "code": "Quantity:\tlfrac * Min(S.Alloc/10/C, (S.Alloc*0.02)/(5*atr20))"
        },
        {
          "file": "samples/clenow_stocks_on_move.rts",
          "line": 53,
          "code": "newqty:\tround(extern(@clenow_stocks, S.Alloc) * riskfactor / atr20)"
        },
        {
          "file": "samples/clenow_stocks_on_move_dynamic.rts",
          "line": 49,
          "code": "newqty:\tround(S.Alloc * riskfactor / ATR(20))"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "S.BPx",
      "title": "S.BPx",
      "aliases": [],
      "section": "17.18.359",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "Number of stat bars (dates) per period in the current test stats data",
      "example": ", if a script includes a daily bar strategy and a weekly bar strategy, there will 252 stat periods per year for both strategies, and S.BPY will return 252 by default.Use the Days Per Year setting to specify a number of daily stat periods per year other than 252.If a script only includes weekly bar strategies, there will be 52 stat periods per year and S.BPY will return 52.The purpose of S.BPY is\u2026",
      "notes": "Specific values are:\u00b7 S.BPY = bars per year\u00b7 S.BPQ = bars per quarter (S.BPY / 4)\u00b7 S.BPM = bars per month (S.BPY / 12) \u00b7 S.BPW = bars per week (S.BPY / 52) The size of each stat period in a test will always be the smallest bar size used in any strategy. For",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.359",
          "title": "S.BPx",
          "line": 4925
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.CashInOut",
      "title": "S.CashInOut",
      "aliases": [],
      "section": "17.18.360",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The running total net Cash In Out for this strategy as of this date",
      "example": null,
      "notes": "The net cash in-out for one stats period can be calculated as S.Cash In Out - S.Cash In Out[1]Unlike S.Fees In Out, S.Cash In Out is NOT included in backtest stats such as the annual return, max drawdown, and daily net percent gain or loss.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.360",
          "title": "S.CashInOut",
          "line": 4930
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.Comms",
      "title": "S.Comms",
      "aliases": [],
      "section": "17.18.361",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The sum of all commissions paid by this strategy on this test date",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.361",
          "title": "S.Comms",
          "line": 4932
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.Compounded",
      "title": "S.Compounded",
      "aliases": [],
      "section": "17.18.362",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "Stats compounding flag",
      "example": null,
      "notes": "Returns 1 (true) if the test used compounding, or 0 (false) otherwise.A test uses compounding if the Allocation or Quantity formula of any strategy refers to S.Equity.If neither formula refers to S.Equity in any strategy then the test does not use compounding. If either formula is absent in any strategy, then the test does use compounding, because the default formula for both of these strategy elements is, in fact, S.Equity.Because this is a test-level statistic, the value returned will be the same for every strategy (hence no need for \"Combined\").",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.362",
          "title": "S.Compounded",
          "line": 4934
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.Date",
      "title": "S.Date",
      "aliases": [],
      "section": "17.18.363",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The current test date",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.363",
          "title": "S.Date",
          "line": 4939
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.DDBars",
      "title": "S.DDBars",
      "aliases": [],
      "section": "17.18.364",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The duration, in bars, of the current drawdown for this strategy as of this test date",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.364",
          "title": "S.DDBars",
          "line": 4941
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.DDDlr",
      "title": "S.DDDlr",
      "aliases": [],
      "section": "17.18.365",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The size, in dollars, of the current drawdown for this strategy as of this test date",
      "example": null,
      "notes": "The internal daily equity value used to calculate drawdown includes the mark-to-market value of open positions.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.365",
          "title": "S.DDDlr",
          "line": 4943
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.DDPct",
      "title": "S.DDPct",
      "aliases": [],
      "section": "17.18.366",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The size, in percentage, of the current drawdown for this strategy as of this test date",
      "example": null,
      "notes": "The internal daily equity value used to calculate drawdown includes the mark-to-market value of open positions.See Compounding for details on how drawdown percentage is calculated for compounded vs. non-compounded tests.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.366",
          "title": "S.DDPct",
          "line": 4945
        }
      ],
      "sample_examples": [
        {
          "file": "samples/mr_sample_tracking_alloc.rts",
          "line": 19,
          "code": "Quantity:\tif (Extern(@mr_long_track, S.DDPct > 0.05), 50, 100) / NumPos"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "S.Dividends",
      "title": "S.Dividends",
      "aliases": [],
      "section": "17.18.367",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The sum of all dividends received or paid by this strategy on this test date",
      "example": null,
      "notes": "Total dividends in a backtest can be added to Results.rts as Dividends: Sum(S.Dividends, S.Number).",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.367",
          "title": "S.Dividends",
          "line": 4949
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.Entries",
      "title": "S.Entries",
      "aliases": [],
      "section": "17.18.368",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The number of new positions entered by this strategy on this test date",
      "example": null,
      "notes": "If referenced from any entry-related strategy formula, S.Entries will return the prior test day's entry count, not that of the current day.Use Combined or Extern to obtain this value for all strategies or for a specific other strategy or Stats Group.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.368",
          "title": "S.Entries",
          "line": 4951
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.EntryOrders",
      "title": "S.EntryOrders",
      "aliases": [],
      "section": "17.18.369",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The number of entry orders placed on this test date",
      "example": null,
      "notes": "S.Entry Orders becomes available at the end of the daily setup selection and ranking process.It can be used in the Qty Final formula as needed to change position sizes based on order count vs. exposure capacity.S.Entry Orders can also be used as a statistic showing how many orders were \"placed\" each day.For strategies that enter \"at market\" S.Entry Orders will usually be the same as S.Entries.For strategies that enter using stop and/or limit orders, S.Entry Orders will usually be more than S.Entries.Use Combined or Extern to obtain this value for all strategies or for a specific other\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.369",
          "title": "S.EntryOrders",
          "line": 4953
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.Equity",
      "title": "S.Equity",
      "aliases": [],
      "section": "17.18.370",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The current account value of a strategy or group of strategies as of this test date",
      "example": null,
      "notes": "By default, S.Equity includes the mark-to-market value, S.M2M, of currently open positions. To get closed-trade-only equity, use S.Equity - S.M2M.If Mark To Market is set to False, then S.Equity does not include S.M2M, and will only change value when a position is closed.S.Equity also includes net cash deposits and withdrawals (from the Cash In Out strategy element). To factor those out, use S.Equity - S.Cash In Out.Likewise for Fees In Out and S.Fees In Out, the difference being that Cash In Out is not included in backtest stats while Fees In Out are included.Use Combined to access the\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.370",
          "title": "S.Equity",
          "line": 4955
        }
      ],
      "sample_examples": [
        {
          "file": "samples/gc_kelly.rts",
          "line": 32,
          "code": "Quantity:\t(S.Equity * kf * f) / (PointValue * stp * atrx)"
        },
        {
          "file": "samples/keltner_pullback.rts",
          "line": 43,
          "code": "Quantity:\tS.Equity * 0.005 / risk\t// share quantity to risk 0.5% based on stop"
        },
        {
          "file": "samples/mr_sample_tracking.rts",
          "line": 10,
          "code": "SetupSkip:\tif(not IsTracker, Extern(@tracker, S.Equity < Avg(S.Equity, 150)), 0)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "S.Exits",
      "title": "S.Exits",
      "aliases": [],
      "section": "17.18.371",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The number of positions exited by this strategy on this test date",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.371",
          "title": "S.Exits",
          "line": 4959
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.Exposure",
      "title": "S.Exposure",
      "aliases": [],
      "section": "17.18.372",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "Total value of positions held overnight as a fraction of current allocation (typically mark-to-market account value)",
      "example": null,
      "notes": "S.Exposure is S.Invested / S.Alloc Use Combined or Extern to obtain this value for all strategies or for a specific other strategy or Stats Group.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.372",
          "title": "S.Exposure",
          "line": 4961
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.FeesInOut",
      "title": "S.FeesInOut",
      "aliases": [],
      "section": "17.18.373",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The running total net Fees In Out for this strategy as of this date",
      "example": null,
      "notes": "The net fees in-out for one stats period can be calculated as S.Fees In Out - S.Fees In Out[1]Unlike S.Cash In Out, S.Fees In Out are included in all the stats calculations of a backtest, such as the annual return, max drawdown, and daily net percent gain or loss.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.373",
          "title": "S.FeesInOut",
          "line": 4963
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.First",
      "title": "S.First",
      "aliases": [],
      "section": "17.18.374",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The number of the first stat period in a test in which a position was entered",
      "example": null,
      "notes": "In the default Results Section, \"Periods\" is defined as S.Number - S.First + 1, and is then used in all of the stats calculations that require a test period count.By using Periods in this way, the stats accurately reflect the span of time which which actual trading occurs, and omit any \"warm-up\" bars where indicators are still being calculated.The Combined S.First value is the smallest value for any strategy (benchmark strategies are not included in combined stats).In the Summary Report, the individual strategy stats will each reflect that strategy's number of periods (assuming default\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.374",
          "title": "S.First",
          "line": 4968
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.FreeCash",
      "title": "S.FreeCash",
      "aliases": [],
      "section": "17.18.375",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The current free cash balance of the account",
      "example": null,
      "notes": "S.Free Cash is calculated as: (starting equity) + (closed trade net profit incl. dividends) + (net cash in-out) + (net interest received-paid)+ (proceeds from currently open short stock positions)- (cost basis of currently open long stock positions)- (margin requirements of currently open futures positions) Combined(S.Free Cash) represents the current \"free cash balance\" of the trading account.",
      "see_also": [
        ": Cash Int Pct",
        "Margin Int Pct",
        "Futures Margin",
        "Min Free Cash"
      ],
      "manual_refs": [
        {
          "section": "17.18.375",
          "title": "S.FreeCash",
          "line": 4970
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.FuturesMargin",
      "title": "S.FuturesMargin",
      "aliases": [],
      "section": "17.18.376",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The current total dollar margin requirement to hold open futures positions",
      "example": null,
      "notes": "See Futures Margin for details about how Real Test models futures margin.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.376",
          "title": "S.FuturesMargin",
          "line": 4974
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.Interest",
      "title": "S.Interest",
      "aliases": [],
      "section": "17.18.377",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The net interest received and/or paid for excess cash and/or margin loan and/or short borrow fees on this date",
      "example": null,
      "notes": "S.Interest is only relevant in the Combined stats series. It will always be 0 for individual strategies.Cumulative net interest can be calculated as Sum(S.Interest, S.Number).See Cash Int Pct, Margin Int Pct, and Risk Free Rate Sym for details on how interest received and/or charged is calculated and applied.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.377",
          "title": "S.Interest",
          "line": 4976
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.Invested",
      "title": "S.Invested",
      "aliases": [],
      "section": "17.18.378",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "Total dollar value of positions held overnight",
      "example": null,
      "notes": "S.Invested is the sum of (shares * latest price) plus dividends received so far of open positions when Mark To Market is True (the default).When Mark To Market is False S.Invested is the sum of (shares * entry price) of open positions. To see this original investment value when Mark To Market is True, use S.Invested - S.M2M.For futures positions \"shares\" above means (contracts * point value), i.e., S.Invested uses notional dollars.Use Combined or Extern to obtain this value for all strategies or for a specific other strategy or Stats Group.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.378",
          "title": "S.Invested",
          "line": 4978
        }
      ],
      "sample_examples": [
        {
          "file": "samples/mr_sample_hedged.rts",
          "line": 9,
          "code": "imbalance: Extern(@mr_short, S.Invested) - Extern(@mr_long, S.Invested)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "S.LongExp",
      "title": "S.LongExp",
      "aliases": [],
      "section": "17.18.379",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "Total value of long positions held overnight as a fraction of current allocation (typically mark-to-market account value)",
      "example": null,
      "notes": "S.Long Exp is S.Long Inv / S.Alloc Use Combined or Extern to obtain this value for all strategies or for a specific other strategy or Stats Group.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.379",
          "title": "S.LongExp",
          "line": 4982
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.LongInv",
      "title": "S.LongInv",
      "aliases": [],
      "section": "17.18.380",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "Total dollar value of long positions held overnight",
      "example": null,
      "notes": "S.Long Inv is the sum of (shares * latest price) plus dividends received so far of open long positions when Mark To Market is True (the default).When Mark To Market is False S.Long Inv is the sum of (shares * entry price) of open long positions.To see this original long investment value when Mark To Market is True, use S.Long Inv - S.M2M.For futures positions \"shares\" above means (contracts * point value), i.e., S.Long Inv is the notional dollar value fo open longs.Use Combined or Extern to obtain this value for all strategies or for a specific other strategy or Stats Group.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.380",
          "title": "S.LongInv",
          "line": 4984
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.LossAmt",
      "title": "S.LossAmt",
      "aliases": [],
      "section": "17.18.381",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The sum of dollar (or base currency) losses for all trades exited as losses by this strategy on this test date (expressed as a positive value).Can also be written as S.Loss Dlr.",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.381",
          "title": "S.LossAmt",
          "line": 4986
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.LossBars",
      "title": "S.LossBars",
      "aliases": [],
      "section": "17.18.382",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The sum of durations, in bars, for trades exited as losses by this strategy on this test date",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.382",
          "title": "S.LossBars",
          "line": 4988
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.Losses",
      "title": "S.Losses",
      "aliases": [],
      "section": "17.18.383",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The number of trades exited as losses by this strategy on this test date",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.383",
          "title": "S.Losses",
          "line": 4992
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.LossPct",
      "title": "S.LossPct",
      "aliases": [],
      "section": "17.18.384",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The sum of dollar loss / dollar position size for all trades exited as losses in this strategy on this test date (expressed as a positive value)",
      "example": null,
      "notes": "Use S.Loss Pct Alloc if you need the sum of dollar loss / strategy allocation.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.384",
          "title": "S.LossPct",
          "line": 4994
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.LossPctAlloc",
      "title": "S.LossPctAlloc",
      "aliases": [],
      "section": "17.18.385",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The sum of dollar loss / strategy allocation for all trades exited as losses in this strategy on this test date (expressed as a positive value)",
      "example": null,
      "notes": "Use S.Loss Pct if you need the sum dollar loss / dollar position size.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.385",
          "title": "S.LossPctAlloc",
          "line": 4996
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.M2M",
      "title": "S.M2M",
      "aliases": [],
      "section": "17.18.386",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "Net gain or loss, in dollars, of all positions remaining open in this strategy on this test date",
      "example": null,
      "notes": "The default \"M2M\" daily stats graph is calculated as S.M2M / S.Alloc and displayed as a percentage.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.386",
          "title": "S.M2M",
          "line": 4998
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.MAE",
      "title": "S.MAE",
      "aliases": [],
      "section": "17.18.387",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "Worst-case (\"adverse\") net gain or loss, in dollars, of all positions remaining open in this strategy on this test date",
      "example": null,
      "notes": "This is theoretically the worst daily net P&L (M2M) value that could have occurred during this day, had all positions touched their least favorable prices simultaneously.The default \"MAE\" daily stats graph is calculated as S.MAE / S.Alloc and displayed as a percentage.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.387",
          "title": "S.MAE",
          "line": 5000
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.MarginReq",
      "title": "S.MarginReq",
      "aliases": [],
      "section": "17.18.389",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Syntax Element Details",
      "description": null,
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.389",
          "title": "S.MarginReq",
          "line": 5007
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.MaxAlloc",
      "title": "S.MaxAlloc",
      "aliases": [],
      "section": "17.18.390",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The amount, in dollars, of the largest allocation value of this strategy as of this test date.",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.390",
          "title": "S.MaxAlloc",
          "line": 5008
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.MaxDDBars",
      "title": "S.MaxDDBars",
      "aliases": [],
      "section": "17.18.391",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The duration, in bars, of the longest drawdown as of this test date",
      "example": null,
      "notes": "The longest drawdown is not necessarily the largest one.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.391",
          "title": "S.MaxDDBars",
          "line": 5010
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.MaxDDDlr",
      "title": "S.MaxDDDlr",
      "aliases": [],
      "section": "17.18.392",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The size, in dollars, of the largest drawdown of this strategy as of this test date",
      "example": null,
      "notes": "The internal daily equity value used to calculate drawdown includes the mark-to-market value of open positions.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.392",
          "title": "S.MaxDDDlr",
          "line": 5014
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.MaxDDPct",
      "title": "S.MaxDDPct",
      "aliases": [],
      "section": "17.18.393",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The size, in percentage, of the largest drawdown of this strategy as of this test date",
      "example": null,
      "notes": "The internal daily equity value used to calculate drawdown includes the mark-to-market value of open positions.See Compounding for details on how drawdown percentage is calculated for compounded vs. non-compounded tests.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.393",
          "title": "S.MaxDDPct",
          "line": 5016
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.MaxEquity",
      "title": "S.MaxEquity",
      "aliases": [],
      "section": "17.18.394",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The amount, in dollars, of the largest net liquidation value of this strategy as of this test date.",
      "example": null,
      "notes": "See S.Equity for on what is included in this value.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.394",
          "title": "S.MaxEquity",
          "line": 5018
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.MFE",
      "title": "S.MFE",
      "aliases": [],
      "section": "17.18.388",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "Best-case (\"favorable\") net gain or loss, in dollars, of all positions remaining open in this strategy on this test date",
      "example": null,
      "notes": "This is theoretically the best daily net P&L (M2M) value that could have occurred during this day, had all positions touched their most favorable prices simultaneously.The default \"MFE\" daily stats graph is calculated as S.MFE / S.Alloc and displayed as a percentage.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.388",
          "title": "S.MFE",
          "line": 5005
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.MinAlloc",
      "title": "S.MinAlloc",
      "aliases": [],
      "section": "17.18.395",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The amount, in dollars, of the smallest allocation value of this strategy as of this test date.",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.395",
          "title": "S.MinAlloc",
          "line": 5020
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.MinEquity",
      "title": "S.MinEquity",
      "aliases": [],
      "section": "17.18.396",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The amount, in dollars, of the smallest net liquidation value of this strategy as of this test date.",
      "example": null,
      "notes": "See S.Equity for on what is included in this value.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.396",
          "title": "S.MinEquity",
          "line": 5022
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.NetDlr",
      "title": "S.NetDlr",
      "aliases": [],
      "section": "17.18.397",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The daily dollar change in net liquidation value of the portion of the account allocated to this strategy as of this test date",
      "example": null,
      "notes": "This is equivalent to S.Equity - S.Equity[1].",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.397",
          "title": "S.NetDlr",
          "line": 5026
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.NetFx",
      "title": "S.NetFx",
      "aliases": [],
      "section": "17.18.398",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The sum of net currency exchange rate change impact on trade profit or loss (T.Net Fx) for all trades closed this period",
      "example": null,
      "notes": "The value will always be 0 unless your test was correctly set up for multi-currency strategy modeling and one or more stocks traded had different base currency than your account's base currency.See Currency and Testing Multi-Currency Strategies for details on how this works.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.398",
          "title": "S.NetFx",
          "line": 5028
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.NetPct",
      "title": "S.NetPct",
      "aliases": [],
      "section": "17.18.399",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The daily percent change in net liquidation value of the portion of the account allocated to this strategy as of this test date",
      "example": null,
      "notes": "This is equivalent to (S.Equity - S.Equity[1]) / S.Alloc[1].",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.399",
          "title": "S.NetPct",
          "line": 5030
        }
      ],
      "sample_examples": [
        {
          "file": "samples/spy_tlt_uis.rts",
          "line": 17,
          "code": "Sharpe:\t \t\t{#2} SQR(252)*Avg(S.NetPct,Periods)/(StdDev(S.NetPct,Periods)^2)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "S.Number",
      "title": "S.Number",
      "aliases": [],
      "section": "17.18.400",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The number of this stat period in a test",
      "example": ", if a script includes a Daily bar strategy and a Weekly bar strategy, and is run for one year, there will by default be 252 stat periods for both strategies, and S.Number will be 252 for the final period of either strategy.Use the Days Per Year setting to specify a number of daily stat periods per year other than 252.If a script only includes weekly bar strategies and is run for one year, there\u2026",
      "notes": "In the context of the Graphs Section, S.Number is also the count of stat periods so far as of this test date.In the context of the Results Section, S.Number is also the total number of stat periods in the test.The size of each stat period in a test will always be the smallest bar size used in any strategy. For",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.400",
          "title": "S.Number",
          "line": 5032
        }
      ],
      "sample_examples": [
        {
          "file": "samples/management_fees.rts",
          "line": 17,
          "code": "perf_fee:\tSelect(fee_period and S.Number > 1, pf_rate * max(S.Alloc - hwm[1] - mgmt_fee, 0), 0)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "S.Positions",
      "title": "S.Positions",
      "aliases": [],
      "section": "17.18.401",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The number of positions that are currently open in the current strategy.",
      "example": null,
      "notes": "When referenced from entry-related formulas in a strategy that enters positions at the open or at the close, S.Positions will have been reduced by any exits that occurred at that same time, allowing it to effectively be used in your entry-related strategy formulas to may need to calculate the number of available \"position slots\".Use Combined or Extern to obtain this value for all strategies or for a specific other strategy or Stats Group.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.401",
          "title": "S.Positions",
          "line": 5036
        }
      ],
      "sample_examples": [
        {
          "file": "samples/mr_sample_test_scan.rts",
          "line": 50,
          "code": "LongEntry:\tLongSetup and LongRank <= Extern(@mr_long, NumPos - S.Positions)"
        },
        {
          "file": "samples/oex_tf_top_down.rts",
          "line": 49,
          "code": "EntrySetup:\tuniverse and c > high1[1]\t// checking Shares or S.Positions is unnecessary"
        },
        {
          "file": "samples/turtles.rts",
          "line": 42,
          "code": "longUnits:\tExtern(@long1, S.Positions) + Extern(@long2, S.Positions) + Extern(@long3, S.Positions) + Extern(@long4, S.Positions)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "S.RiskFreeRate",
      "title": "S.RiskFreeRate",
      "aliases": [],
      "section": "17.18.402",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The daily closing value of the data series specified by the Risk Free Rate Sym symbol",
      "example": null,
      "notes": "This is mainly useful when calculating the Sharpe Ratio, as in the default formula from Results.rts: If Risk Freee Rate Sym is not specified or if it refers to a symbol that is not available in the current data file, S.Risk Free Rate will be a series of zeros.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.402",
          "title": "S.RiskFreeRate",
          "line": 5038
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.RollCosts",
      "title": "S.RollCosts",
      "aliases": [],
      "section": "17.18.403",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The sum of all roll costs paid by this strategy on this test date",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.403",
          "title": "S.RollCosts",
          "line": 5044
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.Setups",
      "title": "S.Setups",
      "aliases": [],
      "section": "17.18.404",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The number of stocks that met the Entry Setup criteria in the current strategy.",
      "example": null,
      "notes": "If referenced from any entry-related strategy formula, S.Setups will return the prior test day's setup count, not that of the current day.Use Combined or Extern to obtain this value for all strategies or for a specific other strategy or Stats Group.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.404",
          "title": "S.Setups",
          "line": 5046
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.ShortExp",
      "title": "S.ShortExp",
      "aliases": [],
      "section": "17.18.405",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "Total value of short positions held overnight as a fraction of current allocation (typically mark-to-market account value)",
      "example": null,
      "notes": "S.Short Exp is S.Shortnv / S.Alloc Use Combined or Extern to obtain this value for all strategies or for a specific other strategy or Stats Group.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.405",
          "title": "S.ShortExp",
          "line": 5048
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.ShortInv",
      "title": "S.ShortInv",
      "aliases": [],
      "section": "17.18.406",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "Total dollar value of short positions held overnight",
      "example": null,
      "notes": "S.Short Inv is the sum of (shares * latest price) minus dividends paid so far of open short positions when Mark To Market is True (the default). When Mark To Market is False S.Short Inv is the sum of (shares * entry price) of open positions.To see this original short investment value when Mark To Market is True, use S.Short Inv + S.M2M.For futures positions \"shares\" above means (contracts * point value), i.e., S.Short Inv is the notional dollar value of open shorts.Use Combined or Extern to obtain this value for all strategies or for a specific other strategy or Stats Group.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.406",
          "title": "S.ShortInv",
          "line": 5050
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.Slips",
      "title": "S.Slips",
      "aliases": [],
      "section": "17.18.407",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The sum of all slippage amounts applied to trade entries or exits by this strategy on this test date",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.407",
          "title": "S.Slips",
          "line": 5055
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.StartEquity",
      "title": "S.StartEquity",
      "aliases": [],
      "section": "17.18.408",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The starting equity, in dollars, for this strategy",
      "example": null,
      "notes": "This value will be the same for every test date.See Allocation for more information.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.408",
          "title": "S.StartEquity",
          "line": 5057
        }
      ],
      "sample_examples": [
        {
          "file": "samples/dividend_capture.rts",
          "line": 43,
          "code": "Allocation:\tS.StartEquity // non-compounded"
        },
        {
          "file": "samples/futures_volume_rank.rts",
          "line": 47,
          "code": "Allocation: S.StartEquity"
        },
        {
          "file": "samples/turtles.rts",
          "line": 48,
          "code": "Size > 0.9 * S.StartEquity, 1,"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "S.Stops",
      "title": "S.Stops",
      "aliases": [],
      "section": "17.18.409",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The number of trades that exited because of their Exit Stop for this strategy on this test date",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.409",
          "title": "S.Stops",
          "line": 5059
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.Targets",
      "title": "S.Targets",
      "aliases": [],
      "section": "17.18.410",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The number of trades that exited because of their Exit Limit for this strategy on this test date",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.410",
          "title": "S.Targets",
          "line": 5061
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.TradeBars",
      "title": "S.TradeBars",
      "aliases": [],
      "section": "17.18.411",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The sum of durations, in bars, for all trades exited by this strategy on this test date",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.411",
          "title": "S.TradeBars",
          "line": 5065
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.TradeDlr",
      "title": "S.TradeDlr",
      "aliases": [],
      "section": "17.18.412",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The sum of dollar gains-losses for all trades exited in this strategy on this test date",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.412",
          "title": "S.TradeDlr",
          "line": 5067
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.TradePct",
      "title": "S.TradePct",
      "aliases": [],
      "section": "17.18.413",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The sum of net dollar gain or loss / trade position size for all trades exited in this strategy on this test date",
      "example": null,
      "notes": "Use S.Trade Pct Alloc if you need the sum of dollar gain or loss / strategy allocation.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.413",
          "title": "S.TradePct",
          "line": 5069
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.TradePctAlloc",
      "title": "S.TradePctAlloc",
      "aliases": [],
      "section": "17.18.414",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The sum of net dollar gain or loss / strategy allocation for all trades exited in this strategy on this test date",
      "example": null,
      "notes": "Use S.Trade Pct if you need the sum of dollar gain or loss / trade position size.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.414",
          "title": "S.TradePctAlloc",
          "line": 5071
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.TWEQ",
      "title": "S.TWEQ",
      "aliases": [],
      "section": "17.18.415",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The time-weighted equity of this strategy as of this test date",
      "example": null,
      "notes": "If a test uses compounded stats (if S.Compounded is 1) then S.TWEQ is a compounded series of daily returns.In this case, S.TWEQ starts a $1 and then is multiplied each day by (1 + that day's percent return), resulting in a \"growth of $1\" series.When a test does not use compounding, S.TWEQ is the same as S.Equity.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.415",
          "title": "S.TWEQ",
          "line": 5073
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.Usage",
      "title": "S.Usage",
      "aliases": [],
      "section": "17.18.416",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "Total value of positions held any time this period as a fraction of current allocation (typically mark-to-market account value)",
      "example": null,
      "notes": "S.Usage is the maximum intraday value of S.Exposure.Use Combined or Extern to obtain this value for all strategies or for a specific other strategy or Stats Group.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.416",
          "title": "S.Usage",
          "line": 5078
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.WinAmt",
      "title": "S.WinAmt",
      "aliases": [],
      "section": "17.18.417",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The sum of dollar (or base currency) gains for all trades exited as wins in this strategy on this test date.Can also be written as S.Win Dlr.",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.417",
          "title": "S.WinAmt",
          "line": 5080
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.WinBars",
      "title": "S.WinBars",
      "aliases": [],
      "section": "17.18.418",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The sum of durations, in bars, for all trades exited as wins in this strategy on this test date",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.418",
          "title": "S.WinBars",
          "line": 5082
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.WinPct",
      "title": "S.WinPct",
      "aliases": [],
      "section": "17.18.419",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The sum of dollar gain / trade position size for all trades exited as wins in this strategy on this test date",
      "example": null,
      "notes": "Use S.Win Pct Alloc if you need the sum of dollar gain / strategy allocation.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.419",
          "title": "S.WinPct",
          "line": 5084
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.WinPctAlloc",
      "title": "S.WinPctAlloc",
      "aliases": [],
      "section": "17.18.420",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The sum of dollar gain / strategy allocation for all trades exited as wins in this strategy on this test date",
      "example": null,
      "notes": "Use S.Win Pct if you need the sum of dollar gain / trade position size.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.420",
          "title": "S.WinPctAlloc",
          "line": 5089
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "S.Wins",
      "title": "S.Wins",
      "aliases": [],
      "section": "17.18.421",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Daily Test Statistics",
      "description": "The number of trades exited as wins by this strategy on this test date",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.421",
          "title": "S.Wins",
          "line": 5091
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "SAR",
      "title": "SAR",
      "aliases": [],
      "section": "17.18.422",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Indicator Functions",
      "description": "Wilder's Parabolic Stop And Reverse",
      "example": null,
      "notes": "Implements the Parabolic Time/Price System as an indicator function for use in trading strategies. The standard SAR is calculated using price highs and lows.To calculate SAR using a single non-standard value series, use Sar F.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.422",
          "title": "SAR",
          "line": 5093
        }
      ],
      "sample_examples": [
        {
          "file": "samples/mr_sample_tradelist.rts",
          "line": 12,
          "code": "The Commission override is necessary because these will be different from the original share quantities"
        },
        {
          "file": "samples/oex_tf_top_down.rts",
          "line": 49,
          "code": "EntrySetup:\tuniverse and c > high1[1]\t// checking Shares or S.Positions is unnecessary"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "SarF",
      "title": "SarF",
      "aliases": [],
      "section": "17.18.423",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "SAR as a function",
      "example": null,
      "notes": "Use Sar F to calcuate SAR using a single non-standard value series.Use SAR for the standard indicator based on price highs and lows.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.423",
          "title": "SarF",
          "line": 5095
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "SaveAs",
      "title": "SaveAs",
      "aliases": [],
      "section": "17.18.424",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Import Specification",
      "description": "Path and name of the data file (.RTD) to save at the end of an import",
      "example": null,
      "notes": "If the Save As file already exists, it will be overwritten without confirmation.If Save As is not specified, Real Test will show a standard file save dialog at the end of the import.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.424",
          "title": "SaveAs",
          "line": 5099
        }
      ],
      "sample_examples": [
        {
          "file": "samples/Sample1.rts",
          "line": 10,
          "code": "SaveAs:\tsample1.rtd"
        },
        {
          "file": "samples/actual_trades.rts",
          "line": 12,
          "code": "SaveAs:\tactual_trades.rtd"
        },
        {
          "file": "samples/anchored_vwap.rts",
          "line": 11,
          "code": "SaveAs:\tspy.rtd"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "SaveChartsTo",
      "title": "SaveChartsTo",
      "aliases": [],
      "section": "17.18.425",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "Path of a folder in which to automatically save a chart for every row of the scan",
      "example": null,
      "notes": "If this setting is present, then every time a scan is run, a chart will be automatically created for every item (row) of the scan. Charts are created in the specified folder using symbol_date.png (e.g. MSFT_20210518.png) as their file names.Existing folder contents are not deleted before new charts are added, but existing chart files with the same names will be overwritten without asking.Saved charts have the same width and height and other display options as the most recently viewed chart window.This feature was added to aid discretionary traders in creating a \"chart book\" for study\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.425",
          "title": "SaveChartsTo",
          "line": 5101
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "SavePositionsAs",
      "title": "SavePositionsAs",
      "aliases": [],
      "section": "17.18.426",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "Path and name of a CSV file to optionally produce at the end of a test to list positions that were still open",
      "example": null,
      "notes": "If Save Positions As is specified, on the last date of a backtest, before the \"end of test\" exits are processed, a list of open positions in all strategies is created and saved to the specified CSV file.Unlike some Scan and Test Settings, there is no Settings Panel equivalent for this particular option and the setting does not persist. See File Path Specification for helpful tips including special path expansion variables.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.426",
          "title": "SavePositionsAs",
          "line": 5106
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "SaveScanAs",
      "title": "SaveScanAs",
      "aliases": [],
      "section": "17.18.427",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "Path and name of CSV file to optionally create",
      "example": null,
      "notes": "If Save Scan As is specified, then the contents of the scan window are automatically saved to the specified file in CSV format each time a scan is run. If the file already exists, it will be overwritten without confirmation.If Save Scan As is not specified, there is no prompt to save a scan, but you can easily do so using the Scan Menu.Most scans that you run are likely to be quick one-off explorations that do not require saving. The Save Scan As setting was added mainly to make it easier to create a daily candidate list for live trading.Unlike some Scan and Test Settings, there is no\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.427",
          "title": "SaveScanAs",
          "line": 5108
        }
      ],
      "sample_examples": [
        {
          "file": "samples/djia_make_syminfo.rts",
          "line": 18,
          "code": "SaveScanAs:\t?scriptpath?\\djia_info.csv"
        },
        {
          "file": "samples/management_fees.rts",
          "line": 38,
          "code": "SaveScanAs:\t?scriptpath?\\management_fees.csv"
        },
        {
          "file": "samples/mr_sample_scan.rts",
          "line": 16,
          "code": "SaveScanAs:\tmr_sample_setups.csv"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "SaveStatsAs",
      "title": "SaveStatsAs",
      "aliases": [],
      "section": "17.18.428",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "Path and name of CSV file to optionally create",
      "example": null,
      "notes": "If Save Stats As is specified, then all formulas in the Graphs section are evaluated for each date of the test and written to a CSV file. If the file already exists, it will be overwritten without confirmation. The CSV file will contain a separate row per date for each individual Strategy, each Stats Group, and Combined.The columns in each row are Date and Strategy followed by a column for each Graphs item.Unlike some Scan and Test Settings, there is no Settings Panel equivalent for this particular option and the setting does not persist. This setting is ignored when running multiple tests\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.428",
          "title": "SaveStatsAs",
          "line": 5110
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "SaveTestListAs",
      "title": "SaveTestListAs",
      "aliases": [],
      "section": "17.18.429",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "Path and name of CSV file to optionally create",
      "example": null,
      "notes": "If Save Test List As is specified, then at the end of a script run the visible contents of the Results Window are saved as a CSV file. If the file already exists, it will be overwritten without confirmation.This is equivalent to manually selecting Save List as CSV File from the Results Menu after the test or optimization run finishes.The purpose of this setting is to facilitate automation of optimization runs with summary stats saved in CSV format for external processing.To automatically save the detailed stats from a single test to CSV, use Save Stats As.Unlike some Scan and Test Settings\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.429",
          "title": "SaveTestListAs",
          "line": 5115
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "SaveTradesAs",
      "title": "SaveTradesAs",
      "aliases": [],
      "section": "17.18.430",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "Path and name of CSV file to optionally create",
      "example": null,
      "notes": "If Save Trades As is specified, then all standard and custom trade items for every trade in the test are written in CSV columns as raw values (format codes are ignored). If the file already exists, it will be overwritten without confirmation.The content of this CSV file is the same as would be produced by opening the Trade List for the test and then saving it in CSV format.Unlike some Scan and Test Settings, there is no Settings Panel equivalent for this particular option and the setting does not persist. This setting is ignored when running multiple tests unless the Multi Save As CSV box is\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.430",
          "title": "SaveTradesAs",
          "line": 5117
        }
      ],
      "sample_examples": [
        {
          "file": "samples/mr_sample_long_only.rts",
          "line": 12,
          "code": "SaveTradesAs:\t?scriptpath?\\mr_long.csv"
        },
        {
          "file": "samples/mr_sample_short_only.rts",
          "line": 10,
          "code": "SaveTradesAs:\t?scriptpath?\\mr_short.csv"
        },
        {
          "file": "samples/ndx_rotate_make_tradelist.rts",
          "line": 21,
          "code": "SaveTradesAs:\t?desktop?\\ndx_rotate.csv"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "SaveTradesType",
      "title": "SaveTradesType",
      "aliases": [],
      "section": "17.18.431",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "Format to use when creating the Save Trades As output file",
      "example": null,
      "notes": "Choices are Full or Compact.If Full is specified or if Save Trades Type is not specified, then all of the Trade List columns are written to the CSV file.If Compact is specified then the CSV file is written with only the fields required for Imported Trade List playback.Unlike some Scan and Test Settings, there is no Settings Panel equivalent for this particular option and the setting does not persist.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.431",
          "title": "SaveTradesType",
          "line": 5121
        }
      ],
      "sample_examples": [
        {
          "file": "samples/mr_sample_long_only.rts",
          "line": 13,
          "code": "SaveTradesType:\tCompact"
        },
        {
          "file": "samples/mr_sample_short_only.rts",
          "line": 11,
          "code": "SaveTradesType:\tCompact"
        },
        {
          "file": "samples/ndx_rotate_make_tradelist.rts",
          "line": 22,
          "code": "SaveTradesType:\tCompact"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Scan",
      "title": "Scan",
      "aliases": [],
      "section": "17.18.432",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Script Sections",
      "description": "Scan definition",
      "example": null,
      "notes": "See Scan Section for details.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.432",
          "title": "Scan",
          "line": 5123
        }
      ],
      "sample_examples": [
        {
          "file": "samples/annual_taxes.rts",
          "line": 19,
          "code": "TestOutput:\tScan"
        },
        {
          "file": "samples/beta_indicator.rts",
          "line": 26,
          "code": "Scan:"
        },
        {
          "file": "samples/bottomup/beta_indicator.rts",
          "line": 26,
          "code": "Scan:"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "ScanInclude",
      "title": "ScanInclude",
      "aliases": [],
      "section": "17.18.433",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Script Sections",
      "description": "Allows a script to include another script when run in Scan Mode",
      "example": null,
      "notes": "See the general-purpose Include statement for further details.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.433",
          "title": "ScanInclude",
          "line": 5125
        }
      ],
      "sample_examples": [],
      "grammar_match": true
    },
    {
      "name": "ScanNoDefCols",
      "title": "ScanNoDefCols",
      "aliases": [],
      "section": "17.18.434",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "Allows the default Date and Symbol columns to optionally be omitted from Scan Window and Save Scan As output",
      "example": null,
      "notes": "By default every scan begins with Date and Symbol columns, followed by the columns defined in the Scan section of the script. In certain cases you may want more control over this. This setting suppresses the Date and Symbol columns, so that only your columns are shown.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.434",
          "title": "ScanNoDefCols",
          "line": 5127
        }
      ],
      "sample_examples": [
        {
          "file": "samples/djia_make_syminfo.rts",
          "line": 17,
          "code": "ScanNoDefCols:\tTrue"
        },
        {
          "file": "samples/djia_use_syminfo.rts",
          "line": 19,
          "code": "ScanNoDefCols:\tTrue"
        },
        {
          "file": "samples/import_tiingo.rts",
          "line": 29,
          "code": "ScanNoDefCols:\tTrue"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "ScanNoHeader",
      "title": "ScanNoHeader",
      "aliases": [],
      "section": "17.18.435",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "Allows the header row to optionally be omitted from any Save Scan As output files",
      "example": null,
      "notes": "There is no way to suppress the column headers in a Scan Window, but this setting can be used if needed to create a CSV file with no header row.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.435",
          "title": "ScanNoHeader",
          "line": 5132
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "ScanNoWindow",
      "title": "ScanNoWindow",
      "aliases": [],
      "section": "17.18.436",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "Allows a Scan to create a CSV output file without also creating a Scan Window.",
      "example": null,
      "notes": "The purpose of this option is to allow large-scale data-generation scans to be run more quickly and with less memory usage.Save Scan As must be specified to use this setting.The Sort definition, if specified, is ignored in this scan mode.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.436",
          "title": "ScanNoWindow",
          "line": 5134
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "ScanSettings",
      "title": "ScanSettings",
      "aliases": [],
      "section": "17.18.437",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Script Sections",
      "description": "Defines the settings to use only when the script run mode is Scan.",
      "example": null,
      "notes": "The general-purpose Settings section is always applied first, then modified by any items specified in Scan Settings when applicable.See Settings Sections for details.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.437",
          "title": "ScanSettings",
          "line": 5136
        }
      ],
      "sample_examples": [
        {
          "file": "samples/cii_rotate.rts",
          "line": 44,
          "code": "ScanSettings:"
        },
        {
          "file": "samples/clenow_stocks_on_move.rts",
          "line": 75,
          "code": "ScanSettings:"
        },
        {
          "file": "samples/clenow_stocks_on_move_dynamic.rts",
          "line": 67,
          "code": "ScanSettings:"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "Select",
      "title": "Select",
      "aliases": [],
      "section": "17.18.438",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Conditional choice function",
      "example": ", the select expression is clearly simpler.If select finds no conditions that return non-zero (\"true\"), then the function returns Na N. This is different from if, which will never return Na N unless done explicitly as in the above .To make select always return a default value if no conditions match (as in the first select above), either make the final condition simply \"1\" (or any non-zero value)\u2026",
      "notes": "Select is similar to IF in that it provides a kind of conditional branch function. In fact, the following two statements are equivalent:\u00b7 if(cond1, value1, value2)\u00b7 select(cond1, value1, 1, value2) The purpose of select becomes more apparent when multiple if statements need to be nested:\u00b7 if(cond1, if(cond2, if(cond3, value3, Na N), value2), value1)\u00b7 select(cond1, value1, cond2, value2, cond3, value3) In this",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.438",
          "title": "Select",
          "line": 5138
        }
      ],
      "sample_examples": [
        {
          "file": "samples/actual_trades.rts",
          "line": 42,
          "code": "// this is one example of a IB flex query with too many columns selected"
        },
        {
          "file": "samples/anchored_vwap.rts",
          "line": 3,
          "code": "Typically the anchor is a price pivot selected visually on a chart."
        },
        {
          "file": "samples/bensdorp_book.rts",
          "line": 113,
          "code": "ExitRule:\t select(BarsHeld = 4, \"n-day\", BarsHeld > 0 and c < FillPrice * 0.96, \"target\")"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Sequence",
      "title": "Sequence",
      "aliases": [],
      "section": "17.18.439",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Look for a sequence of conditions within a specified number of bars",
      "example": "Look for a breakout to a new 100-day high followed by a pullback lasting at least 5 bars followed by another new high, all within the past 10 bars:",
      "notes": "Returns 1 (true) if condition1 and condition2 and any other conditions specified all occurred within the most recent count bars and occurred in the specified sequence.Returns 0 (false) otherwise.It does not matter how many bars separate the condition occurrences nor what happens during those intervening bars, only that these conditions occurred in this sequence within this many bars.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.439",
          "title": "Sequence",
          "line": 5143
        }
      ],
      "sample_examples": [
        {
          "file": "samples/mr_sample_test_scan.rts",
          "line": 47,
          "code": "SetupScore:\tATR5 / C // causes order list sequence to be the same as test scan sort order"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Settings",
      "title": "Settings",
      "aliases": [],
      "section": "17.18.440",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Script Sections",
      "description": "Defines the settings to apply each time the script runs.",
      "example": null,
      "notes": "Use the Settings section for all of your common settings. Use Scan Settings, Test Settings, and Order Settings as needed to override common settings for these specific run modes.See Settings Sections for details.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.440",
          "title": "Settings",
          "line": 5148
        }
      ],
      "sample_examples": [
        {
          "file": "samples/Sample1.rts",
          "line": 12,
          "code": "Settings:"
        },
        {
          "file": "samples/Sample2.rts",
          "line": 5,
          "code": "Settings:"
        },
        {
          "file": "samples/Sample2a.rts",
          "line": 5,
          "code": "Settings:"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "SetupRank",
      "title": "SetupRank",
      "aliases": [],
      "section": "17.18.441",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Current Position Information",
      "description": "Returns the rank number for this position when Setup Score was evaluated at entry time.",
      "example": null,
      "notes": "Setup Rank can be referred to in any non-entry-related strategy formula or in Qty Final.The setup ranking mechanism can be observed by running a test with Test Output: Log enabled.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.441",
          "title": "SetupRank",
          "line": 5150
        }
      ],
      "sample_examples": [
        {
          "file": "samples/multi_moc_top_down.rts",
          "line": 79,
          "code": "//\tStrategyScore:\t(SetupRank + strats - 1 - StratNum) % strats + 1\t// take turns going first each rank number"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "SetupScore",
      "title": "SetupScore",
      "aliases": [],
      "section": "17.18.442",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Ranks entry setups when a strategy has more setups than can be entered Input Numeric formula",
      "example": null,
      "notes": "Setups with higher scores are entered first. If Setup Score is not specified, setups will be ranked in alphabetical order by symbol. The number of positions that a strategy can enter per day is determined by evaluating the Max Setups, Max Entries, Max Invested and, Max Positions.For more information on how the backtest engine works in general, see Backtest Engine Details.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.442",
          "title": "SetupScore",
          "line": 5152
        }
      ],
      "sample_examples": [
        {
          "file": "samples/bensdorp_book.rts",
          "line": 101,
          "code": "SetupScore:\tc/c[200]"
        },
        {
          "file": "samples/clenow_stocks_on_move.rts",
          "line": 62,
          "code": "SetupScore:\tAdjSlope"
        },
        {
          "file": "samples/clenow_stocks_on_move_dynamic.rts",
          "line": 55,
          "code": "SetupScore:\tAdjSlope"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "SetupSkip",
      "title": "SetupSkip",
      "aliases": [],
      "section": "17.18.443",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Enables skipping a setup if a condition applies Input Any formula specifying a true/false condition (non-zero means true)",
      "example": null,
      "notes": "Setup Skip is evaluated during the top-down setup selection process. If the return value is true (non-zero) then this setup does not become an order and its slot is made available to another setup.This is in contrast to Entry Skip, which is not evaluated until the entry simulation phase of a backtest.See Back Test Engine Details for more information about how setup selection works.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.443",
          "title": "SetupSkip",
          "line": 5157
        }
      ],
      "sample_examples": [
        {
          "file": "samples/mr_sample_tracking.rts",
          "line": 10,
          "code": "SetupSkip:\tif(not IsTracker, Extern(@tracker, S.Equity < Avg(S.Equity, 150)), 0)"
        },
        {
          "file": "samples/oex_tf_auto_track.rts",
          "line": 62,
          "code": "SetupSkip:\tif(IsTracker, 0, Extern(@tracker, srank > maxrank))"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "SetupSum",
      "title": "SetupSum",
      "aliases": [],
      "section": "17.18.444",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Evaluates an expression for each setup and returns the sum of the values",
      "example": null,
      "notes": "This is a specialized function meant to be used in entry-related formulas that want to the sum of something across all current setups.Setup Sum(1) returns the count of today's setups, which is not yet available in S.Setups at position entry time.Use Order Sum to count or calculate something for non-skipped setups only.Note that Setup Sum cannot be used to refer to past setups in a strategy. It only has access to setups for the current date in the test. Therefore Setup Sum(expression)[offset] will probably not have meaningful results.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.444",
          "title": "SetupSum",
          "line": 5159
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Shares",
      "title": "Shares or Contracts",
      "aliases": [
        "Contracts"
      ],
      "section": "17.18.445",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Current Position Information",
      "description": "Returns the number of shares or contracts held in the current position",
      "example": null,
      "notes": "This element can be referred to as either Shares or Contracts, regardless of the type of instrument being traded.The number returned is the number of shares (or contracts) held in the current position for the current strategy only. To get the number of shares of the current symbol held in a different strategy, use Extern(strategy_name, Shares).To get the number of shares of the current symbol held in all strategies, use Combined(Shares).Shares is always a positive number, regardless of the side (long vs. short) of the position. Multiply Shares by Side if you need the sign of the result to\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.445",
          "title": "Shares or Contracts",
          "line": 5161
        }
      ],
      "sample_examples": [
        {
          "file": "samples/actual_trades.rts",
          "line": 63,
          "code": "TLFields:\tSymbol,strategy,DateIn,PriceIn,DateOut,PriceOut,,,,Shares"
        },
        {
          "file": "samples/bensdorp_book.rts",
          "line": 89,
          "code": "QtyType:\tShares"
        },
        {
          "file": "samples/bottomup/actual_trades.rts",
          "line": 63,
          "code": "TLFields:\tSymbol,strategy,DateIn,PriceIn,DateOut,PriceOut,,,,Shares"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "ShortLoanIntPct",
      "title": "ShortLoanIntPct",
      "aliases": [],
      "section": "17.18.446",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "Annualized interest rate paid for daily value of short stock positions (short borrow fee rate).",
      "example": null,
      "notes": "Daily short borrow fees are subtracted from combined S.Equity and therefore become part of the total return of the backtest.Use Short Prcds Int Pct to specify interest received for the cash value of short positions, if applicable to your broker.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.446",
          "title": "ShortLoanIntPct",
          "line": 5166
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "ShortPrcdsIntPct",
      "title": "ShortPrcdsIntPct",
      "aliases": [],
      "section": "17.18.447",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "Interest rate received for value of proceeds from short stock positions held in the account.",
      "example": null,
      "notes": "If the settings also provide a Risk Free Rate Sym then Short Prcds Int Pct is added to the current daily interest rate as determined by today's value of the risk-free rate series. In this case, Short Prcds Int Pct would typically be negative, e.g. -0.5 if your broker pays 0.5% less than the fed funds rate (with floor of zero).If Short Prcds Int Pct is provided when there is no Risk Free Rate Sym then Short Prcds Int Pct is simply a fixed annual interest rate.Daily net interest received or paid is added to combined S.Equity and therefore becomes part of the total return of the backtest.The\u2026",
      "see_also": [
        "Cash Int Pct",
        "Margin Int Pct",
        "and Short Loan Int Pct."
      ],
      "manual_refs": [
        {
          "section": "17.18.447",
          "title": "ShortPrcdsIntPct",
          "line": 5168
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Side (position",
      "title": "Side (position)",
      "aliases": [],
      "section": "17.18.448",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Current Position Information",
      "description": "Position side",
      "example": null,
      "notes": "Returns 1 for a long position or -1 for a short position.Multiply Shares or Fill Value by Side if you want them to be negative for short positions.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.448",
          "title": "Side (position)",
          "line": 5172
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Side (strategy",
      "title": "Side (strategy)",
      "aliases": [],
      "section": "17.18.449",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Defines the side (long vs. short) on which a strategy will take positions Choices Long - all entries are long buys Short - all entries are short sales Both - entries can be either long or short (default)",
      "example": null,
      "notes": "In most cases, it is best to use side-specific strategies when modeling a multi-strategy trading system.Both-way strategies are mainly useful for special needs such as hedging a long/short strategy pair using an index.When Side is not specified, the sign of the value of Quantity is used to determine the side of each entry.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.449",
          "title": "Side (strategy)",
          "line": 5174
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Sign",
      "title": "Sign",
      "aliases": [],
      "section": "17.18.450",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Returns the sign of a number",
      "example": null,
      "notes": "Returns 1 if the number is positive, -1 if the number is negative, or 0 if the number is 0.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.450",
          "title": "Sign",
          "line": 5176
        }
      ],
      "sample_examples": [
        {
          "file": "samples/cii_rotate.rts",
          "line": 26,
          "code": "// ListNum 99 is asigned to the automatically-imported index ETFs"
        },
        {
          "file": "samples/combined_multi_bar_size.rts",
          "line": 3,
          "code": "see also combined.rts, which implements this same set of strategies using daily bars and EndOfWeek / EndOfMonth signals"
        },
        {
          "file": "samples/correl_multi.rts",
          "line": 4,
          "code": "It is not recommended to try this on significantly larger datasets"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "SigSpike",
      "title": "SigSpike",
      "aliases": [],
      "section": "17.18.451",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Indicator Functions",
      "description": "Adam Grimes' Sigma Spike indicator",
      "example": null,
      "notes": "Sigma Spike is defined as ROC(C,1) / Std Dev(ROC(C,1),len)[1].",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.451",
          "title": "SigSpike",
          "line": 5180
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "SinceHigh",
      "title": "SinceHigh",
      "aliases": [],
      "section": "17.18.452",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Count of bars since the highest value of an expression in a number of bars",
      "example": null,
      "notes": "If today's value is the highest (largest) value in count days, the function returns 0. If the high was yesterday, the return value is 1, and so on.If there are multiple instances of the highest value then the most recent one is used.This function supports one-pass calculation when used in the Data Section with a non-variable count.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.452",
          "title": "SinceHigh",
          "line": 5182
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "SinceLow",
      "title": "SinceLow",
      "aliases": [],
      "section": "17.18.453",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Count of bars since the lowest value of an expression in a number of bars",
      "example": null,
      "notes": "If today's value is the lowest (smallest) value in count days, the function returns 0. If the high was yesterday, the return value is 1, and so on.If there are multiple instances of the lowest value then the most recent one is used.This function supports one-pass calculation when used in the Data Section with a non-variable count.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.453",
          "title": "SinceLow",
          "line": 5184
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "SinceTrue",
      "title": "SinceTrue",
      "aliases": [],
      "section": "17.18.454",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Count of bars since a condition was last true",
      "example": null,
      "notes": "Condition will be evaluated for the most recent bar first, then proceed back in time until a non-zero value is found or count bars have been checked, whichever comes first.For each bar, condition is evaluated as if that bar were the current bar, i.e. without knowledge of future splits relative to that bar.If count is omitted then there is no maximum (all bars before this one are potentially checked).If condition was never true, the return value is -1.If condition is currently true, the return value is 0.If condition was most recently true yesterday, the return value is 1, and so on.This\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.454",
          "title": "SinceTrue",
          "line": 5189
        }
      ],
      "sample_examples": [
        {
          "file": "samples/annual_taxes.rts",
          "line": 12,
          "code": "SinceEOY:\tif(EndOfYear, SinceTrue(EndOfYear)[1], 0)"
        },
        {
          "file": "samples/dividend_capture.rts",
          "line": 9,
          "code": "ExcludeIf:\tsincetrue(Dividend > 0.2 and C < 100) < 0\t// evaluated for latest bar so need explicit split-unadjustment"
        },
        {
          "file": "samples/higher_lows.rts",
          "line": 26,
          "code": "since1:\tsincetrue(pivot) // bars since most recent pivot (can use one-pass)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Sine",
      "title": "Sine",
      "aliases": [],
      "section": "17.18.455",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Trigonometric sine of a number of degrees",
      "example": null,
      "notes": "The parameter value is assumed to be degrees (0-360).To convert radians to degrees, multiply by 57.2957795131 (180/\u03c0).",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.455",
          "title": "Sine",
          "line": 5191
        }
      ],
      "sample_examples": [
        {
          "file": "samples/ehlers_windows.rts",
          "line": 21,
          "code": "hammfunc:\tSine(pedestal + (180 - 2 * pedestal) * (FunBar-1) / (len-1))"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Skewness",
      "title": "Skewness",
      "aliases": [],
      "section": "17.18.456",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Statistical measure of the lopsidedness of a distribution of values",
      "example": null,
      "notes": "Skewness is calculated in the same way that Excel calculates the SKEW.P function, which is as if the set of count values is the entire population.The specific formula used is shown below, in the \"skew\" item: This also illustrates how these statistical functions could be calculated in the Data Section of a script, though since they're provided built-in, there's no reason to do so.This function supports one-pass calculation when used in the Data Section with a non-variable count.",
      "see_also": [
        "Std Dev and Kurtosis."
      ],
      "manual_refs": [
        {
          "section": "17.18.456",
          "title": "Skewness",
          "line": 5196
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "SkipTestIf",
      "title": "SkipTestIf",
      "aliases": [],
      "section": "17.18.457",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "Formula with condition which, if true, causes an entire test to be skipped",
      "example": ", if you were optimizing a simple RSI or Stochastics crossover strategy, you might use something like this: Without the Skip Test If filter, there would be 81 tests, including many \"illogical\" combinations (albeit perhaps interesting to test these...) Adding the filter as shown above reduces the actual test count to 45 by eliminating the tests that don't \"make sense\" for this strategy idea.This\u2026",
      "notes": "This special formula in Test Settings is meant to be used when running optimizations.As an",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.457",
          "title": "SkipTestIf",
          "line": 5199
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Slippage",
      "title": "Slippage",
      "aliases": [],
      "section": "17.18.458",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Slippage amount, in points (dollars per share or contract), for each transaction Input Any formula specifying dollars per share or contract (points)",
      "example": "for less liquid futures, would be: Max(2 * Tick Size, 0.02 * ATR(5)), meaning \"2 ticks or 2% of daily average true range, whichever is greater\".A more complex for less liquid stocks would be: Max(0.05, 0.002 * Fill Price, 0.1 * Shares / Volume), meaning \"0.05/share or 0.2% of price or 10% of the ratio of your shares to the total daily volume, whichever is greater\".",
      "notes": "Defines the amount of slippage to apply to to each transaction, in price points. Slippage is calculated and applied to each side of the trade (entry and exit) separately.If Fill Price is used in the Slippage formula, it automatically retrieves the entry price for entry slippage and the exit price for exit slippage calculation.Slippage, if specified, is applied by default to every transaction, regardless of order type (market, stop or limit) or time (open, intraday or close).To specify a different slippage amount for limit-order transactions (fills at a limit price), use Limit Slip.To specify\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.458",
          "title": "Slippage",
          "line": 5204
        }
      ],
      "sample_examples": [
        {
          "file": "samples/bensdorp_book.rts",
          "line": 92,
          "code": "Slippage:\t0.002 * FillPrice\t// slippage for non-limit orders"
        },
        {
          "file": "samples/es_compare.rts",
          "line": 25,
          "code": "Slippage:\tTickSize"
        },
        {
          "file": "samples/futures_trend_follow_csi.rts",
          "line": 39,
          "code": "Slippage:\t2 * TickSize\t// 2 ticks each way"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Slope",
      "title": "Slope",
      "aliases": [],
      "section": "17.18.459",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Linear regression slope",
      "example": null,
      "notes": "Calculates the slope of a linear regression of expr evaluated for the previous count bars.",
      "see_also": [
        "Lin Reg and YInt."
      ],
      "manual_refs": [
        {
          "section": "17.18.459",
          "title": "Slope",
          "line": 5210
        }
      ],
      "sample_examples": [
        {
          "file": "samples/beta_indicator.rts",
          "line": 18,
          "code": "beta:\tslope(roc1, indroc1, len)"
        },
        {
          "file": "samples/bottomup/beta_indicator.rts",
          "line": 18,
          "code": "beta:\tslope(roc1, indroc1, len)"
        },
        {
          "file": "samples/clenow_stocks_on_move.rts",
          "line": 30,
          "code": "// AdjSlope calculation (#SlowCalc is required because log(c) of unadjusted prices can't be buffered)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Spearman",
      "title": "Spearman",
      "aliases": [],
      "section": "17.18.460",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Spearman Rank Correlation of two series of this approach to correlation.This implementation handles ties correctly. Output will match Python scipy.spearmanr.A typical use case is this indicator, i.e., 100 * Spearman(C, Fun Bar, 10).",
      "example": null,
      "notes": "See this link for a general",
      "see_also": [
        "Correl",
        "Correl Avg",
        "etc."
      ],
      "manual_refs": [
        {
          "section": "17.18.460",
          "title": "Spearman",
          "line": 5212
        }
      ],
      "sample_examples": [
        {
          "file": "samples/correl_multi.rts",
          "line": 26,
          "code": "corr_djia:\tif (sprmn, Correl(factor, djia, len), Spearman(factor, djia, len))"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Split",
      "title": "Split",
      "aliases": [],
      "section": "17.18.461",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Bar Data Values",
      "description": "Current bar split factor",
      "example": null,
      "notes": "The split factor of a past bar is defined as the as-traded price divided by the split-adjusted price (unadjusted/adjusted).If no stock splits have occurred since the date of the past bar, the split factor is therefore 1.0.Therefore, if split is not 1.0, it means there will be splits in the future relative to the current bar being evaluated.Since Real Test always provides price or volume values \"as-traded\" (unadjusted), and multi-bar indicators adjusted for past splits (to avoid distortion) but not future ones, there is rarely a need to explicitly refer to a bar's split factor.Care must be\u2026",
      "see_also": [
        "Split Handling."
      ],
      "manual_refs": [
        {
          "section": "17.18.461",
          "title": "Split",
          "line": 5214
        }
      ],
      "sample_examples": [
        {
          "file": "samples/actual_trades.rts",
          "line": 58,
          "code": "// AB trade prices are split-adjusted, so use TLAdjusted to tell RT to unadjust them"
        },
        {
          "file": "samples/bottomup/actual_trades.rts",
          "line": 58,
          "code": "// AB trade prices are split-adjusted, so use TLAdjusted to tell RT to unadjust them"
        },
        {
          "file": "samples/dividend_capture.rts",
          "line": 9,
          "code": "ExcludeIf:\tsincetrue(Dividend > 0.2 and C < 100) < 0\t// evaluated for latest bar so need explicit split-unadjustment"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Sqr",
      "title": "Sqr",
      "aliases": [],
      "section": "17.18.462",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Square Root of a number",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.462",
          "title": "Sqr",
          "line": 5218
        }
      ],
      "sample_examples": [
        {
          "file": "samples/spy_tlt_uis.rts",
          "line": 17,
          "code": "Sharpe:\t \t\t{#2} SQR(252)*Avg(S.NetPct,Periods)/(StdDev(S.NetPct,Periods)^2)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "StartDate (Import",
      "title": "StartDate (Import)",
      "aliases": [],
      "section": "17.18.463",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Import Specification",
      "description": "The first date to include in a data import Choices Date Constant - a literal date Earliest - 1/1/1990 or the oldest available date, which ever is more recent",
      "example": null,
      "notes": "To start an import with a date earlier than 1/1/1990, use the desired date rather than Earliest. (The actual earliest data date can't be known until the import is completed.) The default interpretation of Earliest can be changed if desired by editing Real Test.ini (when RT is not running) and changing Earliest Import Year.",
      "see_also": [
        "End Date and Num Bars."
      ],
      "manual_refs": [
        {
          "section": "17.18.463",
          "title": "StartDate (Import)",
          "line": 5220
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "StartDate (Setting",
      "title": "StartDate (Setting)",
      "aliases": [],
      "section": "17.18.464",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "The first date to include in a scan or test Choices Date Constant - a literal date Earliest - the oldest date of any symbol in the current data file",
      "example": null,
      "notes": "If a date range is not specified in a script then the dates from the Settings Panel will be used.If Date Sym is specified then Earliest means the oldest date of that specific symbol.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.464",
          "title": "StartDate (Setting)",
          "line": 5225
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "StartPercent",
      "title": "StartPercent",
      "aliases": [],
      "section": "17.18.465",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Percent of initial Account Size to give to this strategy Input Any formula specifying a percentage",
      "example": null,
      "notes": "Both S.Start Equity and the initial value of S.Equity for the strategy will be this percentage of the initial account size.The default Start Percent is 100. This models each strategy having the entire account at its disposal.Specifying Start Percent less than 100 is useful when modeling strategies running in separate accounts. In this case *Account Size* would be the sum of your initial account values and Start Percent would specify the relative percent sizes of each sub-account.When using Start Percent: 100 (or not using it since this is the default), multiple strategies should apply their\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.465",
          "title": "StartPercent",
          "line": 5227
        }
      ],
      "sample_examples": [
        {
          "file": "samples/annual_taxes.rts",
          "line": 30,
          "code": "StartPercent:\t0"
        },
        {
          "file": "samples/combined_rebalance.rts",
          "line": 24,
          "code": "StartPercent:\t30"
        },
        {
          "file": "samples/management_fees.rts",
          "line": 31,
          "code": "StartPercent:\t0 // graphs descending from $0"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "StatsGroup",
      "title": "StatsGroup",
      "aliases": [],
      "section": "17.18.466",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Script Sections",
      "description": "Defines a group of strategies to combine for test statistics reporting and for application of multi-strategy constraints such as Max Exposure, Max Invested, Max Positions, etc.",
      "example": null,
      "notes": "The strategies in a Stats Group are specified with the Using statement.Stats Groups can include Strategies or Benchmarks but cannot include other Stats Groups.A Strategy or Benchmark can be included in any number of Stats Groups.See Special Strategy Types for details.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.466",
          "title": "StatsGroup",
          "line": 5229
        }
      ],
      "sample_examples": [
        {
          "file": "samples/bensdorp_book.rts",
          "line": 169,
          "code": "StatsGroup: Longs"
        },
        {
          "file": "samples/namespace_example.rts",
          "line": 101,
          "code": "//StatsGroup: _vxx_shorting"
        },
        {
          "file": "samples/oc_all_actual.rts",
          "line": 50,
          "code": "StatsGroup: Longs"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "StatsIncludeCash",
      "title": "StatsIncludeCash",
      "aliases": [],
      "section": "17.18.467",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "Whether to include cash deposits and withdrawals (from Cash In Out or Cash List) in percent-based test stats Choices False - exclude cash from stats (stats are \"time weighted\") True - include cash in stats (stats are \"net of cash\")",
      "example": "script can be used to apply and report management fees by simply including it at the end of any other script.",
      "notes": "Use False (the default) to see your \"pure\" trading stats independent of cash withdrawals or deposits (e.g. for taxes).Use True to see trading stats that treat cash transactions like trading gains or losses (e.g. for client \"net of fees\" stats).The management_fees.rts",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.467",
          "title": "StatsIncludeCash",
          "line": 5234
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "StdDev",
      "title": "StdDev",
      "aliases": [],
      "section": "17.18.468",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Statistical measure of the variance of a distribution of values",
      "example": null,
      "notes": "Std Dev is calculated in the same way that Excel calculates the STDEV.P function, which is as if the set of count values is the entire population.The specific formula used is shown below, in the \"sdev\" item: This also illustrates how these statistical functions could be calculated in the Data Section of a script, though since they're provided built-in, there's no reason to do so.This function supports one-pass calculation when used in the Data Section with a non-variable count.",
      "see_also": [
        "Skewness and Kurtosis."
      ],
      "manual_refs": [
        {
          "section": "17.18.468",
          "title": "StdDev",
          "line": 5236
        }
      ],
      "sample_examples": [
        {
          "file": "samples/spy_tlt_uis.rts",
          "line": 17,
          "code": "Sharpe:\t \t\t{#2} SQR(252)*Avg(S.NetPct,Periods)/(StdDev(S.NetPct,Periods)^2)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "StdErr",
      "title": "StdErr",
      "aliases": [],
      "section": "17.18.469",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Standard error of predicted vs. actual values in a regression",
      "example": null,
      "notes": "For each value in the expr data series formula, the Slope and YInt are calculated for count values.Each expr value is then compared to the predicted value of that point on the line thus defined.The Std Error is the square root of the sum of squared differences between actual expr values and Lin Reg predictions.This function is equivalent to =STEYX in Excel.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.469",
          "title": "StdErr",
          "line": 5241
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "STOC",
      "title": "STOC",
      "aliases": [],
      "section": "17.18.470",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Indicator Functions",
      "description": "Stochastics Indicator",
      "example": null,
      "notes": "The Stochastic Oscillator measures the position of a value in a range of similar values, with optional smoothing.STOC(len, avg) could also be expressed as 100 * Avg((C - Lowest(L, len)) / (Highest(H, len) - Lowest(L, len)), avg).STOC(1,1) is therefore a simple way to calculate \"Internal Bar Strength\", i.e., 100*(C-L)/(H-L).In case you're looking for the \"Williams %R\" indicator, that is simply -1 * (100 - STOC(len, 1)).",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.470",
          "title": "STOC",
          "line": 5245
        }
      ],
      "sample_examples": [
        {
          "file": "samples/bensdorp_book.rts",
          "line": 2,
          "code": "the set of strategies described in \"Automated Stock Trading Systems\" by Laurens Bensdorp"
        },
        {
          "file": "samples/beta_indicator.rts",
          "line": 19,
          "code": "// beta is simply the linear regression slope of a stock's returns vs. index returns"
        },
        {
          "file": "samples/bottomup/beta_indicator.rts",
          "line": 19,
          "code": "// beta is simply the linear regression slope of a stock's returns vs. index returns"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "StopSlip",
      "title": "StopSlip",
      "aliases": [],
      "section": "17.18.471",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Slippage amount, in points (dollars per share or contract), for each stop order transaction Input Any formula specifying dollars per share or contract (points)",
      "example": null,
      "notes": "Defines the amount of slippage to apply to to each stop order transaction, in price points. Stop Slip is applied to any transaction that occurs at an Entry Stop or Exit Stop price.If Stop Slip is not specified then Slippage is applied instead.When a strategy uses both Entry Stop and Entry Limit (enters positions with a stop-limit order) and the fill is at the limit price, Limit Slip is applied.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.471",
          "title": "StopSlip",
          "line": 5249
        }
      ],
      "sample_examples": [
        {
          "file": "samples/keltner_pullback.rts",
          "line": 46,
          "code": "//\tStopSlip:\tTrigger * 0.001"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "StratData",
      "title": "StratData",
      "aliases": [],
      "section": "17.18.472",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Script Sections",
      "description": "Named formulas calculated and stored in memory arrays for each strategy each date while tests are run .",
      "example": null,
      "notes": "See Test Data and Strat Data Sections for a more detailed",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.472",
          "title": "StratData",
          "line": 5251
        }
      ],
      "sample_examples": [
        {
          "file": "samples/management_fees.rts",
          "line": 13,
          "code": "StratData:"
        },
        {
          "file": "samples/oex_tf_auto_track.rts",
          "line": 3,
          "code": "Uses automatic \"tracker\" benchmarks and StratData to rank recent performance."
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Strategy",
      "title": "Strategy",
      "aliases": [],
      "section": "17.18.473",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Script Sections",
      "description": "Defines a trading strategy",
      "example": null,
      "notes": "See Strategy Section for details.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.473",
          "title": "Strategy",
          "line": 5253
        }
      ],
      "sample_examples": [
        {
          "file": "samples/Sample1.rts",
          "line": 18,
          "code": "Strategy: SPY_Crossover"
        },
        {
          "file": "samples/Sample2.rts",
          "line": 15,
          "code": "Strategy: SPY_Crossover"
        },
        {
          "file": "samples/Sample2a.rts",
          "line": 16,
          "code": "Strategy: SPY_Crossover"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "StrategyScore",
      "title": "StrategyScore",
      "aliases": [],
      "section": "17.18.474",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Provides a value to use for this strategy when ranking all strategies to determine setup prioritization in top-down mode Input Numeric formula",
      "example": "if the only constraint is e.g. Combined: Max Exposure: 100, then Strategy Score will play a large role in deciding which strategy or set of strategies are most likely to receive that exposure.Strategy Score also gains significance when Max Per Turn is used to allow a strategy to select all of its setups on its first turn, or more than one setup per turn.Use the multi_moc_top_down.rts and\u2026",
      "notes": "Strategy Score is evaluated for each strategy at each turn of the setup selection process.The strategy with the highest score gets first choice to add its next setup(s) at that step.If Strategy Score is not provided, the default is simply the negative strategy number (first strategy gets top rank, then second, etc.) Typically all strategies will use the same score formula (use a shared Template if so) though this is not a requirement.Here are some examples of common Strategy Score formulas:\u00b7 Strat Num // highest strategy number (reverse script order)\u00b7 -S.Positions // fewest open positions\u00b7\u2026",
      "see_also": [
        ": Backtest Engine Details and Capacity Constraints"
      ],
      "manual_refs": [
        {
          "section": "17.18.474",
          "title": "StrategyScore",
          "line": 5255
        }
      ],
      "sample_examples": [
        {
          "file": "samples/multi_moc_top_down.rts",
          "line": 76,
          "code": "// example StrategyScore formulas to play with"
        },
        {
          "file": "samples/oex_tf_top_down.rts",
          "line": 41,
          "code": "StrategyScore:\tROC(S.Equity,20)\t// best recent performance (m2m)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "StratNum",
      "title": "StratNum",
      "aliases": [],
      "section": "17.18.475",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Current Strategy Information",
      "description": "Ordinal number of the current strategy in the script",
      "example": null,
      "notes": "This can be useful in a Strategy Score formula.",
      "see_also": [
        "?Strategy",
        "which returns the current strategy name",
        "and Strat Ref",
        "which allows dynamic strategy lookup."
      ],
      "manual_refs": [
        {
          "section": "17.18.475",
          "title": "StratNum",
          "line": 5274
        }
      ],
      "sample_examples": [
        {
          "file": "samples/multi_moc_top_down.rts",
          "line": 77,
          "code": "//\tStrategyScore:\t-StratNum\t// lowest strategy number (default if not specified)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "StratRef",
      "title": "StratRef",
      "aliases": [],
      "section": "17.18.476",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Find the number of a given strategy, and/or allow dynamic external symbol usage",
      "example": null,
      "notes": "If the current strategy is \"mr_long\", then @mr_long, Strat Num, Strat Ref(Strat Num), Strat Ref(?Strategy), and Strat Ref(\"mr_long\") will each return the same number.Strat Ref can also be used as the first argument to Extern, for cases where you need to dynamically refer to other strategies.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.476",
          "title": "StratRef",
          "line": 5276
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Sum",
      "title": "Sum",
      "aliases": [],
      "section": "17.18.477",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Sum of values",
      "example": null,
      "notes": "Evaluates expr for each of count bars and returns the sum of the values.This function supports one-pass calculation when used in the Data Section with a non-variable count.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.477",
          "title": "Sum",
          "line": 5281
        }
      ],
      "sample_examples": [
        {
          "file": "samples/actual_trades.rts",
          "line": 39,
          "code": "TradeList:\tib_log.csv // change to your actual file (assumes Order Ref contains strategy name)"
        },
        {
          "file": "samples/annual_taxes.rts",
          "line": 13,
          "code": "LTGain:\t#OnePerDate if(SinceEOY > 0, Combined(TradeStatSum(if(DateYear(T.DateOut) = This(Year) and Days(T.DateIn, T.DateOut) > 366, T.Profit - T.Div, 0))), 0)"
        },
        {
          "file": "samples/bottomup/actual_trades.rts",
          "line": 39,
          "code": "TradeList:\tib_log.csv // change to your actual file (assumes Order Ref contains strategy name)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "SumSince",
      "title": "SumSince",
      "aliases": [],
      "section": "17.18.478",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Sum of values since a condition was last true, or until it becomes true",
      "example": null,
      "notes": "For each bar until condition is true, expression is evaluated and added to the sum.The sum does not include the value of expression for the bar where the condition becomes true.If condition is immediately true, the result is 0.If nth is positive, condition is evaluated for the most recent bar, then continues back in time until the nth non-zero value is found.If nth is negative, condition will be evaluated for the most recent bar, then continues forward in time until the abs(nth) non-zero value is found. If nth is not specified, the default is 1.Count most be provided if nth is to be provided\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.478",
          "title": "SumSince",
          "line": 5283
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "SumSQ",
      "title": "SumSQ",
      "aliases": [],
      "section": "17.18.479",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Sum of squared values",
      "example": null,
      "notes": "Evaluates expr for each of count bars and returns the sum of the squares of the values.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.479",
          "title": "SumSQ",
          "line": 5288
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "SuperTrend",
      "title": "SuperTrend",
      "aliases": [],
      "section": "17.18.480",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Indicator Functions",
      "description": "Olivier Seban's Super Trend indicator",
      "example": null,
      "notes": "Super Trend is like a trailing stop above or below typical price.Typical price (TP) is (H + L) / 2.The trend line is TP +/- ATR(len) * mult.When TP crosses above trend, trend flips to TP - ATR * mult.When TP crosses below trend, trend flips to TP + ATR * mult.Trend direction is therefore defined by whether TP is above or below trend.ATR is calculated using Wilder's smoothing.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.480",
          "title": "SuperTrend",
          "line": 5290
        }
      ],
      "sample_examples": [
        {
          "file": "samples/supertrend.rts",
          "line": 2,
          "code": "Old SuperTrend Indicator Example (prior to build-in indicator being added)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Switch",
      "title": "Switch",
      "aliases": [],
      "section": "17.18.481",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Value switch function",
      "example": "would return nan if there were no matches.Arguments can be numeric or strings. If strings then comparison is case-insensitive.",
      "notes": "Switch(Symbol, $AAPL, 1, $GOOGL, 2, $MSFT, 3) is equivalent to:Select(Symbol = $AAPL, 1, Symbol = $GOOGL, 2, Symbol = $MSFT, 3)or to:if(Symbol = $AAPL, 1, if(Symbol = $GOOGL, 2, if(Symbol = $MSFT, 3))) As with Select, the final match, value pair can be replaced by a single value to specify what to return if there are no matches, e.g.Switch(Symbol, $AAPL, 1, $GOOGL, 2, 3)would return 3 for all other symbols, whereas the prior",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.481",
          "title": "Switch",
          "line": 5295
        }
      ],
      "sample_examples": [
        {
          "file": "samples/mr_sample_tracking_alloc.rts",
          "line": 2,
          "code": "whereas mr_sample_tracking.rts uses these curves as on/off switches"
        },
        {
          "file": "samples/weekly_moc_asx_daily_daily.rts",
          "line": 32,
          "code": "// switch back to daily for the following"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Symbol",
      "title": "Symbol",
      "aliases": [],
      "section": "17.18.482",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Stock/Contract Information",
      "description": "Numeric code for the symbol of the current security",
      "example": null,
      "notes": "The value returned is the alphabetical ordinal number of the symbol in the currently loaded Data File. You don't need to know the actual number to use it. Use constant Symbol References like $MSFT to compare specific symbols to the value of this variable.",
      "see_also": [
        "?Symbol",
        "which returns the current symbol as a string",
        "and Sym Ref",
        "which allows dynamic symbol lookup.?Symbol = \"MSFT\" and Symbol = $MSFT would both accomplish the same purpose",
        "but it is slightly more efficient to use symbol constants. Symbol constants also have the advantage of smart auto-complete when entering them."
      ],
      "manual_refs": [
        {
          "section": "17.18.482",
          "title": "Symbol",
          "line": 5297
        }
      ],
      "sample_examples": [
        {
          "file": "samples/actual_trades.rts",
          "line": 4,
          "code": "(note that some Symbols may not be found, due to mergers or Symbol changes since list was created)"
        },
        {
          "file": "samples/annual_taxes.rts",
          "line": 23,
          "code": "Filter:\tEndOfYear and Symbol = $SPY // change as needed or always import SPY"
        },
        {
          "file": "samples/bensdorp_book.rts",
          "line": 165,
          "code": "EntrySetup:\tSymbol = $SPY and c = llv(c,50)"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "SymChangeList",
      "title": "SymChangeList",
      "aliases": [],
      "section": "17.18.483",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "Specifies the path to a CSV file containing a list of symbol changes to use when processing imported trade lists",
      "example": "of a Sym Changes.csv file used for trade lists: Here is an excerpt from the default ibfutures_ndu.csv file that is included with Real Test in the Examples folder: To correctly generate orders for IB futures trades using Norgate futures data, it is necessary to use this list. Edit as needed for other data sources and/or futures markets.To use this list, either rename it as Sym Changes.csv or add\u2026",
      "notes": "This feature is provided as an optional alternative to editing old trade lists themselves.The default if not specified is symchanges.csv in (a) the current Order Clerk Folder or (b) the Real Test installation folder.It is not necessary to use the Sym Change List for trade list symbols which have since been delisted. When using Norgate Data with delisted stocks included, Real Test will automatically find the delisted version of such symbols, e.g. CATM would be found as CATM-202105, assuming that the trade occurred before that date.The Sym Change List file has two required and two optional\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.483",
          "title": "SymChangeList",
          "line": 5302
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "SymInfoFile",
      "title": "SymInfoFile",
      "aliases": [],
      "section": "17.18.484",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Import Specification",
      "description": "Specifies a symbol information file to be used during data import Input Path to a symbol information file.",
      "example": null,
      "notes": "See Symbol Information File for details.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.484",
          "title": "SymInfoFile",
          "line": 5308
        }
      ],
      "sample_examples": [
        {
          "file": "samples/breadth.rts",
          "line": 10,
          "code": "SymInfoFile:\t?scriptpath?\\spx_syminfo.csv"
        },
        {
          "file": "samples/djia_earnings.rts",
          "line": 10,
          "code": "SymInfoFile:\t?scriptpath?\\djia_info.csv"
        },
        {
          "file": "samples/djia_use_syminfo.rts",
          "line": 5,
          "code": "note that when using Norgate you never need a SymInfoFile because this metadata is imported automatically"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "SymRef",
      "title": "SymRef",
      "aliases": [],
      "section": "17.18.485",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Find the number of a given symbol, and/or allow dynamic external symbol usage",
      "example": null,
      "notes": "If the current symbol is MSFT, then $MSFT, Symbol, Sym Ref(Symbol), Sym Ref(?Symbol), and Sym Ref(\"MSFT\") will each return the same number.Sym Ref can also be used as the first argument to Extern, for cases where you need to dynamically refer to other symbols.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.485",
          "title": "SymRef",
          "line": 5310
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "T.Bars",
      "title": "T.Bars",
      "aliases": [],
      "section": "17.18.486",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Record Items",
      "description": "Duration of a trade in bars",
      "example": null,
      "notes": "Entry and exit the same bar has duration of 0.Trade duration in days depends on the Bar Size used to run the test.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.486",
          "title": "T.Bars",
          "line": 5315
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "T.CommIn",
      "title": "T.CommIn",
      "aliases": [],
      "section": "17.18.487",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Record Items",
      "description": "Commission paid for the entry transaction of a trade, in dollars",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.487",
          "title": "T.CommIn",
          "line": 5317
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "T.CommOut",
      "title": "T.CommOut",
      "aliases": [],
      "section": "17.18.488",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Record Items",
      "description": "Commission paid for the exit transaction of a trade, in dollars",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.488",
          "title": "T.CommOut",
          "line": 5319
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "T.DateIn",
      "title": "T.DateIn",
      "aliases": [],
      "section": "17.18.489",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Record Items",
      "description": "Entry date of a trade as a number in yyyymmdd format",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.489",
          "title": "T.DateIn",
          "line": 5321
        }
      ],
      "sample_examples": [
        {
          "file": "samples/annual_taxes.rts",
          "line": 13,
          "code": "LTGain:\t#OnePerDate if(SinceEOY > 0, Combined(TradeStatSum(if(DateYear(T.DateOut) = This(Year) and Days(T.DateIn, T.DateOut) > 366, T.Profit - T.Div, 0))), 0)"
        },
        {
          "file": "samples/ndx_plus_wtf_script.rts",
          "line": 64,
          "code": "Stop:\tif(T.Strat = 2 and BarDate>=T.DateIn and BarDate <= T.DateOut, wtf_trail, nan)"
        },
        {
          "file": "samples/trend_following_basics.rts",
          "line": 82,
          "code": "Stop: if(BarDate>=T.DateIn and BarDate <= T.DateOut, trailStop, nan) // only plots the line during when the trade was open"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "T.DateOut",
      "title": "T.DateOut",
      "aliases": [],
      "section": "17.18.490",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Record Items",
      "description": "Exit date of a trade as a number in yyyymmdd format",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.490",
          "title": "T.DateOut",
          "line": 5325
        }
      ],
      "sample_examples": [
        {
          "file": "samples/annual_taxes.rts",
          "line": 13,
          "code": "LTGain:\t#OnePerDate if(SinceEOY > 0, Combined(TradeStatSum(if(DateYear(T.DateOut) = This(Year) and Days(T.DateIn, T.DateOut) > 366, T.Profit - T.Div, 0))), 0)"
        },
        {
          "file": "samples/ndx_plus_wtf_script.rts",
          "line": 64,
          "code": "Stop:\tif(T.Strat = 2 and BarDate>=T.DateIn and BarDate <= T.DateOut, wtf_trail, nan)"
        },
        {
          "file": "samples/trend_following_basics.rts",
          "line": 82,
          "code": "Stop: if(BarDate>=T.DateIn and BarDate <= T.DateOut, trailStop, nan) // only plots the line during when the trade was open"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "T.Div",
      "title": "T.Div",
      "aliases": [],
      "section": "17.18.491",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Record Items",
      "description": "Dividend amount(s) received or paid over the duration of a trade",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.491",
          "title": "T.Div",
          "line": 5327
        }
      ],
      "sample_examples": [
        {
          "file": "samples/annual_taxes.rts",
          "line": 13,
          "code": "LTGain:\t#OnePerDate if(SinceEOY > 0, Combined(TradeStatSum(if(DateYear(T.DateOut) = This(Year) and Days(T.DateIn, T.DateOut) > 366, T.Profit - T.Div, 0))), 0)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "T.Fraction",
      "title": "T.Fraction",
      "aliases": [],
      "section": "17.18.492",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Record Items",
      "description": "The fraction of allocation at trade entry time that was used as the initially ordered position size",
      "example": null,
      "notes": "See Fill Fraction for details about how this is calculated.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.492",
          "title": "T.Fraction",
          "line": 5329
        }
      ],
      "sample_examples": [
        {
          "file": "samples/mr_sample_tradelist.rts",
          "line": 10,
          "code": "TLValueOut is the FillFraction (T.Fraction) of each entry (ditto)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "T.FxIn",
      "title": "T.FxIn",
      "aliases": [],
      "section": "17.18.493",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Record Items",
      "description": "Currency exchange rate on trade entry date",
      "example": null,
      "notes": "This is the ratio of security currency divided by account currency.The value will always be 1 unless your test was correctly set up for multi-currency strategy modeling and the stock traded has a different base currency than your account's base currency.See Currency and Testing Multi-Currency Strategies for details on how this works.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.493",
          "title": "T.FxIn",
          "line": 5331
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "T.FxOut",
      "title": "T.FxOut",
      "aliases": [],
      "section": "17.18.494",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Record Items",
      "description": "Currency exchange rate on trade exit date",
      "example": null,
      "notes": "This is the ratio of security currency divided by account currency.The value will always be 1 unless your test was correctly set up for multi-currency strategy modeling and the stock traded has a different base currency than your account's base currency.See Currency and Testing Multi-Currency Strategies for details on how this works.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.494",
          "title": "T.FxOut",
          "line": 5335
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "T.Highest",
      "title": "T.Highest",
      "aliases": [],
      "section": "17.18.495",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Record Items",
      "description": "The highest high during a trade",
      "example": null,
      "notes": "If there was a split during the trade, price is expressed using the exit date split factor.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.495",
          "title": "T.Highest",
          "line": 5337
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "T.Lowest",
      "title": "T.Lowest",
      "aliases": [],
      "section": "17.18.496",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Record Items",
      "description": "The lowest low during a trade",
      "example": null,
      "notes": "If there was a split during the trade, price is expressed using the exit date split factor.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.496",
          "title": "T.Lowest",
          "line": 5339
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "T.NetFx",
      "title": "T.NetFx",
      "aliases": [],
      "section": "17.18.497",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Record Items",
      "description": "Net currency exchange rate change impact on trade profit or loss",
      "example": null,
      "notes": "This returns the portion of this trade's net profit or loss that is attributable to the change in currency exchange rate between position entry and exit dates.The value will always be 0 unless your test was correctly set up for multi-currency strategy modeling and the stock traded has a different base currency than your account's base currency. See Currency and Testing Multi-Currency Strategies for details on how this works.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.497",
          "title": "T.NetFx",
          "line": 5341
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "T.NetPct",
      "title": "T.NetPct",
      "aliases": [],
      "section": "17.18.498",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Record Items",
      "description": "The net trade profit or loss of a trade after commission and dividend are applied, expressed as a fraction (%/100) of the entry position size",
      "example": null,
      "notes": "This is calculated as T.Profit / (T.Qty In * T.Price In * T.Fx In) / T.Pt Val",
      "see_also": [
        "T.Profit"
      ],
      "manual_refs": [
        {
          "section": "17.18.498",
          "title": "T.NetPct",
          "line": 5346
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "T.Points",
      "title": "T.Points",
      "aliases": [],
      "section": "17.18.499",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Record Items",
      "description": "The net points (split-adjusted $/share) gained or lost in a trade (negative for a loss)",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.499",
          "title": "T.Points",
          "line": 5348
        }
      ],
      "sample_examples": [
        {
          "file": "samples/turtles.rts",
          "line": 38,
          "code": "lastTradeWin:\tif(system==2, 0, if(extern(@longtrack,sincetrue(t.points)) > extern(@shorttrack,sincetrue(t.points)),"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "T.PriceIn",
      "title": "T.PriceIn",
      "aliases": [],
      "section": "17.18.500",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Record Items",
      "description": "Trade entry price",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.500",
          "title": "T.PriceIn",
          "line": 5350
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "T.PriceOut",
      "title": "T.PriceOut",
      "aliases": [],
      "section": "17.18.501",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Record Items",
      "description": "Trade exit price",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.501",
          "title": "T.PriceOut",
          "line": 5352
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "T.Profit",
      "title": "T.Profit",
      "aliases": [],
      "section": "17.18.502",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Record Items",
      "description": "The net trade profit or loss of a trade after commission and dividend are applied, expressed in dollars",
      "example": null,
      "notes": null,
      "see_also": [
        "T.Net Pct"
      ],
      "manual_refs": [
        {
          "section": "17.18.502",
          "title": "T.Profit",
          "line": 5356
        }
      ],
      "sample_examples": [
        {
          "file": "samples/annual_taxes.rts",
          "line": 13,
          "code": "LTGain:\t#OnePerDate if(SinceEOY > 0, Combined(TradeStatSum(if(DateYear(T.DateOut) = This(Year) and Days(T.DateIn, T.DateOut) > 366, T.Profit - T.Div, 0))), 0)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "T.PtVal",
      "title": "T.PtVal",
      "aliases": [],
      "section": "17.18.503",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Record Items",
      "description": "The point value of symbol of a trade",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.503",
          "title": "T.PtVal",
          "line": 5358
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "T.QtyIn",
      "title": "T.QtyIn",
      "aliases": [],
      "section": "17.18.504",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Record Items",
      "description": "The number of shares or contracts bought or shorted when a trade was entered",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.504",
          "title": "T.QtyIn",
          "line": 5360
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "T.QtyOut",
      "title": "T.QtyOut",
      "aliases": [],
      "section": "17.18.505",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Record Items",
      "description": "The number of shares or contracts sold or covered when a trade was exited",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.505",
          "title": "T.QtyOut",
          "line": 5362
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "T.Reason",
      "title": "T.Reason",
      "aliases": [],
      "section": "17.18.506",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Record Items exposure32 max invested",
      "description": "The reason a trade was exited or an entry was skipped",
      "example": null,
      "notes": "Trade reason codes are displayed as text in the trade list window. This element is here in case you need to refer to a trade's reason code in a formula.Exit Reason Codes:Code Reason1 exit rule2 exit limit3 exit stop4 end of test5 end of data6 trade list7 reduce position8 roll forward Setup/Entry Skip Reason Codes:Code Reason1 max invested2 max positions3 max entries4 max same category5 max same symbol6 zero quantity7 limit not hit8 stop not hit9 ambiguous timing10 entry skip formula11 max setups12 max exposure13 max new positions14 max new exposure15 max new invested16 stop+limit not hit17 no\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.506",
          "title": "T.Reason",
          "line": 5364
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "T.RollCosts",
      "title": "T.RollCosts",
      "aliases": [],
      "section": "17.18.507",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Record Items",
      "description": "Total roll costs paid for a futures trade, in dollars.",
      "example": null,
      "notes": "Use the Roll Cost strategy formula to specify the cost of each roll transaction (both sides).Use S.Roll Costs to see the total roll costs for all trades closed that day.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.507",
          "title": "T.RollCosts",
          "line": 5372
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "T.Side",
      "title": "T.Side",
      "aliases": [],
      "section": "17.18.508",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Record Items",
      "description": "The side of a trade (1=long, -1=short)",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.508",
          "title": "T.Side",
          "line": 5374
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "T.SlipIn",
      "title": "T.SlipIn",
      "aliases": [],
      "section": "17.18.509",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Record Items",
      "description": "The amount of slippage applied to the entry price of a trade, in total dollars",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.509",
          "title": "T.SlipIn",
          "line": 5376
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "T.SlipOut",
      "title": "T.SlipOut",
      "aliases": [],
      "section": "17.18.510",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Record Items",
      "description": "The amount of slippage applied to the exit price of a trade, in total dollars",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.510",
          "title": "T.SlipOut",
          "line": 5378
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "T.SplitIn",
      "title": "T.SplitIn",
      "aliases": [],
      "section": "17.18.511",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Record Items",
      "description": "The bar split factor (actual price / adjusted price) at trade entry time",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.511",
          "title": "T.SplitIn",
          "line": 5380
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "T.SplitOut",
      "title": "T.SplitOut",
      "aliases": [],
      "section": "17.18.512",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Record Items",
      "description": "The bar split factor (actual price / adjusted price) at trade exit time",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.512",
          "title": "T.SplitOut",
          "line": 5382
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "T.Strat",
      "title": "T.Strat",
      "aliases": [],
      "section": "17.18.513",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Record Items",
      "description": "The strategy number of a trade",
      "example": null,
      "notes": "Strategies are numbered by the order in which they appeared in a script that was used to run the test",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.513",
          "title": "T.Strat",
          "line": 5386
        }
      ],
      "sample_examples": [
        {
          "file": "samples/ndx_plus_wtf_script.rts",
          "line": 64,
          "code": "Stop:\tif(T.Strat = 2 and BarDate>=T.DateIn and BarDate <= T.DateOut, wtf_trail, nan)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "T.TimeIn",
      "title": "T.TimeIn",
      "aliases": [],
      "section": "17.18.514",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Record Items",
      "description": "Entry time-of-day code of a trade",
      "example": null,
      "notes": "Trade time codes are displayed as text in the trade list window. This element is here in case you need to refer to a trade's entry time in a formula.Time codes are: 1=Open, 2=Intraday, 3=Close.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.514",
          "title": "T.TimeIn",
          "line": 5388
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "T.TimeOut",
      "title": "T.TimeOut",
      "aliases": [],
      "section": "17.18.515",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Record Items",
      "description": "Exit time-of-day code of a trade",
      "example": null,
      "notes": "Trade time codes are displayed as text in the trade list window. This element is here in case you need to refer to a trade's exit time in a formula.Time codes are: 1=Open, 2=Intraday, 3=Close.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.515",
          "title": "T.TimeOut",
          "line": 5390
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "T.ValueIn",
      "title": "T.ValueIn",
      "aliases": [],
      "section": "17.18.516",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Record Items",
      "description": "Value calculated by Entry Trade Value when position was entered",
      "example": null,
      "notes": "This item can be useful in Trade Statistics Functions",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.516",
          "title": "T.ValueIn",
          "line": 5392
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "T.ValueOut",
      "title": "T.ValueOut",
      "aliases": [],
      "section": "17.18.517",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Record Items",
      "description": "Value calculated by Exit Trade Value when position was exited",
      "example": null,
      "notes": "This item can be useful in Trade Statistics Functions",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.517",
          "title": "T.ValueOut",
          "line": 5396
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Tangent",
      "title": "Tangent",
      "aliases": [],
      "section": "17.18.518",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Trigonometric tangent of a number of degrees",
      "example": null,
      "notes": "The parameter value is assumed to be degrees (0-360).To convert radians to degrees, multiply by 57.2957795131 (180/\u03c0).",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.518",
          "title": "Tangent",
          "line": 5398
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "TanH",
      "title": "TanH",
      "aliases": [],
      "section": "17.18.519",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Hyberbolic Tangent of a number",
      "example": null,
      "notes": "The Tan H function normalizes financial time series to a range of -1 to 1, aiding in creating smooth, bounded trading indicators and improving the detection of overbought and oversold conditions. Its properties include being linear in the middle, which helps in interpreting small changes clearly, and bounding outliers, which prevents extreme values from disproportionately affecting the analysis.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.519",
          "title": "TanH",
          "line": 5400
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "TargetPrice",
      "title": "TargetPrice",
      "aliases": [],
      "section": "17.18.520",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Calculate the value of tomorrow's close that would cause an indicator to reach a specific level",
      "example": "if today's close was 100 and the default 50% range is used, it will start with the range 50 to 150 and narrow it from there. If the required price is outside the range, the result will be the range boundary, not the correct price.For a quick test of how this works, compare Target Price(RSI(2), 50) to RRSI(2, 50) -- the results will be the same (or very close).(RRSI is much faster than Target\u2026",
      "notes": "This function uses binary search logic to govern an iterative process:\u00b7 temporarily coerce tomorrow's OHLC values to a specific value in the data (adding an extra bar at the end if needed)\u00b7 call the indicator function with a one-bar lookahead offset e.g. MA(C, 20)[-1]\u00b7 narrow the search range based on whether the result was too low or too high The optional range argument lets you control how wide a range to allow. For",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.520",
          "title": "TargetPrice",
          "line": 5405
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "TEMA",
      "title": "TEMA",
      "aliases": [],
      "section": "17.18.521",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Triple Exponential Moving Average",
      "example": null,
      "notes": "Count is usually thought of as an integer representing a number of bars, but can actually be any decimal value. An EMA is constructed by multiplying each difference between the result so far and the next value by a factor equal to 2 / (count + 1).Triple EMA is calculated as 3 * EMA(expr, count) - 3 * EMA(EMA(expr, count)) + EMA(EMA(EMA(expr, count))) Unlike the EMA function, TEMA applies the exponential weight factor from the start of available data rather than beginning with MA(expr, count). This is consistent with how other backtesting software calculates this indicator.This function\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.521",
          "title": "TEMA",
          "line": 5407
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Template",
      "title": "Template",
      "aliases": [],
      "section": "17.18.522",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Script Sections",
      "description": "Defines a strategy template",
      "example": null,
      "notes": "See Special Strategy Types for details.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.522",
          "title": "Template",
          "line": 5412
        }
      ],
      "sample_examples": [
        {
          "file": "samples/actual_trades.rts",
          "line": 20,
          "code": "Template: trades"
        },
        {
          "file": "samples/bensdorp_book.rts",
          "line": 87,
          "code": "Template: common"
        },
        {
          "file": "samples/bottomup/actual_trades.rts",
          "line": 20,
          "code": "Template: trades"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "TestData",
      "title": "TestData",
      "aliases": [],
      "section": "17.18.524",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Script Sections",
      "description": "Named formulas calculated and stored in memory arrays for each symbol each date while tests are run .",
      "example": null,
      "notes": "See Test Data Section for a more detailed",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.524",
          "title": "TestData",
          "line": 5416
        }
      ],
      "sample_examples": [
        {
          "file": "samples/annual_taxes.rts",
          "line": 10,
          "code": "TestData:"
        },
        {
          "file": "samples/clenow_stocks_on_move.rts",
          "line": 50,
          "code": "TestData:"
        },
        {
          "file": "samples/clenow_stocks_on_move_dynamic.rts",
          "line": 51,
          "code": "// ^^^ Quantity is only evaluated once per symbol so TestData is not required here"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "TestInclude",
      "title": "TestInclude",
      "aliases": [],
      "section": "17.18.523",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Script Sections",
      "description": "Allows a script to include another script when run in Test Mode",
      "example": null,
      "notes": "See the general-purpose Include statement for further details.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.523",
          "title": "TestInclude",
          "line": 5414
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "TestName",
      "title": "TestName",
      "aliases": [],
      "section": "17.18.525",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "String that should appear in the \"Name\" column of the Test Results row after the test is run",
      "example": null,
      "notes": "If Test Name is not specified in a script then the name from the Settings Panel will be used, and if that is blank then the script name is used as the test name.If Test Name is specified, it is evaluated as a Formula that returns a String Value. To specify a literal test name, it must be enclosed in quotation marks. String Functions such as Format can optionally be used to generate a test name that is relevant to the current set of",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.525",
          "title": "TestName",
          "line": 5420
        }
      ],
      "sample_examples": [
        {
          "file": "samples/ndx_rotate_factor_test.rts",
          "line": 13,
          "code": "TestName:\tItem(\"name{#}\", factor_number)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "TestOutput",
      "title": "TestOutput",
      "aliases": [],
      "section": "17.18.526",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "Specifies additional output and actions during and after a single test run Choices (multiple, separated by commas) None - no additional test output Report - generate a Test Summary Report Graph - open a stats graph and dynamically update it as the test runs Log - generates a detailed transaction and position log and displays it at the end of the test Orders - generate the list of Tomorrow's Orders Scan - run a special scan allowing position-level formula elements to be used to output the list of positions remaining open and/or other details Debug - show output from Debug Entry, Debug Exit and\u2026",
      "example": null,
      "notes": "If Test Output is not specified in a script then the choices from the Settings Panel will be used.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.526",
          "title": "TestOutput",
          "line": 5422
        }
      ],
      "sample_examples": [
        {
          "file": "samples/annual_taxes.rts",
          "line": 19,
          "code": "TestOutput:\tScan"
        },
        {
          "file": "samples/management_fees.rts",
          "line": 36,
          "code": "TestOutput:\tScan"
        },
        {
          "file": "samples/mr_sample_debug.rts",
          "line": 12,
          "code": "TestOutput:\tDebug"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "TestScan",
      "title": "TestScan",
      "aliases": [],
      "section": "17.18.527",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Script Sections",
      "description": "Test Output Scan definition",
      "example": null,
      "notes": "This section defines a special type of scan that is run at the end of a test and has full access to the test context including open positions.See Test Output Scan for more information.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.527",
          "title": "TestScan",
          "line": 5424
        }
      ],
      "sample_examples": [
        {
          "file": "samples/annual_taxes.rts",
          "line": 20,
          "code": "TestScanAllDates:\tTrue"
        },
        {
          "file": "samples/management_fees.rts",
          "line": 21,
          "code": "TestScan:"
        },
        {
          "file": "samples/mr_sample_test_scan.rts",
          "line": 17,
          "code": "TestScanAllDates:\tFalse // only scan on last date of test run (change to True to see all historical orders)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "TestScanAllDates",
      "title": "TestScanAllDates",
      "aliases": [],
      "section": "17.18.528",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "Allows a Test Scan to include a row for every date of a test Choices True - include all dates False - (default) only run the scan on the last date of the test (before doing end-of-test exits)",
      "example": null,
      "notes": "See Test Output Scan for more information.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.528",
          "title": "TestScanAllDates",
          "line": 5428
        }
      ],
      "sample_examples": [
        {
          "file": "samples/annual_taxes.rts",
          "line": 20,
          "code": "TestScanAllDates:\tTrue"
        },
        {
          "file": "samples/management_fees.rts",
          "line": 37,
          "code": "TestScanAllDates:\tTrue"
        },
        {
          "file": "samples/mr_sample_test_scan.rts",
          "line": 17,
          "code": "TestScanAllDates:\tFalse // only scan on last date of test run (change to True to see all historical orders)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "TestSettings",
      "title": "TestSettings",
      "aliases": [],
      "section": "17.18.529",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Script Sections",
      "description": "Defines the settings to use only when the script run mode is Test or Optimize.",
      "example": null,
      "notes": "The general-purpose Settings section is always applied first, then modified by any items specified in Test Settings when applicable.See Settings Sections for details.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.529",
          "title": "TestSettings",
          "line": 5430
        }
      ],
      "sample_examples": [
        {
          "file": "samples/mr_sample_debug.rts",
          "line": 7,
          "code": "TestSettings:"
        },
        {
          "file": "samples/namespace_example.rts",
          "line": 69,
          "code": "TestSettings:"
        },
        {
          "file": "samples/oex_tf_auto_track.rts",
          "line": 21,
          "code": "TestSettings:"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "This",
      "title": "This",
      "aliases": [],
      "section": "17.18.530",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Anchors a value in multi-bar or multi-position function calculations",
      "example": ", say you want to know how many bars it has been since there was more volume than today's volume. You might try using Since True(V[1] > V), but since this is a multi-bar function, the entire expression \"V[1] > V\" is rolled back through time and evaluated for each bar as if it was the current bar. So instead of telling you how many bars since volume exceeded today's volume, it is telling you how\u2026",
      "notes": "In functions such as Count True, Since True and True In Row, we sometimes want to compare a number of prior bar values to one specific bar value.For",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.530",
          "title": "This",
          "line": 5432
        }
      ],
      "sample_examples": [
        {
          "file": "samples/actual_trades.rts",
          "line": 36,
          "code": "// this works for IB TWS trade log export files with default columns"
        },
        {
          "file": "samples/annual_taxes.rts",
          "line": 13,
          "code": "LTGain:\t#OnePerDate if(SinceEOY > 0, Combined(TradeStatSum(if(DateYear(T.DateOut) = This(Year) and Days(T.DateIn, T.DateOut) > 366, T.Profit - T.Div, 0))), 0)"
        },
        {
          "file": "samples/bensdorp_book.rts",
          "line": 88,
          "code": "// elements common to all strategies that \"use\" this template"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "TickSize",
      "title": "TickSize",
      "aliases": [],
      "section": "17.18.531",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Stock/Contract Information",
      "description": "Futures contract tick size",
      "example": null,
      "notes": "Specifies the smallest possible price change for a futures contract.Tick sizes are obtained automatically when importing data from Norgate.For CSV futures data import, it would be necessary to provide tick sizes for each contract using a Sym Info file.If not provided, Tick Size defaults to 0.01 for stocks.Note that Tick Size is not used in any internal calculations in Real Test. All available decimal places in data bar values used in every calculation.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.531",
          "title": "TickSize",
          "line": 5437
        }
      ],
      "sample_examples": [
        {
          "file": "samples/es_compare.rts",
          "line": 25,
          "code": "Slippage:\tTickSize"
        },
        {
          "file": "samples/futures_trend_follow_csi.rts",
          "line": 39,
          "code": "Slippage:\t2 * TickSize\t// 2 ticks each way"
        },
        {
          "file": "samples/futures_trend_follow_simple.rts",
          "line": 39,
          "code": "Slippage:\tTickSize"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "TLAdjusted",
      "title": "TLAdjusted",
      "aliases": [],
      "section": "17.18.532",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Specifies whether the prices and quantities of trades in a Trade List are split-adjusted Choices False - not adjusted, i.e. as-traded (default) True - adjusted",
      "example": null,
      "notes": "Real Test assumes that tradelist prices are not split-adjusted, as in most cases they will have come from actual trades that occurred in the market.This setting is mainly for use when exporting a trade list from other software such as Ami Broker and then importing it to Real Test.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.532",
          "title": "TLAdjusted",
          "line": 5439
        }
      ],
      "sample_examples": [
        {
          "file": "samples/actual_trades.rts",
          "line": 58,
          "code": "// AB trade prices are split-adjusted, so use TLAdjusted to tell RT to unadjust them"
        },
        {
          "file": "samples/bottomup/actual_trades.rts",
          "line": 58,
          "code": "// AB trade prices are split-adjusted, so use TLAdjusted to tell RT to unadjust them"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "TLAdoptPos",
      "title": "TLAdoptPos",
      "aliases": [],
      "section": "17.18.533",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Specifies whether trades from a Trade List that were entered prior to the test's Start Date should be \"adopted\" by the strategy Choices False - do not adopt positions entered before the start date (default) True - do adopt them",
      "example": null,
      "notes": "Trades entered before the start date will only be adopted by the strategy if they were exited after the start date or have no exit specified.When such trades are adopted, their entry dates are changed to match the test's start date.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.533",
          "title": "TLAdoptPos",
          "line": 5444
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "TLDateFmt",
      "title": "TLDateFmt",
      "aliases": [],
      "section": "17.18.534",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Specifies whether the dates in a Trade List are in M/D/Y vs. D/M/Y format Choices DMY - dates are D/M/YMDY - dates are M/D/YNotes The default if a strategy does not specify TLDate Format is to use the Date Display Format setting from the Program Options Dialog.This strategy setting lets you use trade lists with the opposite of your standard date format more easily, and/or use two trade lists with opposite formats in the same script.Other date formats are supported which are not ambiguous and therefore do not require TLDate Fmt to be specified.",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.534",
          "title": "TLDateFmt",
          "line": 5446
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "TLDelim",
      "title": "TLDelim",
      "aliases": [],
      "section": "17.18.535",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Specifies the column delimiter in a Trade List file.Choices Comma Semicolon Tab",
      "example": null,
      "notes": "The default column delimiter is Comma when TLNum Fmt is Point or Semicolon when TLNum Fmt is Comma.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.535",
          "title": "TLDelim",
          "line": 5448
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "TLEndDate",
      "title": "TLEndDate",
      "aliases": [],
      "section": "17.18.536",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "The date to switch from pure Trade List playback to pure strategy formula processing.Choices0 - (default) play back the trade list and superimpose strategy formulas (if provided) on those imported trades Latest - play back the trade list verbatim and ignore the strategy definitionany date - play back the trade list verbatim up through that date, then ignore the rest of the imported trades and apply the strategy definition thereafter",
      "example": null,
      "notes": "The default \"0\" choice (or omitting this element) runs a Trade List strategy as was always done prior to release 2.0.29.2. The Entry Setup formula is ignored. Other strategy formulas, if specified, will modify the behavior of the imported trade.The \"Latest\" choice, or specifying any date after the backtest end date, causes a pure trade list playback regardless of what else is in the strategy definition.Specifying a date that is earlier than the backtest end date runs a pure trade list playback through that date and then switches to a pure strategy backtest.This strategy setting only applies\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.536",
          "title": "TLEndDate",
          "line": 5452
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "TLFields",
      "title": "TLFields",
      "aliases": [],
      "section": "17.18.537",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Imported trade list CSV field order specification (comma-separated list) Choices Asset Id - the stock's Norgate asset ID (overrides Symbol if provided) Symbol - the stock symbol Strategy - the strategy name (if present, must match script strategy name) Side - the round-trip trade side (long or 1 for long, short or -1 for short) Action - the transaction type (BUY/SELL) and its presence identifies the file as a transaction list Date Time - this field includes both date and time of a transaction, with a space between them Shares - the quantity of a transaction or of both sides of a round-trip\u2026",
      "example": "of how a Trade List strategy might look: Note that the field names (like all names in Real Test) are not case-sensitive.To ignore a column in a trade list file, add an extra comma to the field order list, as shown in the above.To ignore the first one or more columns, add extra comma(s) at the start of the list, e.g. \",,symbol,side,\" etc.See Using an Imported Trade List for a detailed",
      "notes": "The TLFields order must be specified for a Trade List strategy to work.If the CSV file includes a header row with column labels, these are simply ignored.If TLFields includes Strategy, then only those trades where the contents of that column match the name of the strategy that contains the TLFields statement will be included. If TLFields does not include Strategy values, then all trades in the list will be used by this strategy.Here is an",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.537",
          "title": "TLFields",
          "line": 5454
        }
      ],
      "sample_examples": [
        {
          "file": "samples/actual_trades.rts",
          "line": 22,
          "code": "TLFields:\tSymbol,Strategy,Side,DateIn,QtyIn,PriceIn,DateOut,QtyOut,PriceOut"
        },
        {
          "file": "samples/bottomup/actual_trades.rts",
          "line": 22,
          "code": "TLFields:\tSymbol,Strategy,Side,DateIn,QtyIn,PriceIn,DateOut,QtyOut,PriceOut"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "TLNumFmt",
      "title": "TLNumFmt",
      "aliases": [],
      "section": "17.18.538",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Specifies whether numbers (prices) in a Trade List use a point or a comma as their decimal separator Choices Point - point (period) is used (default) Comma - comma is used",
      "example": null,
      "notes": "By default comma is the field separator in a CSV trade list file, and point is the decimal separator.This optional item enables European-format \"CSV\" trade lists to be imported by Real Test.Specify TLNum Fmt: Comma if your trade lists use comma in place of point as the decimal delimiter.When using TLNum Fmt: Comma, be sure to also specify Semi Colon as your TLDelim.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.538",
          "title": "TLNumFmt",
          "line": 5460
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "TLStratName",
      "title": "TLStratName",
      "aliases": [],
      "section": "17.18.539",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Specifies which strategy name within a Trade List maps to the script strategy that imports the Trade List Input A strategy name",
      "example": null,
      "notes": "By default a strategy that imports trades must have the same name as its trades in the list.This optional strategy setting allows a strategy of any name to import trades of the specified strategy name.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.539",
          "title": "TLStratName",
          "line": 5465
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "TLTimeShift",
      "title": "TLTimeShift",
      "aliases": [],
      "section": "17.18.540",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Specifies the timezone shift, in hours, to apply to trade dates and times in a Trade List Input A number of hours.",
      "example": ", if your ASX trades are shown in NYC time, add TLTime Shift: 14 to your strategy definition.",
      "notes": "This setting is mainly for use with IB Flex Query output for non-US markets where Date/Time is nevertheless reported in NYC time.For",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.540",
          "title": "TLTimeShift",
          "line": 5467
        }
      ],
      "sample_examples": [
        {
          "file": "samples/actual_trades.rts",
          "line": 50,
          "code": "// the TLTimeShift setting tells RT how to shift the date/time values so they're aligned with ASX data bars"
        },
        {
          "file": "samples/bottomup/actual_trades.rts",
          "line": 50,
          "code": "// the TLTimeShift setting tells RT how to shift the date/time values so they're aligned with ASX data bars"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "TLValueIn",
      "title": "TLValueIn",
      "aliases": [],
      "section": "17.18.541",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Current Position Information",
      "description": "The Value In value for a position that originated from a Trade List",
      "example": "of how this works.",
      "notes": "TLValue In provides a way for strategy formulas to access an arbitrary value from a trade list.The intended use case is to test combined strategies without having to merge separate scripts.This is done by running them separately with Save Trades As and then combining them by playing back those saved trade lists together.Typically each separate script would use Entry Trade Value and/or Exit Trade Value to save information such as Order Price or Fill Fraction.The combined playback script can then access these values using TLValue In or TLValue Out, typically for use in a Quantity override.See\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.541",
          "title": "TLValueIn",
          "line": 5471
        }
      ],
      "sample_examples": [
        {
          "file": "samples/mr_sample_long_only.rts",
          "line": 24,
          "code": "EntryTradeValue:\tOrderPrice // becomes TLValueIn in the playback strategy"
        },
        {
          "file": "samples/mr_sample_short_only.rts",
          "line": 22,
          "code": "EntryTradeValue:\tOrderPrice // becomes TLValueIn in the playback strategy"
        },
        {
          "file": "samples/mr_sample_tradelist.rts",
          "line": 9,
          "code": "TLValueIn is the OrderPrice of each entry (see mr_sample_long_only.rts)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "TLValueOut",
      "title": "TLValueOut",
      "aliases": [],
      "section": "17.18.542",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Current Position Information",
      "description": "The Value Out value for a position that originated from a Trade List",
      "example": "of how this works.",
      "notes": "TLValue Out provides a way for strategy formulas to access an arbitrary value from a trade list.The intended use case is to test combined strategies without having to merge separate scripts.This is done by running them separately with Save Trades As and then combining them by playing back those saved trade lists together.Typically each separate script would use Entry Trade Value and/or Exit Trade Value to save information such as Order Price or Fill Fraction.The combined playback script can then access these values using TLValue In or TLValue Out, typically for use in a Quantity override.See\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.542",
          "title": "TLValueOut",
          "line": 5473
        }
      ],
      "sample_examples": [
        {
          "file": "samples/mr_sample_long_only.rts",
          "line": 25,
          "code": "ExitTradeValue:\tFillFraction // becomes TLValueOut in the playback strategy"
        },
        {
          "file": "samples/mr_sample_short_only.rts",
          "line": 23,
          "code": "ExitTradeValue:\tFillFraction // becomes TLValueOut in the playback strategy"
        },
        {
          "file": "samples/mr_sample_tradelist.rts",
          "line": 10,
          "code": "TLValueOut is the FillFraction (T.Fraction) of each entry (ditto)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "ToDate",
      "title": "ToDate",
      "aliases": [],
      "section": "17.18.543",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "String Functions",
      "description": "Convert a string to a date value",
      "example": null,
      "notes": "The following date formats can be parsed by this function:\u00b7 yyyymmdd (as a string)\u00b7 mm/dd/yy or mm/dd/yyyy, where mm and dd are either 1 or 2 digits\u00b7 dd-mmm-yy or dd-mmm-yyyy, where mmm is Jan, Feb, etc. (not case-sensitive) If the string is not a valid date, the result will be 0.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.543",
          "title": "ToDate",
          "line": 5475
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "ToLower",
      "title": "ToLower",
      "aliases": [],
      "section": "17.18.544",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "String Functions",
      "description": "Convert a string to all lowercase",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.544",
          "title": "ToLower",
          "line": 5480
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "ToNum",
      "title": "ToNum",
      "aliases": [],
      "section": "17.18.545",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "String Functions",
      "description": "Convert a string to a numeric value",
      "example": null,
      "notes": "If nth is not specified then this function only looks for a number at the beginning of the string.If nth is 1 then the first number found within the string (or at the beginning) is returned.If nth is 2 the second number found is returned, and so on.A return value of 0 means either the number found was 0 or no number was found.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.545",
          "title": "ToNum",
          "line": 5482
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Top",
      "title": "Top",
      "aliases": [],
      "section": "17.18.547",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "General-Purpose Functions",
      "description": "Use the top N digits of a number to make a new number",
      "example": null,
      "notes": "This function was added to make it easier to use different levels of the TRBC industry codes, though it can be used with any numeric value.The TRBC codes are 10-digit numbers from which every pair of digits going from left to right makes the industry designation more specific.For the economic sector code, use Top(TRBC, 2).For the business sector code, use Top(TRBC, 4).For the industry group code, use Top(TRBC, 6).For the specific industry code, use Top(TRBC, 8).",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.547",
          "title": "Top",
          "line": 5488
        }
      ],
      "sample_examples": [
        {
          "file": "samples/bensdorp_book.rts",
          "line": 102,
          "code": "ExitStop:\tMax(FillPrice - 5 * atr20, HHV(C,BarsHeld)*0.75)"
        },
        {
          "file": "samples/cii_rotate.rts",
          "line": 20,
          "code": "topCIIs:\t5"
        },
        {
          "file": "samples/combined.rts",
          "line": 45,
          "code": "SetupScore:\tC[5] / C \t// select the top 5 ranked by 5-day pullback"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "ToUpper",
      "title": "ToUpper",
      "aliases": [],
      "section": "17.18.546",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "String Functions",
      "description": "Convert a string to all uppercase",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.546",
          "title": "ToUpper",
          "line": 5484
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "Tracker",
      "title": "Tracker",
      "aliases": [],
      "section": "17.18.548",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Specifies whether to automatically create a tracking benchmark copy of this strategy.Choices None - do not add a tracking benchmark (default) Hidden - add a tracking benchmark that will not appear in graphs or reports Visible - add a tracking benchmark that will appear in graphs and reports in the Strat Data section topic for a more complex",
      "example": "script for a simple of Tracker and Is Tracker usage.See the oex_tf_auto_track.rts script and its .",
      "notes": "When Tracker is specified (other than None), a Benchmark copy of the current strategy is internally created. Specifying Tracker: Hidden names the auto-generated benchmark as the strategy name with a leading underscore and with \"_track\" appended, e.g. the tracker for a strategy called \"mr_long\" would be added as \"_mr_long_track\".Specifying Tracker: Visible does the same, just without the leading underscore. (A leading underscore on a benchmark name means \"do not show this benchmark in graphs or reports\".) Use Is Tracker in your strategy+tracker formulas to know which one is being evaluated.See\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.548",
          "title": "Tracker",
          "line": 5490
        }
      ],
      "sample_examples": [
        {
          "file": "samples/mr_sample_tracking.rts",
          "line": 9,
          "code": "Tracker:\tVisible // generate benchmark copy of strategy"
        },
        {
          "file": "samples/oex_tf_auto_track.rts",
          "line": 3,
          "code": "Uses automatic \"tracker\" benchmarks and StratData to rank recent performance."
        }
      ],
      "grammar_match": false
    },
    {
      "name": "TradeList",
      "title": "TradeList",
      "aliases": [],
      "section": "17.18.549",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Designates a strategy as being based on an external list of trades and provides the path to that list Input Path to a CSV file containing a list of trades to be used. of this mechanism.",
      "example": null,
      "notes": "Strategies that include a Trade List must also include a TLFields definition.See Using an Imported Trade List for a detailed",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.549",
          "title": "TradeList",
          "line": 5495
        }
      ],
      "sample_examples": [
        {
          "file": "samples/actual_trades.rts",
          "line": 21,
          "code": "TradeList:\t?scriptpath?\\actual_trades.csv"
        },
        {
          "file": "samples/bottomup/actual_trades.rts",
          "line": 21,
          "code": "TradeList:\t?scriptpath?\\actual_trades.csv"
        },
        {
          "file": "samples/mr_sample_long_only.rts",
          "line": 3,
          "code": "separated to demonstrate combining strategiges via tradelist"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Trades",
      "title": "Trades",
      "aliases": [],
      "section": "17.18.550",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Script Sections",
      "description": "Backtest trade list column definitions See Trades Section and Trade List Windows.",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.550",
          "title": "Trades",
          "line": 5497
        }
      ],
      "sample_examples": [
        {
          "file": "samples/actual_trades.rts",
          "line": 2,
          "code": "illustrates how to run a \"test\" from a list of actual trades"
        },
        {
          "file": "samples/annual_taxes.rts",
          "line": 13,
          "code": "LTGain:\t#OnePerDate if(SinceEOY > 0, Combined(TradeStatSum(if(DateYear(T.DateOut) = This(Year) and Days(T.DateIn, T.DateOut) > 366, T.Profit - T.Div, 0))), 0)"
        },
        {
          "file": "samples/bottomup/actual_trades.rts",
          "line": 2,
          "code": "illustrates how to run a \"test\" from a list of actual trades"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "TradeStatAvg",
      "title": "TradeStatAvg",
      "aliases": [],
      "section": "17.18.551",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Statistics Functions .",
      "description": "The average of trade record values for the most recent N trades or for all trades",
      "example": null,
      "notes": "See the link above for important information about this function",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.551",
          "title": "TradeStatAvg",
          "line": 5499
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "TradeStatMax",
      "title": "TradeStatMax",
      "aliases": [],
      "section": "17.18.552",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Statistics Functions .",
      "description": "The largest of trade record values for the most recent N trades or for all trades",
      "example": null,
      "notes": "See the link above for important information about this function",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.552",
          "title": "TradeStatMax",
          "line": 5504
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "TradeStatMin",
      "title": "TradeStatMin",
      "aliases": [],
      "section": "17.18.553",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Statistics Functions .",
      "description": "The smallest of trade record values for the most recent N trades or for all trades",
      "example": null,
      "notes": "See the link above for important information about this function",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.553",
          "title": "TradeStatMin",
          "line": 5506
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "TradeStatStdDev",
      "title": "TradeStatStdDev",
      "aliases": [],
      "section": "17.18.554",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Statistics Functions .",
      "description": "The standard deviation of trade record values for the most recent N trades or for all trades",
      "example": null,
      "notes": "See the link above for important information about this function",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.554",
          "title": "TradeStatStdDev",
          "line": 5510
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "TradeStatSum",
      "title": "TradeStatSum",
      "aliases": [],
      "section": "17.18.555",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Trade Statistics Functions .",
      "description": "The sum of trade record values for the most recent N trades or for all trades",
      "example": null,
      "notes": "See the link above for important information about this function",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.555",
          "title": "TradeStatSum",
          "line": 5512
        }
      ],
      "sample_examples": [
        {
          "file": "samples/annual_taxes.rts",
          "line": 13,
          "code": "LTGain:\t#OnePerDate if(SinceEOY > 0, Combined(TradeStatSum(if(DateYear(T.DateOut) = This(Year) and Days(T.DateIn, T.DateOut) > 366, T.Profit - T.Div, 0))), 0)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Trough",
      "title": "Trough",
      "aliases": [],
      "section": "17.18.556",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Value of the nth most recent trough of a series of prices or other values",
      "example": null,
      "notes": "The definition of a Trough is the lowest value which is then followed by one or more values that are at least n% above that most recent low.See Peak for important additional information about how these functions work in Real Test.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.556",
          "title": "Trough",
          "line": 5514
        }
      ],
      "sample_examples": [
        {
          "file": "samples/anchored_vwap.rts",
          "line": 4,
          "code": "Here we use TroughBars to locate the most recent apparent pivot."
        }
      ],
      "grammar_match": false
    },
    {
      "name": "TroughBars",
      "title": "TroughBars",
      "aliases": [],
      "section": "17.18.557",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Count of bars since the nth most recent trough of a series of prices or other values",
      "example": null,
      "notes": "The definition of a Trough is the lowest value which is then followed by one or more values that are at least n% above that most recent low.See Peak for important additional information about how these functions work in Real Test.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.557",
          "title": "TroughBars",
          "line": 5519
        }
      ],
      "sample_examples": [
        {
          "file": "samples/anchored_vwap.rts",
          "line": 4,
          "code": "Here we use TroughBars to locate the most recent apparent pivot."
        }
      ],
      "grammar_match": false
    },
    {
      "name": "TrueInRow",
      "title": "TrueInRow",
      "aliases": [],
      "section": "17.18.558",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Count of bars in a row for which a condition was true",
      "example": null,
      "notes": "Condition will be evaluated for the most recent bar first, then proceed back in time until a FALSE (0) value is found or count bars have been checked, whichever comes first. For each bar, condition is evaluated as if that bar were the current bar, i.e. without knowledge of future splits relative to that bar.If count is omitted then there is no maximum (all bars before this one are potentially checked). If condition was never true, the return value is 0. If condition is currently true, but wasn't true yesterday, the return value is 1. If condition was true today and yesterday, the return value\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.558",
          "title": "TrueInRow",
          "line": 5521
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    },
    {
      "name": "TrueRange",
      "title": "TrueRange or TR",
      "aliases": [
        "TR"
      ],
      "section": "17.18.559",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Bar Data Values",
      "description": "Current bar range including prior close",
      "example": null,
      "notes": "True Range is defined as Max(C[1],H) - Min(C[1],L).Either True Range or TR can be used.",
      "see_also": [
        "ATR",
        "Range."
      ],
      "manual_refs": [
        {
          "section": "17.18.559",
          "title": "TrueRange or TR",
          "line": 5526
        }
      ],
      "sample_examples": [
        {
          "file": "samples/Sample1.rts",
          "line": 18,
          "code": "Strategy: SPY_Crossover"
        },
        {
          "file": "samples/Sample2.rts",
          "line": 6,
          "code": "DataFile:\tsample1.rtd // see Sample1.rts for import instructions"
        },
        {
          "file": "samples/Sample2a.rts",
          "line": 6,
          "code": "DataFile:\tsample1.rtd // see Sample1.rts for import instructions"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "UntilTrue",
      "title": "UntilTrue",
      "aliases": [],
      "section": "17.18.560",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Count bars until a condition will be true",
      "example": null,
      "notes": "Condition will be evaluated for the most recent bar first, then proceed forward in time until a non-zero value is found or count bars have been checked, whichever comes first. For each bar, condition is evaluated as if that bar were the current bar, i.e. without knowledge of future splits relative to that bar.If count is omitted then there is no maximum (all bars after this one are potentially checked). If condition never becomes true, the return value is -1. If condition is currently true, the return value is 0. If condition will be true tomorrow, the return value is 1, and so on.Since this\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.560",
          "title": "UntilTrue",
          "line": 5528
        }
      ],
      "sample_examples": [
        {
          "file": "samples/dividend_capture.rts",
          "line": 25,
          "code": "Bars:\tUntilTrue(Dividend > 0, 20)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Update",
      "title": "Update",
      "aliases": [],
      "section": "17.18.561",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Import Specification",
      "description": "Norgate data update request Choices True - launch a Norgate update False - don't launch a Norgate update (default)",
      "example": null,
      "notes": "This import option makes it easy to ensure that Norgate has updated the data before you import it.When a Norgate import is run with Update: TRUE, the update process is launched and Real Test waits for it to finish before starting the import. The status of this operation is shown in the Status Bar. It is fine to be editing scripts, reviewing test results, etc. while an import (or any other task) is running.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.561",
          "title": "Update",
          "line": 5532
        }
      ],
      "sample_examples": [
        {
          "file": "samples/import_norgate.rts",
          "line": 14,
          "code": "Update:\tFalse\t// change to true to run a NDU update before the import"
        },
        {
          "file": "samples/simple_day_trade_basket_scan.rts",
          "line": 14,
          "code": "// must manually update these two items before running the scan"
        },
        {
          "file": "samples/spy_tlt_uis.rts",
          "line": 5,
          "code": "To reproduce or update the WalkForward parameters, do this:"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "UseAvailableBars",
      "title": "UseAvailableBars",
      "aliases": [],
      "section": "17.18.562",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Settings",
      "description": "Controls what happens when there are not enough bars to calculate a simple average or indicator Choices True - calculate simple averages and indicators using how ever many bars are available False - return Na N if not enough bars are available (default)",
      "example": ", if a formula refers to Avg(C,200) and the current bar is only the 100th bar of the data for that symbol, then the 100-day average close will be returned instead.The Use Available Bars setting has no effect on exponential averages or indicators. Exponential average calculation actually requires five times the \"length\" to reach full precision. Real Test will use this full-precision length when it\u2026",
      "notes": "When Use Available Bars is False, then any simple average or indicator that does not have enough data to calculate the correct value will return Na N (not a number), and the formula will stop being evaluated.When Use Available Bars is True, simple averages and indicators are calculated using however many bars are available. For",
      "see_also": [
        "Number of Bars Required."
      ],
      "manual_refs": [
        {
          "section": "17.18.562",
          "title": "UseAvailableBars",
          "line": 5534
        }
      ],
      "sample_examples": [
        {
          "file": "samples/cii_rotate.rts",
          "line": 42,
          "code": "UseAvailableBars:\tFalse"
        },
        {
          "file": "samples/combined.rts",
          "line": 20,
          "code": "UseAvailableBars:\tFalse"
        },
        {
          "file": "samples/combined_rebalance.rts",
          "line": 9,
          "code": "UseAvailableBars:\tFalse"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Using",
      "title": "Using",
      "aliases": [],
      "section": "17.18.563",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Strategy Elements",
      "description": "Tells a Strategy or Benchmark or Template to use elements from another strategy or benchmark or template Input A list of comma-separated names of strategies or benchmarks of templates",
      "example": "scripts, such as mr_sample.rts, incorporate the template/using concept.",
      "notes": "Using is most often used by strategies to incorporate elements from templates, but any strategy type can inherit from any other with Using.All of the elements defined in the used strategy are copied into the using strategy. If the using strategy defines its own version of any of those elements, its own elements replace the ones from the used strategy.All this is here just to save you from having to re-type (or copy/paste) strategy elements that you use in multiple strategies in a script. Certain elements, such as Commission and Slippage formulas, are often the same for every strategy.Some of\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.563",
          "title": "Using",
          "line": 5536
        }
      ],
      "sample_examples": [
        {
          "file": "samples/actual_trades.rts",
          "line": 5,
          "code": "see actual_entries.rts for an example using actual entries with mechanical exit rules"
        },
        {
          "file": "samples/bensdorp_book.rts",
          "line": 97,
          "code": "Using:\tcommon"
        },
        {
          "file": "samples/bottomup/actual_trades.rts",
          "line": 5,
          "code": "see actual_entries.rts for an example using actual entries with mechanical exit rules"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Volume",
      "title": "Volume or V",
      "aliases": [
        "V"
      ],
      "section": "17.18.564",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Bar Data Values",
      "description": "Current bar volume",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.564",
          "title": "Volume or V",
          "line": 5541
        }
      ],
      "sample_examples": [
        {
          "file": "samples/Sample1.rts",
          "line": 2,
          "code": "Simplest Example -- 50/200 crossover on SPY"
        },
        {
          "file": "samples/Sample2.rts",
          "line": 3,
          "code": "find out which crossover MA lengths would have done best"
        },
        {
          "file": "samples/Sample2a.rts",
          "line": 3,
          "code": "find out which crossover MA lengths would have done best"
        }
      ],
      "grammar_match": true
    },
    {
      "name": "VWMA",
      "title": "VWMA",
      "aliases": [],
      "section": "17.18.565",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Volume-Weighted Moving Average",
      "example": null,
      "notes": "VWMA is calculated as Sum(expr * Volume, count) / Sum(Volume, count) VWMA(Close, count) is a way to calculate volume-weighted average price (VWAP).This function supports one-pass calculation when used in the Data Section with a non-variable count.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.565",
          "title": "VWMA",
          "line": 5543
        }
      ],
      "sample_examples": [
        {
          "file": "samples/anchored_vwap.rts",
          "line": 25,
          "code": "avwap:\tVWMA(price, pivotBars)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "WalkForward",
      "title": "WalkForward",
      "aliases": [],
      "section": "17.18.566",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Script Sections",
      "description": "Defines lists of system parameter values by date for use in running a walk-forward test that was generated by a walk-forward optimization process",
      "example": "that uses walk-forward optimization to implement a strategy from an article.",
      "notes": "See Optimization Dialog and Walk-Forward Tests for details.If a script includes a Walk Forward section (not commented out), running it in single test mode will always use the variable parameter values as listed under Walk Forward. To run such a script with constant parameter values, comment out the Walk Forward section first.See spy_tlt_uis.rts in the Examples folder for an",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.566",
          "title": "WalkForward",
          "line": 5547
        }
      ],
      "sample_examples": [
        {
          "file": "samples/spy_tlt_uis.rts",
          "line": 5,
          "code": "To reproduce or update the WalkForward parameters, do this:"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Week",
      "title": "Week",
      "aliases": [],
      "section": "17.18.567",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Bar Data Values",
      "description": "Current bar's week of the year (1-52)",
      "example": null,
      "notes": "This function works identically to =WEEKNUM(cell, 2) in Excel.Neither Excel nor Real Test follow the ISO-8601 standard for week-of-year numbering.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.567",
          "title": "Week",
          "line": 5549
        }
      ],
      "sample_examples": [
        {
          "file": "samples/clenow_stocks_on_move.rts",
          "line": 41,
          "code": "TradeDay:\tExtern($SPY, DayOfWeek < 3 and  DayOfWeek[-1] >= 3) // Wed. (Thu. if holiday)"
        },
        {
          "file": "samples/clenow_stocks_on_move_dynamic.rts",
          "line": 41,
          "code": "TradeDay:\tExtern($SPY, DayOfWeek < 3 and  DayOfWeek[-1] >= 3) // Wed. (Thu. if holiday)"
        },
        {
          "file": "samples/combined.rts",
          "line": 29,
          "code": "// simple weekly rotation into the recently strongest asset -- stocks, bonds, or gold"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "WhenTrue",
      "title": "WhenTrue",
      "aliases": [],
      "section": "17.18.568",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Evaluates an expression for a past (or future) bar when a condition was (or will be) true",
      "example": null,
      "notes": "If nth is positive, condition is evaluated for the most recent bar and continue back in time until the nth non-zero value is found.If nth is negative, condition will be evaluated for the most recent bar and continue forward in time until the abs(nth) non-zero value is found.For each bar, condition is evaluated as if that bar were the current bar, i.e. without knowledge of future splits relative to that bar.When the specified nth condition is found, expression is then evaluated for that bar and the resulting value is returned.If condition is never found, the result is Na N.If nth is not\u2026",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.568",
          "title": "WhenTrue",
          "line": 5551
        }
      ],
      "sample_examples": [
        {
          "file": "samples/opex_and_vxex.rts",
          "line": 21,
          "code": "NextOpEx:\tWhenTrue(IsOpEx, BarDate, 25, -1)[-5]"
        },
        {
          "file": "samples/turtles.rts",
          "line": 39,
          "code": "extern(@longtrack,whentrue(t.points,t.points)), extern(@shorttrack,whentrue(t.points,t.points))) > 0)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "WMA",
      "title": "WMA or WAvg",
      "aliases": [
        "WAvg"
      ],
      "section": "17.18.569",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Weighted Moving Average",
      "example": null,
      "notes": "Either WMA or WAvg can be used as the name of this function.This type of moving average is calculated by putting the most weight on the most recent bar, fractionally less weight on the next bar, and so on. This link describes how the calculation is done in more detail.",
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.569",
          "title": "WMA or WAvg",
          "line": 5556
        }
      ],
      "sample_examples": [
        {
          "file": "samples/anchored_vwap.rts",
          "line": 25,
          "code": "avwap:\tVWMA(price, pivotBars)"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "Year",
      "title": "Year",
      "aliases": [],
      "section": "17.18.570",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Bar Data Values",
      "description": "Current bar year number Negative offsets, e.g. Year[-2], can be legitimately used to obtain the year of a future bar. This works even if the offset goes beyond the range of the currently loaded data file. For best results when future dates are required, a Holiday List should also be provided.",
      "example": null,
      "notes": null,
      "see_also": [],
      "manual_refs": [
        {
          "section": "17.18.570",
          "title": "Year",
          "line": 5558
        }
      ],
      "sample_examples": [
        {
          "file": "samples/annual_taxes.rts",
          "line": 5,
          "code": "eoy_month:\t12\t// fiscal year end month"
        },
        {
          "file": "samples/bensdorp_book.rts",
          "line": 8,
          "code": "StartDate:\t2014-01-01\t// one year earlier than test start date"
        },
        {
          "file": "samples/cii_rotate.rts",
          "line": 40,
          "code": "StartDate:\t1995-01-01 // one year later than import start date"
        }
      ],
      "grammar_match": false
    },
    {
      "name": "YInt",
      "title": "YInt",
      "aliases": [],
      "section": "17.18.571",
      "hierarchy": [
        "Realtest Script Language",
        "Syntax Element Details"
      ],
      "category": "Multi-Bar Functions",
      "description": "Linear regression y-intercept",
      "example": null,
      "notes": "Calculates the y-intercept of a linear regression of expr evaluated for the previous count bars.",
      "see_also": [
        "Slope and Lin Reg."
      ],
      "manual_refs": [
        {
          "section": "17.18.571",
          "title": "YInt",
          "line": 5560
        }
      ],
      "sample_examples": [],
      "grammar_match": false
    }
  ],
  "summary": {
    "total_entries": 571,
    "category_counts": {
      "Cross-Sectional Functions": 20,
      "Stock/Contract Information": 28,
      "General": 5,
      "Current Strategy Information": 4,
      "General-Purpose Functions": 53,
      "Settings": 41,
      "Import Specification": 30,
      "Indicator Functions": 24,
      "Multi-Bar Functions": 57,
      "Strategy Elements": 86,
      "Settings Input True or False (default is False)": 2,
      "Library Section": 1,
      "Bar Data Values": 28,
      "Current Position Information": 25,
      "Settings or Strategy Elements or Data": 1,
      "Script Sections": 29,
      "Syntax Element Details": 5,
      "Strategy Elements value to a position at entry time Input Formula expression property.A typical usage, along with the Max Same Cat element, is to limit the number of simultaneous positions from the same sector or industry. When using Norgate data, either the TRBC or GICS classification value for the current symbol can be referenced in the formula. Using TRBC along with the Top function is an especially convenient way to specify a for this purpose. For": 1,
      "Current Position Information strategy element formula for this position": 1,
      "General-Purpose Functions Descriptionevaluate stats expression using combined strategy results": 1,
      "String Functions": 14,
      "Daily Test Statistics": 64,
      "Settings or Strategy Elements": 1,
      "Strategy Elements for a strategy or group of strategies Input Any formula specifying a percentage would not exceed the percent of S.Alloc expressed as Max Cat Exp.Use the formula to define the of any security.If a setup cannot be selected due to this constraint and the strategy specifies Reduce: True, then the position's Quantity will be reduced to allow the position to be ordered for entry at smaller size if possible.Setups skipped for this reason display \"max cat exp\" in the Reason column of the Trade List, provided that the Keep Trades setting included Skipped.If Max Cat Exp is not\u2026": 1,
      "Strategy Elements for a strategy or group of strategies Input Any formula specifying a dollar amount would not exceed the dollar value expressed as Max Cat Inv.Use the formula to define the of any security.If a setup cannot be selected due to this constraint and the strategy specifies Reduce: True, then the position's Quantity will be reduced to allow the position to be ordered for entry at smaller size if possible.Setups skipped for this reason display \"max cat inv\" in the Reason column of the Trade List, provided that the Keep Trades setting included Skipped.If Max Cat Inv is not specified\u2026": 1,
      "Strategy Elements positions that can be open simultaneously in a strategy or group of strategies Input Any formula specifying a count as this setup of currently open positions plus previously selected setups plus one would not exceed the value returned by this formula.Use the formula to define the of any security.Setups skipped for this reason display \"max same \" in the Reason column of the Trade List, provided that the Keep Trades setting included Skipped.If Max Same Cat is not specified then there is no limit placed on the number of same- positions.": 1,
      "Settings or Order Settings": 4,
      "Settings or Order Settings or Strategy Elements": 5,
      "Settings or Test Settings": 1,
      "Trade Record Items": 31,
      "Trade Record Items exposure32 max invested": 1,
      "Trade Statistics Functions .": 5
    },
    "grammar_matches": 53,
    "entries_with_samples": 293
  }
}
