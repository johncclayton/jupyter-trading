# Plan 1: Extract and Understand RealTest Language

The goal is to extract as much information as possible about the real test script language into text files.

It's important to understand that some of the manual deals with the Real Test UI, and some of it with the Real Test
Script (.rts) language.  Focus on the script language - and not on the UI, unless the portions of the UI help provide
meaning and or context.

In the generated output, never use full path names - always use relative path names.  Where this might be a problem for further processing steps, make sure these steps resolve the relative path names properly.

All code goes into the tools/ directory.

Here are the general steps to extract:

1. **Prepare Versioned Artifacts**  
   - Input: Repository root containing at least one `RealTest*.pdf`, populated `samples/` with `.rts` examples.  
   - Actions: Identify newest matching PDF by timestamp; derive version name `YYYYMMDD-realtest-guide`; create `versions/<version>/`; move PDF to `versions/<version>/manual.pdf` and leave a copy in the repository root for future comparisons; ensure `samples/` exists.  
   - Output: `versions/<version>/manual.pdf`, ready-to-use `samples/` directory, retained original PDF.

2. **Run Standardized Text Extraction**  
   - Input: `versions/<version>/manual.pdf`.  
   - Actions: Implement a single reusable CLI in `tools/` that loads the manual once, normalizes the text, and exposes subcommands for each downstream artifact (starting with text extraction).  
   - Output: `versions/<version>/manual.txt` (UTF-8 plain text) generated by the shared loader.

3. **Build Manual Structure and Glossary**  
   - Input: `versions/<version>/manual.txt`.  
   - Actions: Use the shared CLI to parse headings and glossary terms from the normalized text into `manual_structure.json`.
   - Output: `versions/<version>/manual_structure.json` (sections list + glossary array).

4. **Compile Function, Directive, and Statement Catalog**  
   - Input: `versions/<version>/manual.txt`, `versions/<version>/manual_structure.json`, `samples/*.rts`, `bnf/lark/realtest.lark`.  
   - Actions: Start with manual-derived entries, then enrich with sample references, sanity-check against the existing grammar, and fold in watchlist context before writing `function_catalog.json`.  
   - Output: `versions/<version>/function_catalog.json`.

5. **Assemble LLM Prompt Assets**  
   - Input: Catalog, manual text, manual structure, grammar, and `watchlists.json`.  
   - Actions: Produce a concise cheat sheet, create a sample end-to-end prompt showing the recommended structure, and add a validation utility that reports token counts for any assembled prompt (skip dense retrieval indexing for now).  
   - Output: Prompt asset directory under `versions/<version>/` containing the cheat sheet, sample prompt, and a prompt-length checker script.
